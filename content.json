{"posts":[{"title":"1809坑：多余显示器，桌面变卡","text":"谨慎启用 Hyper-v ！，小心自动更新！ 在安装完 Windows 10 的 1809 版本之后，我的电脑两次出现了这样的情况：桌面变得非常卡，大概只有20帧的样子，在显示设置中出现了多个没有用的显示器，而我的笔记本并没有接上任何外接屏幕。 开启Hyper-v后出现多个多余显示器 | 微软社区 在百度之后确认了，多个显示器是因为我启用了 Hyper-v 功能而多出来的，这可能是 win 10 的一个 Bug 。而整个桌面的窗口变卡的原因有些不确定，因为在启用 Hyper-v 之后还经历了一次 windows 更新。 我尝试过在设备管理器中禁用多余的显示器，使用系统保护回到上一个还原点都没有效果，百度谷歌到的情况相同的问题也都没有解决。真是万不得已，最终只好备份所有文件重置了。也不知道是什么原因导致的这个问题，可能和特定型号的硬件有关吧。难受！ 所以，试用新版本的系统的时候一定要谨慎了，特别是在生产力机器上，一些奇怪的问题可能导致难以挽回的后果。 一些马后炮措施 启用系统还原。在 控制面板-&gt; 高级系统设置(系统属性) -&gt; 系统保护 中启用系统还原，每当进行重大操作的时候先建立一个还原点，在系统更新的时候也会自动创建还原点。出现问题的时候可以回退回去，需要的时间大约是20分钟。 关闭自动更新驱动。在 系统属性 -&gt; 硬件 -&gt; 设备安装设置 中，“是否要自动下载适合你设备的制造商应用和自定义图标”选项，选择“否”来避免系统自动搜索、安装、更新驱动。最新版本的驱动程序不一定是最好的，特别是显卡驱动。 重置。最后的最后，如果一切都无法挽回了，Windows 10 有重置的功能，在 设置 -&gt; 更新和安全 -&gt; 恢复 中可以重置系统。这个选项会重置整台电脑，恢复出厂设置，相当于自己重装系统，但是保留了驱动程序，省得再安装一次，相比手动重装节省时间。恢复一次可能需要半个小时。 5月5日后记：现在升级到了 1903，打开沙盒模式或启用 Hyper-v 的时候仍然会有多个屏幕，不过关闭功能之后重启两次就可以恢复了。 参见： win10开启Hyper-v后，多出四个非即插即用型监视器 - Microsoft Community win10 1709故障：开启 Hyper-v 后会出现多余的监视器 -W10之家","link":"/2019/02/25/1809-hyper-v-bug/"},{"title":"ANTLR 4 笔记","text":"“语言的边界就是思想的边界。” DSL 的误区 | 王垠 如何愉快地写个小parser - 知乎 Getting Started with ANTLR v4 | GitHub ANTLR 4权威指南 (豆瓣) The Definitive ANTLR 4 Reference 英文版和示例代码 是什么 ANTLR 是： 语法分析器的生成器：可以根据一个程序设计语言的语法描述自动生成语法分析器。 扫描器的生成器：可以根据一个语言的语法单元的正则表达式描述生成词法分析器。 语法制导的翻译引擎：ANTLR 会生成语法树并生成相应的访问器或者监听器类来遍历语法树。 使用 LL(*) 文法的解析器。 包含很多现成的语法定义，解析主流的语言都可以开箱即用：antlr/grammars-v4 · GitHub。 安装 命令行 https://www.antlr.org/download/ 1CLASSPATH =.;D:\\javalib\\*; 12:: antlr4.bat@java -cp .;D:\\javalib\\antlr-4.8-complete.jar org.antlr.v4.Tool %* 12::grun.bat@java -cp .;D:\\javalib\\antlr-4.8-complete.jar org.antlr.v4.gui.TestRig %* IDEA 安装插件 ANTLR v4 grammar plugin 在语法文件的规则上 右键 -&gt; Test Rule ... ，来实时测试语法树 在语法文件里面 右键 -&gt; Generate ANTLR Recognizer 来生成代码 VS Code 安装插件 ANTLR4 grammar syntax support。 Hello world 12345// Define a grammar called Hellogrammar Hello;r : 'hello' ID ; // match keyword hello followed by an identifierID : [a-z]+ ; // match lower-case identifiersWS : [ \\t\\r\\n]+ -&gt; skip ; // skip spaces, tabs, newlines 1234grun Hello r -guigrun Hello r -tokensgrun Hello r -treeantlr4 -no-listener -visitor xxx.g4 退出：Windows 按下 Ctrl + Z，Enter 退出。 遍历语法树 ANTLR 的监听器和访问器能够将语法和程序逻辑代码解耦，可以不需要在语法中内嵌动作。 使用访问器和监听器机制，我们可以完成一切与语法相关的事情。一旦进入Java的领域，就没有什么ANTLR的相关内容值得学习了。我们需要谨记在心的是，语法及其对应的语法分析树，以及访问器或者监听器事件方法之间的关系。除此之外，剩下的仅仅是普通的代码。在对输入文本进行识别时，我们可以产生输出、收集信息（正如本例中我们所做的）、用某种方式验证输入文本，或者执行计算。 Listener（监听器） 类似于 XML 的 SAX 解析。监听器的方法会被 Antlr 提供的遍历器对象自动调用。 可以用 ParseTreeProperty 来储存和获取变量。 123ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();values.put(ctx, values.get(ctx.getChild(0)));values.get(ctx.e(0)); Visitor（访问器） 访问器方法中，需要显式地调用 visit() 方法来访问子节点，可以自己定义怎么访问子树。 代码生成 Parser.java Lexer.java .tokens Listener.java 入门 语法导入 使用 import 可以让语法文件模块化。 标签 1234stat: expr NEWLINE # printExpr | ID '=' expr NEWLINE # assign | NEWLINE # blank ; 加了标签的备选分支，会生成相应的访问器方法。 语法分析 语法中嵌入动作 使用语义判定改变语法分析过程 词法分析 孤岛语法。例子：解析xml 重写输入流。例子：java代码添加序列化标识符 将词法送入不同通道。例子：忽略却保留注释和空白字符 开发 设计语法 起始规则，词法符号，语法规范 常见的语言模式 序列（sequence） 选择（choice） 词法符号依赖（token dependency） 嵌套结构（nested phrase） 序列模式 比如一个协议语言POP，由关键字、整数和换行组成。 1retr : 'RETR' INT '\\n' 任意长度序列可以用 + 字符。(INT)+ 或者 INT+。 可以为空，零个或多个用 *。 零个或一个：?。 选择模式（多个备选分支） 使用符号 | 作为“或者”来表达编程语言中的选择模式。备选分支（alternative）或者可生成的结果（productions）。 1type : 'float' | 'int' | 'void' 词法符号依赖模式 依赖符号的语法，比如数组的括号。表达对符号的依赖的方法。 1vector : '[' INT+ ']' ; // [1], [1 2], [1 2 3], ... 嵌套模式 自己引用自己。如果一条规则定义中的伪代码引用了它自身，就需要一条递归规则（自引用规则）。 直接递归和间接递归。 1234expr : ID '[' expr ']' | '(' expr ')' | INT ; 左递归和优先级 经典的从左到右自顶向下的语法分析器无法处理左递归。算符优先级带来的问题。ANTLR解决的方式是，写在前面的语法拥有较高的优先级。如果遇到了从右向左结合的，需要使用 assoc 手工指定结合性： 123expr : &lt;assoc=right&gt; expr '^' expr | INT ; ANTLR 4 可以能够处理直接左递归，但是不能处理间接左递归。 识别词法 匹配标识符 1ID : ('a'..'z'|'A'..'Z')+ ; //匹配1个或多个大小写字母 或者： 1ID : [a-zA-z]+ ; ID 规则可能和其他规则冲突，比如其他关键字 enum 或 for。所以要把 ID 规则放在所有关键字规则之后。 匹配数字 1INT : '0'..'9'+ ; 或者 1INT : [0-9]+ ; 浮点数： 12345FLOAT : DIGIT+ '.' DIGIT* // 1. 3.14 | '.' DIGIT+ // .1 .1415 ;fragmentDIGIT : [0-9] ; // 单个数字 将一条规则声明为 fragment 可以告诉ANTLR，该规则本身不是一个词法符号，它只会被其他的词法规则使用。 字符串 1STRING : '&quot;' .*? '&quot;' ; . 匹配任意单个字符，.* 匹配零个或多个，? 标记表示使用非贪婪匹配子规则（nongreedy subrule）。 转义字符： 123STRING : '&quot;' (ESC|.)*? '&quot;' ;fragmentESC : '\\\\&quot;' | '\\\\\\\\' ; // 转义 \\&quot; 和 \\\\ 注释和空白字符 C 中的单行和多行注释： 1LINE_COMINT : '//' .*? '\\r'? '\\n' -&gt; skip ; // 消费掉双斜杠后面的一切字符，直到遇到换行符 空白字符： 1WS : [ \\t\\r\\n]+ -&gt; skip ; 解析现成的语言 要想揭开一门语言的神秘面纱，我们需要分析不同来源的信息。语言的规模越大，我们需要的参考文档和各式各样的范例代码就越多。有时候，只有设法对语言现有的实现进行试探，才能发现边界情况。语言的参考文档通常并非一目了然。 CSV JSON DOT Cymbol 语法和程序逻辑 在事件方法中共享信息 使用访问器的方法来返回值 继承 BasicVisitor 的时候指定泛型 使用类的成员在事件方法之间共享数据 比如在监听器的类中声明一个栈，每个子表达式的结果退入栈中，然后在更高层的节点中取出来。 对语法分析树的结点进行标注 可以直接将语句绑定在语法上，这样每一个节点都会有这个值：e returns [int value] ...; 。 使用 ParseTreeProperty 的辅助类，本质上是 IdentityHashMap，用节点对象作为键。 高级特性 上下文相关的词法问题 （12章第二节） 因为ANTLR自动生成的语法分析器经常在词法符号流中进行非常远的前瞻以作出语法分析决策。这意味着，远在语法分析器能够执行提供上下文信息的行为之前，词法分析器就需要将字符流处理为词法符号。 因为这样，处理上下文相关的词法问题变得比较困难。 关键字作为标识符的问题的解决方法是，令词法分析器将所有关键字当作词法符号送给语法分析器。","link":"/2020/10/21/antlr-v4-note/"},{"title":"Hexo 安装配置笔记","text":"记录 Hexo 的安装过程（踩过的坑）。 是的，我从 WordPress 转移到了 Hexo…… 相比于功能庞大的 WordPress，小巧简单的静态网页生成器有它的特点： 不需要 SQL 数据库 （再也不用备份数据库了） 没有后台管理，直接编辑文章和配置文件 （再也不怕忘记管理员密码了） 生成的是静态网页，不仅可以部署在 VPS 上，还可以托管在 GitHub Pages 等平台 本质是 Markdown 解析器，自然地对 Markdown 支持相当好 如果你像我一样，习惯用 Markdown 来记笔记、写日志，那么使用 Hexo、Hugo、Jekyll 这类生成器是最好不过了。它们直接使用 md 文件来渲染网页，把一篇写好的笔记转换成可以公开的博客不需要任何的格式转换操作。这种所见即所得的写作方式，相信你一定会喜欢上的~ 安装 Hexo 文档：https://hexo.io/zh-cn/docs/ GitHub: https://github.com/hexojs/hexo 123npm install hexo-clinpm install hexo-server --savenpm install hexo-deployer-git --save 常用命令： 1hexo new [layout] &lt;title&gt; 本地图片显问题 在 _config.yml 文件里面把 post_asset_folder 设置为 true。 安装 hexo-asset-image 插件。 1npm install hexo-asset-image --save 文章中插入图片： 1{% asset_img \"span>\" '\"\" \"图片\"' %} 这样在 Markdown 编辑器里面能看到同名文件夹的图片，生成的静态网页也能显示图片。 Front-matter 12345678910---title: Hexo 安装配置笔记date: 2019-12-28 17:01:06categories: - 日志tags: - Hexo - 博客permalink: hexo-configuration--- 在文章最开始的几行字。用来标识标题和日期。其中一个很有用的就是 permalink。静态网页会根据它的值来设置文章的 URL。这样一来，md 文件的名字就可以随便取了。 20220913 更新：新版的 permalink 含义似乎变了，会替换整个 URL，包括日期前缀。需要自定义变量来实现，可以看下文档。 分类和标签 在文章的 front-matter 中指定了标签和分类，那么在生成网页后，就有了对应的页面。 比如 categories: 日志，就会生成 /categories/日志。 如果不想在 URL 里面显示中文，可以自定义标签和分类的路径，在配置文件里面这么写： 1234567category_map: 日志: log 软件: softwaretag_map: 反向代理: reverse-proxy 安全: security 无线: wireless 归档和标签的分页 归档页面应该让人一眼看到所有文章，但是 Hexo 默认会将它按数量分成页面显示，看起来很不直观。 123456789101112# _config.yml# 设置首页分页之前默认就有，这里就不额外加了# index_generator:# per_page: 5archive_generator: per_page: 0 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: false #为了加快生成速度，按月归档就不要了tag_generator: per_page: 0 #值为0表示不分页，按需填写 Hexo博客归档不分页显示设置方法 | 搜百谷 站点地图 使用站点地图来方便被收索引擎收录。 GitHub: https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap 1npm install hexo-generator-seo-friendly-sitemap --save RSS 添加 RSS 订阅。 GitHub: https://github.com/hexojs/hexo-generator-feed 1npm install hexo-generator-feed 我的配置文件： 12345678910111213# _config.yml# hexo-generator-feedfeed: type: - atom - rss2 path: - atom.xml - feed.xml limit: false content: true order_by: -date icon: icon.ico 不渲染特定文件 hexo 会把所有 md 和 html 文件渲染成主题的样式，但是这又是不是我们想要的。 123# _config.ymlskip_render: - &quot;**/*.html&quot; **/*.html 可以使它跳过渲染目录下的所有 html 文件。 NexT 主题 文档：https://theme-next.org/docs/ GitHub: https://github.com/theme-next/hexo-theme-next 12cd hexogit clone https://github.com/theme-next/hexo-theme-next themes/next PJAX Pjax 即 HTML5 的 pushState + Ajax。这个技术通过异步加载和更改浏览器地址栏实现了无刷新加载网页。由于只加载部分页面，减少了请求的次数和内容，打开网页将会很快。 安装插件 theme-next-pjax： 12cd themes/nextgit clone https://github.com/theme-next/theme-next-pjax source/lib/pjax 然后开启 NexT 的 Pjax： 12# next/_config.ymlpjax: true 但是启用 pjax 以后添加自定义的 js 控件将会变得比较困难。 关闭动画 123# next/_config.ymlmotion: enable: false NexT 默认是开启动画的，就是打开网页时的淡入效果。结果就是让读者晚一秒种看到正文内容……有什么用呢？关了关了。 菜单启用分类和标签 新建一个页面： 1hexo new page categories 然后编辑这个文件的 Front-matter： 123456---title: 分类date: 2019-12-30 16:54:16type: categoriescomments: false--- 配置文件里面去掉 categories 项的注释： 12345menu: home: / || home #about: /about/ || user #tags: /tags/ || tags categories: /categories/ || th 启用标签菜单同理。 评论系统 主题提供了很多可选的评论系统。我选了 Valine，一个基于服务商 Leancode 的评论系统。 使用之前要去 Leancloud 注册和创建应用，然后再设置 -&gt; 应用 Keys 里面，获得应用的 AppID 和 AppKey，写到 NexT 的配置文件里面去。 1234567891011121314151617# next/_config.ymlvaline: enable: true appid: 53p6sFAYCBY1FfEX9nOa3byP-gzGzoHsz appkey: V6tCmUsramFioGA0GbBETOLR notify: false # Mail notifier verify: false # Verification code placeholder: （っ╹◡╹）ﾉ❀ # Comment box placeholder avatar: mm # Gravatar style guest_info: nick,mail,link # Custom comment header pageSize: 10 # Pagination size language: # Language, available values: en, zh-cn visitor: false # Article reading statistic comment_count: false # If false, comment count will only be displayed in post page, not in home page recordIP: false # Whether to record the commenter IP serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in) #post_meta_order: 0 比较重要的就是 comment_count 参数，设置为 false 来让评论数不在首页显示（post meta），只在文章页面显示。 LaTeX 写公式必备。 12sudo apt-get install pandocnpm install hexo-renderer-pandoc --save 启用 pandoc 之后图片会有描述，和 fancybox 插件显示重复，改一下样式： 123456789101112/* source/_data/styles.styl *//* pandoc */figure figcaption { font-size: 0.8em; text-align: center;}/* fancybox */.image-caption { display: none;} 12345678910111213# next/_config.ymlcustom_file_path: # style 这一行取消注释 style: source/_data/styles.stylmath: # 设置为 false 需要在要渲染的文章的 Front-matter 里面加上 `mathjax: true` per_page: false mathjax: enable: true # See: https://mhchem.github.io/MathJax-mhchem/ mhchem: false 因为 pandoc 渲染器的语法要求比较严格，所以在安装完之后记得要检查一下以前写过的文章，可能会有所变化。 搜索 启用 Hexo 的本地搜索功能。 1npm install hexo-generator-searchdb --save 12345# next/_config.yml# Local Search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true 静态博客怎么搜索呢？安装这个插件后，生成了一个 search.xml，里面包含了博客里面的全部文本。搜索的时候会加载这个文件进行查找。 参见： hexo中完美插入本地图片 | ETRD博客 Hexo使用攻略-添加分类及标签 | linlif-blog YAML 语言教程 - 阮一峰的网络日志 Hexo使用攻略：（四）Hexo的分类和标签设置 | { GoonX } 为你的Hexo加上评论系统-Valine | BlueLzy's Blog","link":"/2019/12/28/hexo-configuration/"},{"title":"Dokcer 的远程连接和部署","text":"让远程部署和本地一样简单！ TL;DR Docker 是 C/S 架构的，服务端和客户端可以在不同主机运行 无加密的 TCP 连接配置简单，但不安全 TLS 加密的连接需要创建和配置证书，最常用 SSH 连接使用方便，但是 IDE 不大兼容，比较局限 命令行、IDEA、VS Code 怎么连接 Docker daemon 一个小 demo，用 Dokcer client 部署 Spring Boot 项目 20220913 更新：现在 SSH 连接的方式已经被大部分软件支持了，别的方式的可以不用看了。 Docker 的架构 最近在学习用 Docker 来部署项目。我按照这个教程来把 Java 项目部署到了服务器的 Docker 上面。IDEA 的 Dokcer 插件真的是特别方便，配置好之后一键就能部署上去，而且 Windows 本机上也不需要安装几百兆的 Docker Desktop，不用开启 Hyper-V。这是怎么实现的呢？ 从 Docker 的官方文档里面可以看到，Docker 使用的是 C/S 架构的系统，分为客户端和服务端。客户端（Docker client）使用命令和服务端（Dokcer daemon，守护进程）进行交互。守护进程负责干重活，比如构建、运行和分发你的容器。客户端和守护进程可以运行在同一台主机，也就是我们常规的安装；也可以让客户端连接到一台远程的守护进程。客户端和守护进程使用 REST API 进行交互，通过 UNIX sockets 或者网络接口进行传输。 所以我们如果只需要连接远程服务器的 Docker 的话，就没有必要在本地安装完整的 Docker，不需要安装 Docker daemon，只需要有能与 Docker daemon 进行交互的客户端，比如 Docker client，就可以了。 连接 Docker daemon 在默认的设置下，Docker daemon 只监听来自本地的 UNIX socket 连接。 在 /lib/systemd/system/docker.service 下面可以看到 dockerd，即 Docker daemon 的启动参数： 1ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 我们需要修改这个 systemd 的启动参数来开启外部访问。 使用无加密 TCP 连接 使用 sudo systemctl edit docker.service 来编辑 docker.service，这会在它的基础上重写配置。 写上下面的内容，保存文件。 123[Service]ExecStart=ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 上面这个 ExecStart= 的作用是清空原来项目的值，然后用新的值替代。官方文档这么写的，我之前还以为是笔误…… 更新 systemctl 配置和重启 Docker。 12sudo systemctl daemon-reloadsudo systemctl restart docker.service 检查 dockerd 是否运行起来 1sudo netstat -lntp | grep dockerd 现在我们已经开放了 TCP 的 2375 端口，只要在执行命令的时候加上参数就可以了： 1docker -H tcp://docker.beanbang.cn:2375 version 也可以设置环境变量 DOCKER_HOST，这样就不用每次都带参数： 12export DOCKER_HOST=tcp://docker.beanbang.cn:2375docker version 注意：使用这种连接方式是不安全的，端口并没有加密，这意味者任何人都可以连接你的 Docker daemon，往里面运行容器。虚拟机用还好，云服务器上要是被别有用心的人发现了不是纯白给了。所以加密你的 Docker 端口还是很有必要的。 使用 TLS 加密的 TCP 连接 需要使用 OpenSSL 生成密钥，证书。客户端和守护进程使用这些证书和密钥来进行认证。只要照着官方文档的这篇文章，一步一步做下来就可以了: Protect the Docker daemon socket | Docker Documentation 生成证书的大致过程是，生成 CA 的密钥和 CA 证书，生成客户端和服务端的密钥；生成客户端和服务端的签名请求，然后 CA 分别对客户端和服务端的签名请求生成证书。 跟着教程一顿操作之后，可以得到下面的几个文件。 文件 描述 ca-key.pem CA 密钥 ca.pem CA 证书 server-key.pem 服务端密钥 server-cert.pem 服务端证书 key.pem 客户端密钥 cert.pem 客户端证书 然后我们接着修改 docker.service。虽然可以这么写： 1sudo systemctl edit docker.service 1234[Service]ExecStart=ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/home/ubuntu/certificate/ca.pem --tlscert=/home/ubuntu/certificate/server-cert.pem --tlskey=/home/ubuntu/certificate/server-key.pem \\ -H tcp://0.0.0.0:2376 -H fd:// 不过，这样大长串的参数很不直观。下面我们换成使用 Docker 提供的另一种配置 dockerd 的方式，就是 daemon.json 文件。 1sudo vim /etc/docker/daemon.json 12345678910{ &quot;hosts&quot;: [ &quot;fd://&quot;, &quot;tcp://0.0.0.0:2376&quot; ], &quot;tlsverify&quot;: true, &quot;tlscacert&quot;: &quot;/home/ubuntu/certificate/ca.pem&quot;, &quot;tlscert&quot;: &quot;/home/ubuntu/certificate/server-cert.pem&quot;, &quot;tlskey&quot;: &quot;/home/ubuntu/certificate/server-key.pem&quot;} 原本的 docker.service 只保留一点东西： 1sudo vim /etc/docker/daemon.json 123[Service]ExecStart=ExecStart=/usr/bin/dockerd 然后重启 Docker 就可以了。 注意：Docker 在启动的时候会同时使用 systemd 和 daemon.json 文件。如果两个文件的配置项冲突了，会造成无法启动。所以配置要么写 docker.service 里面，要么写 daemon.json 里面，不要两个都写，防止出现问题。 注意2：按照惯例，不加密的 TCP 连接使用 2375 端口，TLS 加密的 TCP 连接使用 2376 端口。 运行起来后，客户端连接需要 ca.pem，cert.pem，key.pem 三个文件。我们可以把它们从主机上拷贝下来，放在自己用户目录的 .docker 目录下，这是证书文件的默认查找目录。 纯命令： 12docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem \\ -H=docker.beanbang.cn:2376 version 使用环境变量： 123export DOCKER_HOST=tcp://docker.beanbang.cn:2376 DOCKER_TLS_VERIFY=1export DOCKER_CERT_PATH=$HOME/.docker # 证书在默认查找目录可以不用指定docker version 使用 SSH 连接 从 Docker 的 18.09 版本开始，Docker client 支持通过 SSH 来连接远程 daemon 了。但是到了今天（2020年8月），我能直接下载到的最新 Dokcer client for Windows 版本是 17.09。IDEA 和 VS Code 这些 IDE 我也试过，同样不能使用 SSH 协议来连接。所以这种方法虽然特别方便，但是目前还是比较有局限性的。 要使用 SSH 协议来连接 Docker daemon，你可以使用 Linux 或者 WSL 安装新版的 docker-cli。 服务端不需要任何配置，只需要在客户端执行命令： 1docker -H ssh://ubuntu@192.168.43.220 version 注意，这边主机名只能使用 IP 地址，不能使用域名。 这种方式是使用 SSH 密钥登录和认证的，如果你没有使用密钥来登录主机，可以现配置一个： 检查一下你的用户目录下的 .ssh 文件夹下面有没有 id_rsa 和 id_rsa.pub 文件。如果你在用 Git，可能已经创建过密钥了。 没有的话就创建： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把你的公钥添加到远程主机： 1ssh-copy-id ubuntu@192.168.43.220 Windows 没有这个命令的话就手动把 id_rsa.pub 里面的内容添加到远程主机用户的 ~/.ssh/authorized_keys 里面。 这就行了。同样可以把这个连接串设置到环境变量中，方便使用： 1export DOCKER_HOST=ssh://ubuntu@192.168.43.220 客户端配置 命令行 Windows 直接安装 Docker desktop 是可以的，安装完成之后就可以使用 docker 命令了。但是假如我们本地只想用客户端的功能，不想安装它那厚重的 Docker Engine，可以只下载几个二进制可执行文件。下面是下载地址: Docker CLI Windows：https://download.docker.com/win/static/stable/x86_64/ Docker compose：https://github.com/docker/compose/releases 下载完成后，重命名成 docker.exe 和 docker-compose.exe，丢进设置过 Path 环境变量的文件夹里就可以了。 Linux Linux 客户端只需要安装 docker-ce-cli。这里推荐一下清华 tuna 镜像源，提供了 docker-ce 的镜像和安装教程。 IntelliJ IDEA IDEA 里面图形化的设置很方便。如果使用了加密的 TCP，要选定证书的文件夹，并且 URL 要写成 https://docker.beanbang.cn:2376 这样的以 https 开头的形式。 IDEA 添加 Docker 连接 VS Code 首先安装 Docker 插件，然后修改配置文件。 123456// settings.json{ &quot;docker.host&quot;: &quot;tcp://docker.beanbang.cn:2376&quot;, &quot;docker.tlsVerify&quot;: &quot;1&quot;, &quot;docker.certPath&quot;: &quot;C:\\\\Users\\\\GYM\\\\.docker&quot;} VS Code 配置连接 Docker 试试看！ 连接上远程 Docker 之后，我们就可以尝试远程部署了。这是一个例子，在 Windows 10 上用 Dokcer CLI 部署一个 Spring Boot 项目到远程服务器上。我使用的是 TLS 加密的 TCP，就是上面的提到的配置。 环境变量： 123$ set | findstr DOCKERDOCKER_HOST=tcp://docker.beanbang.cn:2376DOCKER_TLS_VERIFY=1 在 Spring initializr 上面创建项目并下载到本地。 使用 Spring initializr 来初始化项目 添加一个控制器： 1234567891011121314package cn.beanbang.demo.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(@RequestParam(defaultValue = &quot;world&quot;) String name) { return String.format(&quot;Hello, %s!&quot;, name); }} 执行 mvnw package 命令打包。会在 target 目录下生成 rest-test-0.0.1-SNAPSHOT.jar 文件。 在项目的目录下创建 Dockerfile 文件： 1234FROM openjdk:8-jreADD target/rest-test-0.0.1-SNAPSHOT.jar app.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 然后可以开始部署了。 创建容器： 1234567891011121314151617$ docker build -t rest-test .Sending build context to Docker daemon 16.78MBStep 1/4 : FROM openjdk:8-jre ---&gt; 2e2653debbe9Step 2/4 : ADD target/rest-test-0.0.1-SNAPSHOT.jar app.jar ---&gt; a80c846520e1Step 3/4 : EXPOSE 8080 ---&gt; Running in 68400e62b5cdRemoving intermediate container 68400e62b5cd ---&gt; fb69206fbe08Step 4/4 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] ---&gt; Running in 3e03c7f8804eRemoving intermediate container 3e03c7f8804e ---&gt; df0e8cc51568Successfully built df0e8cc51568Successfully tagged rest-test:latestSECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories. 运行容器： 12$ docker run --name rest-demo -p 8081:8080 -d rest-testdd164ec7f237ba8736f2253ab2b226a66700733ed85e52cacee52345ec28f71b 显示容器日志和测试接口 这样，一个简单的 Java Web 服务就搭建起来了。在执行 docker build 命令的时候，Docker 会把构建所需要的文件上传到服务端的 daemon，然后 daemon 负责创建镜像和后续的容器运行等流程。 参见： Protect the Docker daemon socket | Docker Documentation dockerd | Docker Documentation Post-installation steps for Linux | Docker Documentation Docker Tips: Access the Docker Daemon via SSH | by Luc Juggery | Medium","link":"/2020/08/31/remote-access-and-deployment-of-docker/"},{"title":"IDEA 生成类和方法注释","text":"IDEA 可以自动生成 Javadoc 格式的注释。 快速补全注释 IntelliJ IDEA 提供了自动补全文档格式注释的方法。只要在声明语句的前面打上 /** 然后按下回车，IDE 就会自动给你补全注释。对于方法的注释，产生的注释片段会包含所需要的标签（每个参数的 @param 标签、@return、@throws等等）。 IDEA 的文档注释补全 文档格式的注释也支持 JavaScript、Python、Ruby、和 PHP。 使用 Fix doc comment 动作 把光标放在一段类，方法，函数或者成员变量中，然后按下 Ctrl+Shift+A。 打上 fix doc comment 然后按下回车。 IDEA 就会自动给注释增加上缺失部分的标签。 fix doc comment 动作 | IDEA 帮助文档 如果一个方法的特征改变了，IDEA会高亮出不匹配部分的标签，然后提出快速修改的建议。 标签的自动补全 对于文档注释的标签，IDEA 也提供了代码自动补全。在 @ 标记的后面按下 Ctrl+Space ，然后就能够从弹出建议的列表里面选择需要的标签了。如果标签包含多个值（比如 @param），可以在建议的列表里面继续选择。 标签的补全 | IDEA 帮助文档 但是 Ctrl+Space 在微软拼音输入法里面是切换中英文的快捷方式，造成冲突而且不能改变……你可以添加一个英语语言，然后按 Win+Space切换到英语键盘来编码。 有什么好处 你一定查过 Java 的 API 文档。这份文档是怎么制作的呢？没错，用的就是 Javadoc 格式的注释。查看 JDK 的源码，你就能发现这种格式的注释。只要我们按照这种规范来编写注释，就能使用 javadoc 工具从代码生成 HTML 文档。 （文档和代码的耦合性这么高，难道这就是 Java 一直没有中文文档的原因……） 还有一个好处就是，IDEA 也会识别这种注释。将光标移动到类名或方法名上，按下 Ctrl+Q，就会弹出气泡提示： IDEA 显示快速文档查看气泡 自动气泡提示 如果要让鼠标移动到类名上自动弹出提示，可以这么做： File -&gt; Settings.. -&gt; Editor -&gt; General，找到项目 Show quick documentation on mouse move，勾选上就可以了。 设置自动显示气泡提示 参考资料： Documenting code - Help | IntelliJ IDEA Code reference information - Help | IntelliJ IDEA Javadoc - 维基百科，自由的百科全书","link":"/2020/02/03/idea-documenting-code/"},{"title":"KMS 服务器 vlmcsd 的安装和激活","text":"微软防盗，批量授权。假传圣旨，在线激活~ KMS (Key Management Service) 是微软针对 Windows 系统和软件的一种激活机制。通过在网络中设置 KMS 服务器给局域网中的系统批量激活。用这种方式激活的机子有激活周期，一般是6个月。这样既使系统激活的步骤简化，也使激活范围限制在一定的范围之内。 后来微软的官方 KMS 服务器被反向破解了，于是有大神 Hotbird64 制作了开源的仿真 KMS 服务器 vlmcsd （原帖MyDigitalLife），成为了一种盗版 Windows 的一种激活方式。模拟官方服务器，假传圣旨，激活一次，管用180天。 所以，即日起，小站开始提供 Windows 和 Office 的正版激活服务啦！只要你的系统满足以下条件就可以使用该方法激活： 使用的是批量授权的系统，即 VL 版本（Volume License）； 使用对应版本的 KMS 客户端安装密钥，即GVLK（Generic Volume Licensing Key）。 一般来说，我们从 MSDN,我告诉你 网站下载选择带 VL 、 VOL 或 business edition 字样的系统镜像，都会是可以使用KMS激活的版本，安装完后会自带GVLK密钥。 激活 Windows 使用管理员执行以下命令： 123slmgr.vbs /skms kms.beanbang.cn # 设置kms服务器slmgr.vbs /ato # 激活slmgr.vbs /xpr # 查看激活时效 如果之前有过修改密钥的操作，可以将密钥修改回对应版本 GVLK。Win10 专业版的密钥是W269N-WFGWX-YVC9B-4J6C9-T83GX，其他密钥可以去微软的 激活指南 里查找。如果不知道系统版本，可以运行wmic os get caption查看。 12slmgr.vbs /upk # 清除密钥slmgr.vbs /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX # Win10专业版 然后再添加上面的KMS服务器激活。 win10激活成功 Office 管理员运行： 123cd /d D:\\Program Files\\Microsoft Office\\Office16 # office安装位置cscript ospp.vbs /sethst:kms.beanbang.cn # 设置kms服务器cscript ospp.vbs /act # 立即激活 如果需要 GVLK 同样可以在微软的 文档 中找到。 1cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 #2016专业增强版 office2016激活成功 如果在激活过程中出现问题，可以移步下载这个方便的图形化软件 Office Tool Plus 来操作： OTP图形化激活office 安装 vlmcsd 的服务端可以运行在 VPS 上，也可以运行在相同局域网下的电脑上，树莓派上，甚至是手机上，只要 IP 地址是可以到达的就可以。但是不能安装在被激活的电脑上，因为激活系统是会自己检测到的。 Docker 2021年7月17日更新：来用 Docker 吧，省时省力。 1234567git clone https://github.com/Lazyb0x/vlmcsd-docker.git vlmcsdcd vlmcsdgit clone --branch master --single-branch https://github.com/Wind4/vlmcsd.gitdocker-compose builddocker-compose up -d 服务器 下载地址：源码+可执行文件 密码2018 | Github Releases 在binaries目录中可以看到已经为各个操作系统和处理器编译好的可执行文件，进入到你的系统的对应 CPU 架构目录中，一般都是intel，Linux 系统不确定可以用cat /proc/cpuinfo命令查询。 123wget https://github.com/Wind4/vlmcsd/releases/download/svn1112/binaries.tar.gztar -zxvf binaries.tar.gzcd binaries/Linux/intel/static/ 进入static目录下文件如下： 12345~/vlmcsd/binaries/Linux/intel/static$ lsvlmcsdmulti-x64-musl-static vlmcsd-x86-musl-staticvlmcsdmulti-x86-musl-static vlmcsd-x86-musl-static-threadsvlmcsdmulti-x86-musl-static-threads vlmcs-x64-musl-staticvlmcsd-x64-musl-static vlmcs-x86-musl-static vlmcsd 开头的就是服务端文件，vlmcs 用来检测运行的 KMS 服务，vlmcsdmulti 有前面两个的功能。 运行： 1./vlmcsd-x64-musl-static -l log.txt 运行后会在 1688 端口上开启服务，所以记得需要在防火墙，VPS 等设置上允许 1688 端口的 TCP 数据包通过。 结束： 12ps -A|grep vlmcsd # 得到进程号，比如11611kill 11611 虚拟机 在Hotbitd64提供的压缩包内还有一个floppy文件夹内有一个不到2Mb大小的 vfd 软盘映像文件，里面是一个微型激活系统，可以在各种虚拟机上，比如 Vitrualbox ，Windows 自带的 Hyper-v 上运行来激活系统，非常方便（这人也太厉害了8）。只有一个需要注意的问题，就是虚拟机的联网方式。 桥接网络和host-only模式都可以 系统在激活的时候会检测服务器的 IP 地址，如果发现 ip 地址是本机 ip，就会报错，激活失败。所以应该选择诸如桥接网卡等能够分配独立 ip 且可以访问得到的联网方式。 虚拟机界面 启动虚拟机后服务器就开始工作了，只要按照前面的操作，填写虚拟机上显示的的 IPv4 地址就可以激活了。 最后，给这个二级域名做了一个简单的网页~ kms.beanbang.cn 参考资料 Emulated KMS Servers on non-Windows platforms | My Digital Life Forums 本站上线KMS服务~一句命令激活windows/office | 零散坑（详细的激活教程） 自建KMS激活服务器的两种方法 电脑问题 | 花火时光 Windows 版本和授权激活方式介绍(KMS MAK)_godspeed_新浪博客 OfficeToolPlus 说明文档 · GitHub","link":"/2019/01/31/kms-server-vlmcsd/"},{"title":"Leetcode 11：盛最多水的容器 双指针法的证明","text":"翻译一篇双指针法的证明，来自 Leetcode 主站 kongweihan 的评论。 原问题按此：盛最多水的容器 - 力扣（LeetCode）。 leetcode_question_11 这是用矩阵来表示的另一种方法： 画一个矩阵，它的行表示第一条线段，列表示第二条线段。用 n=6 的情况做个例子。 在下图中，x 表示我们不需要计算的面积，因为：（1）对角线上的值，代表两条线重叠了；（2）矩阵左下角三角形区域和右上角是对称的。 我们从 (1,6) 开始来计算面积，用 o 来表示。现在，如果左边的线段比右边的短，那么在第一行的除 (1,6) 外的所有元素的面积都小于（等于）它。所以对于这些情况我们就不需要计算它们的值了（用 --- 划掉 ）。 1234567 1 2 3 4 5 61 x ------- o2 x x3 x x x 4 x x x x5 x x x x x6 x x x x x x 然后我们移动左边的线段，计算 (2,6)。现在，如果右边的线段短一些，所有低于 (2,6) 的情况都可以排除了。 1234567 1 2 3 4 5 61 x ------- o2 x x o3 x x x |4 x x x x |5 x x x x x |6 x x x x x x 无论这条 o 的路径是怎样的，我们最终只要找到这条路径上最大的数值就可以了，而这需要 n-1 步计算。 1234567 1 2 3 4 5 61 x ------- o2 x x - o o o3 x x x o | |4 x x x x | |5 x x x x x |6 x x x x x x 希望对你有所帮助。用这种方式来看我觉得舒服多了。 下面是我参考题解写的。真的很难想到，这题能用复杂度为 O(n) 的方法解决。 1234567891011121314151617181920212223242526// Q010.javaclass Solution10 { public int maxArea(int[] height) { int l = 0; int r = height.length-1; int max = 0; while(l&lt;r) { max = Math.max(max, Math.min(height[l], height[r])*(r-l)); if (height[l]&lt;height[r]) l++; else r--; } return max; }}public class Q010 { public static void main(String[] args) { Solution10 s = new Solution10(); int[] a = {1,8,6,2,5,4,8,3,7}; int m = s.maxArea(a); System.out.println(m); }}","link":"/2019/05/05/leetcode-11-two-pointer-approach/"},{"title":"Leetcode 72：编辑距离 - 动态规划的解题思路","text":"记录题解，也借这个过程捋一捋动态规划的思路和方法。 原题目按此：72. 编辑距离 - 力扣（LeetCode）。 题目描述 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 比如 horse 转换到 ros 所需要的最小操作数是 3，或者说 horse 到 ros 的距离是 3. 开始 能够用动态规划求解的问题通常具有下面的几个特点： 让你求某个问题的一个最优解 这个问题能够拆分成更小的子问题（递归求解/分治法） 会重复求解相同的子问题 满足这些条件，这个问题就是一个动态规划问题了。求解问题也是按照这些步骤来进行。 我们根据《算法导论》上面提供的步骤来。 1. 刻画一个最优解的结构特征 “如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质。”1 也就是说这一步我们需要正确的划分子问题，让子问题有最优解的时候，原问题也有最优解。想办法找到和原问题形式一样，但是规模比较小的问题。 所以我们可以考虑，两个字符串的距离，可以由另外两个字符串的距离的基础上，插入/删除/替换了一个字符来得到。 设置两个指针 i 和 j，分别放在原字符 word1 和替换字符 word2 的最后，指针从右往左移，操作 word1[i]，让它和 word2[j] 相同。指针经过的地方代表这一部分的字符串已经完成了转换。 12345 horsei: ↑ rosj: ↑ 那么，对每一个字符，这边就以 horse 的 e 作为例子，我们能有这么几种操作： 1 在 e 的右边插入字符 s。 12345horses ↑ ros ↑ 假如我们知道 horse -&gt; ro 的距离为 n，那么总编辑距离就是 n+1。 2 删除字符 e。接下来需要计算 hors -&gt; ros 的距离。距离 +1。 12345hors ↑ ros ↑ 3 把 e 替换成 s。接下来需要计算 hors -&gt; ro 的距离。注意，这里如果两个字母相同，就不用转换了，这时候相当于代价为0，直接等价于子问题。 12345horss ↑ ros ↑ 对于这一个字符的修改，相当于是做出了一种选择：我们不知道对这个字符 e 怎么处理最终编辑的距离会最短，所以假设每一种可能性都是最优解并且去尝试。通过上面的例子我们发现，子问题中需要求的字符串长度已经缩短了，说明这种方法是可行的。 2. 递归地定义最优解的值 设 m[i, j] 表示 word1[0..i] 到 word2[0..j] 的距离，几个子问题就可以表示成这样： 当 word1[i] == word2[j] 时，m[i, j] = m[i-1, j-1]； 当 word1[i] != word2[j] 时，m[i, j] 可以是： m[i, j-1] + 1 m[i-1, j] + 1 m[i-1, j-1] +1 在它们中选距离最短的一个。 因此，我们得到递归公式2： \\[ m[i, j]=\\left\\{ \\begin{array}{lr} m[i-1, j-1] &amp; w1[i] = w2[j]\\\\ min(m[i, j-1] + 1,\\ m[i-1, j] + 1,\\ m[i-1, j-1] +1) &amp; w1[i] \\neq w2[j] \\end{array} \\right. \\] 因为是递归求解，需要考虑一下递归的终止条件：当 i 或 j 等于 -1 时，是空值和字符串之间的转换，显然从空到长度为 n 的字符串的距离就是 n。即： m[-1, j] = j + 1 m[i, -1] = i + 1 再完善一下公式： \\[ m[i, j]=\\left\\{ \\begin{array}{lr} j + 1 &amp; i=-1\\\\ i + 1 &amp; j=-1\\\\ m[i-1, j-1] &amp; w1[i] = w2[j]\\\\ min(m[i, j-1] + 1,\\ m[i-1, j] + 1,\\ m[i-1, j-1] +1) &amp; w1[i] \\neq w2[j] \\end{array} \\right. \\] 写出递归式之后，我们已经把一个应用问题转化成了数学问题。接下来就是编程时间，把它转化成代码了😉。 3. 计算最优解的值 带备忘的自顶向下 自顶向下法比较贴近我们的思考方式。它比递归更进一步，会保存每一步的计算结果。这样在需要一个子问题的解之前会先检查是不是已经计算过了，如果是的话就直接使用保存过的值。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { int[][] dist; public int minDistance(String word1, String word2) { int l1 = word1.length(); int l2 = word2.length(); dist = new int[l1][l2]; for (int i=0; i&lt;l1; i++) { for (int j=0; j&lt;l2; j++) { dist[i][j] = -1; //用 -1 来代表没有计算过的部分 } } return calcDistance(word1, word2, l1-1, l2-1); } private int calcDistance(String w1, String w2, int i, int j) { if (i==-1) return j+1; if (j==-1) return i+1; if (dist[i][j]!=-1) return dist[i][j]; int res; if (w1.charAt(i)==w2.charAt(j)) { res = calcDistance(w1, w2, i-1, j-1); } else { int add = calcDistance(w1, w2, i, j-1)+1; int rem = calcDistance(w1, w2, i-1, j)+1; int repl = calcDistance(w1, w2, i-1, j-1)+1; res = Math.min(Math.min(add, rem), repl); } dist[i][j] = res; return res; }} 这里用二维数组 dist[][] 来保存计算过的距离，用值 -1 表示未计算过的距离。 自底向上 自底向上的方法采用的是这么一种思路：先求解规模小的问题，再求解规模大的问题。在求解一个问题的时候，它所依赖的子问题都已经被计算过了。这样的好处在于可以不用使用递归函数调用，也不需要检查子问题是否计算过。 这张表是 horse -&gt; ros 每个长度编辑距离的表格，和上面自顶向下代码中的 dist 数组存储的数据差不多，多了一行一列的边界值，也就是终止条件的情况。应该能够很直观地看到，表格中的每一个值（m[i, j]），所依赖三个子问题都在它的左边、上面和左上角。只要按照一定顺序计算，就能生成整张表。 12345678910111213141516171819202122232425262728293031class Solution { public int minDistance(String word1, String word2) { int l1 = word1.length(); int l2 = word2.length(); int[][] dist = new int[l1+1][l2+1]; for (int i=0; i&lt;=l1; i++) dist[i][0] = i; for (int j=0; j&lt;=l2; j++) { dist[0][j] = j; } for (int i=1; i&lt;=l1; i++) { for (int j=1; j&lt;=l2; j++) { if (word1.charAt(i-1)==word2.charAt(j-1)) { dist[i][j] = dist[i-1][j-1]; } else { int add = dist[i][j-1]+1; int rem = dist[i-1][j]+1; int repl = dist[i-1][j-1]+1; dist[i][j] = Math.min(repl, Math.min(rem, add)); } } } return dist[l1][l2]; }} 4. 利用计算出的信息构造一个最优解 让我们更进一步！ 到上面为止，对于解答问题——得到单词间的最小距离，已经完成了。但是假如我们想要知道具体的每一步应该怎么编辑字符，该怎么做呢？我们可以对代码稍加修改，使每一个问题不仅保存最优解的值，还把相应的操作保存下来。 另外定义一个二维数组 act[][] 来储存操作，用值 0~3 来表示跳过、插入、删除和替换的操作，在找到最短距离的同时顺便记录下对应的操作，就能得到一张操作表。 假如 act[i][j] 当前的值是 2，代表删除，那么就删除 word1[i] 的字符，然后往上移，寻找 act[i-1][j]，以此类推。 代码： 1234567891011121314151617181920212223242526272829303132333435public void printOperations(int[][] act,int i,int j, String w1, String w2) { System.out.println(w1 + &quot; -&gt; &quot; + w2 + &quot;:&quot;); while (i!=0 &amp;&amp; j!=0) { String tmp; String s = &quot;&quot;; switch (act[i][j]) { case 0: //s = &quot;(跳过)\\n&quot;; i--; j--; break; case 1: tmp = w1.substring(0, i) + w2.charAt(j-1) + w1.substring(i+1); s = String.format(&quot;%s -&gt; %s (插入 '%c')\\n&quot;, w1, tmp, w2.charAt(j-1)); w1 = tmp; j--; break; case 2: tmp = w1.substring(0, i-1) + w1.substring(i); s = String.format(&quot;%s -&gt; %s (删除 '%c')\\n&quot;, w1, tmp, w1.charAt(i-1)); w1 = tmp; i--; break; case 3: tmp = w1.substring(0, i-1) + w2.charAt(j-1) + w1.substring(i); s = String.format(&quot;%s -&gt; %s (将 '%c' 替换为 '%c')\\n&quot;, w1, tmp, w1.charAt(i-1), w2.charAt(j-1)); w1 = tmp; i--; j--; break; } System.out.print(s); }} 输出的结果： 1234567891011121314151617horse -&gt; ros:horse -&gt; hors (删除 'e')hors -&gt; hos (删除 'r')hos -&gt; ros (将 'h' 替换为 'r')intention -&gt; execution:intention -&gt; intenuion (插入 'u')intenuion -&gt; intecuion (将 'n' 替换为 'c')intecuion -&gt; inecuion (删除 't')inecuion -&gt; ixecuion (将 'n' 替换为 'x')ixecuion -&gt; execuion (将 'i' 替换为 'e')consistent -&gt; constraint:consistent -&gt; consistint (将 'e' 替换为 'i')consistint -&gt; consisaint (将 't' 替换为 'a')consisaint -&gt; consiraint (将 's' 替换为 'r')consiraint -&gt; constraint (将 'i' 替换为 't') 完整代码：这里。 希望能对你有所帮助。 参见： 《算法导论》 详解一道经典面试题：编辑距离 - 知乎 自底向上 和自顶向下 - 编辑距离 - 力扣（LeetCode） 《算法导论（原书第3版）》，（美）科尔曼（Cormen, T. H.）等著；殷建平等译，机械工业出版社，2013.1，15.3章 动态规划原理，P216。↩︎ 递归公式，也叫状态转移方程。注意不是“递推”，递归是自顶向下的，而递推是自底向上的。↩︎","link":"/2020/01/08/leetcode-72-edit-distance/"},{"title":"Linux 下的软件安利","text":"把 Manjaro Gnome 当作生产环境，用了大概一个月的时间后… 就体验来看呢，如果日常用的软件在 Linux 上都有相同版本或者替代的话，感觉还是不错的。就是驱动和字体渲染比不上 Windows。 下面是一些好用的软件推荐。虽然很多链接标的是 Arch Linux 软件包的地址，但是对其他的发行版也基本都是支持的。很多软件都提供了 Snap 或者 FlatPak 或者 AppImage 这些通用的打包方式，在不同的发行版都是可以运行的。 效率工具 文本：Typora 最好用的 Markdown 编辑器。 SSH 客户端：Termius 终端连接工具，颜值很高。支持所有平台，包括 Windows 和 Android。免费的版本提供 SSH 客户端和端口映射工具，付费的还提供帐号间连接的同步等等功能。 记事本：Simplenote （AUR） Simplenote 是一个功能简单的记事本软件，只能记录纯文本内容。它的优点在于全平台支持，并且实时同步。一个设备上输入的文字马上可以在另一个设备看到（甚至可以当作跨设备的剪切板用）。我把它当作备忘录来用。这个软件和 Wordpress 是一个公司，所以稳定性也是有所保证的。 截图工具 推荐两个截图工具，分别是深度截图（deepin-screenshot）和火焰截图（flameshot）。它们都能做到像 QQ 截图那样方便地截图。 文档处理 这个肯定是 WPS Office 了，国产良心。除此之外 Only Office 和 Libre Office 也值得一试。 即时通讯 微信：用 deepin-wine-wechat，或者用 wine-for-wechat 和 com.qq.weixin.spark。 QQ：官方 Electron 版本上线了，用 linuxqq！或者用 icalingua++，第三方的 QQ 客户端，或者 deepin-wine-qq，或者 deepin-wine-tim。 剪切板管理：CopyQ 不错的剪切板管理工具，记录剪切板的历史，文本和图片都支持，可以自定义快捷键激活。 远程桌面：Remmina 支持 RDP、VNC、SFTP 等协议，功能强大。 文件查找：catfish 全局的文件搜索。类似 Windows 下的软件 Everything。配合 mlocate 缓存食用，可以加快查找速度。 系统工具 分区管理：GParted 和 Windows 下的 DiskGenius 类似的分区编辑工具。 输入法：RIME 全平台的开源的可定制化程度很高的输入法引擎。IBus 和 Fcitx 都支持。 网络代理：V2rayA 为 Linux 设计的 V2ray 客户端，用网页的形式来管理连接。用 Docker 部署很方便。最大的特点就是提供了一键开启透明代理，不需要手动去配置 iptables 了。 容器：Docker 各种服务类的工具，比如数据库，中间件，Web服务端等等，都可以用 Docker 来部署，省时省力。以前安装 MySQL，Oracle 数据库需要配置很多东西，现在一行命令就可以启动起来了。甚至图形化应用也可以用 Docker 来跑，比如 docker-wine-linux。 Gnome Tweaks：可以改 Gnome 桌面系统设置里没有的项目，比如字体和主题。 Timeshift：可以创建文件系统增量快照，和 Windows 还原点类似，再也不怕更新滚挂了。 多设备协同 KDE Connect：功能强大的协同软件。Gnome 桌面可以用 GSConnect。它可以做到电脑和手机文件共享、剪切板共享、把手机屏幕当作触摸板和键盘、同步显示手机的通知、多媒体控制、查找手机等等非常实用的功能。只需要电脑和手机都安装了软件，并且处在同一个局域网中就可以。 scrcpy：一款安卓手机投屏到电脑的软件。使用 adb 协议，可以用鼠标和键盘操作手机，向手机发送文件等。需要用数据线连接手机和电脑。adb 协议也支持远程连接，所以稍微配置一下也可以无线使用。 Remote Touchpad：手机控制电脑的软件。通过网页的形式提供触摸屏和键盘数据的功能。手机浏览器扫描电脑上的二维码就可以操作。比 KDE Connect 简单，好处是不用安装额外软件。 Termux：这是一个安卓软件，命令行工具。提供完整的 Linux 环境。有了它，手机直接变成一台 Linux 服务器 / 终端。电脑可以通过 ssh 连接手机，然后就能为所欲为了。 多媒体 网易云音乐：官方支持 Linux。提供deb格式的安装包。Arch 用户可以从 AUR 软件源安装（netease-cloud-music）。 有道词典：Deepin 和 有道一起推出的 Linux 版本。AUR：youdao-dict。可惜没有账户功能，不能同步生词本。 YesPlayMusic：第三方的网易云客户端，颜值很高。去掉了网易云的社交功能。并且集成了另一个工具：UnblockNeteaseMusic，能自动从别的音乐平台获取变灰的歌曲。 VLC：全能的视频播放器。 GIMP：开源的画图工具，位图图像编辑。如果是编辑矢量图用Inkscape。 Gnome 桌面插件 No Title Bar - Forked：一个可以把窗口的标题栏和状态栏合并的插件。窗口最大化的时候不显示标题栏，扩大了屏幕的显示区域。 BackSlide：随时间变化的壁纸，可以选择一个文件夹的壁纸作为幻灯片展示。和 Windows 的变化壁纸功能一样。 Lunar Calendar：在日历栏显示农历和节假日。 Dash to Dock：应用栏可以移动到屏幕的其他位置。 AppIndicator and KStatusNotifierItem Support：会把旧版的状态图标放置到顶部的状态栏。比如 Wine 程序的状态图标，没开启这个插件图标就会显示在状态栏对面。 System Action - Hibernate：开启了挂起功能之后，用这个插件会在关机的菜单多一项“休眠”按钮。 联想专用 battmngr：这个命令行工具能改变联想电脑的电源管理设置，也就是在 Windows 上的快捷键 Fn + Q 一键性能切换功能。","link":"/2021/10/25/awesome-linux-software/"},{"title":"Minecraft的文件结构","text":"打开玩了半年的MC的.minecraft文件夹，你可能会看到这样的场景： MC文件夹内的一大堆文件 这些文件和文件夹到底是从启动器来的，从模组来的，还是游戏本身自己就有的呢？有些文件可以从命名上就判断来源，比如“litemod”，有些却不能。于是我从纯净版的Minecraft 1.12.2文件开始，重新再安装一次Optifine、Forge、LiteLoader以及各种MOD，看看这些文件是从哪里产生的。 游戏基础文件 123452018/09/23 14:06 &lt;DIR&gt; .2018/09/23 14:06 &lt;DIR&gt; ..2018/09/23 13:51 &lt;DIR&gt; assets2018/09/23 14:06 &lt;DIR&gt; libraries2018/09/23 14:05 &lt;DIR&gt; versions 这是一个原版完整的Minecraft游戏的所有文件。只要有assets、libraries、versions三个文件夹内的文件，游戏就可以运行。 assets 存放MC的图标、皮肤、音效、音乐以及语言文件等。没有这个文件夹游戏也可以启动，但是没有声音，只有英语。除去assets外其他文件只有大约50mb。这也是MC核心文件的大小。 libraries 包含游戏启动所需要的库文件。缺少部分文件文件会无法启动，不过一般启动器会从官网下载回来补齐并启动游戏。 versions 版本文件。当安装了新版本游戏，或者安装了Optifine，Forge等其他补丁后，会在这里生成新的版本文件，并可以被启动器检测到以供玩家选择版本。 游戏数据文件 12345678910111213142018/09/23 15:47 &lt;DIR&gt; .2018/09/23 15:47 &lt;DIR&gt; ..2018/09/23 13:51 &lt;DIR&gt; assets2018/09/23 15:41 &lt;DIR&gt; saves2018/09/23 14:06 &lt;DIR&gt; libraries2018/09/23 15:40 &lt;DIR&gt; logs2018/09/23 14:05 &lt;DIR&gt; versions2018/09/23 15:40 &lt;DIR&gt; resourcepacks2018/09/23 16:04 &lt;DIR&gt; screenshots2018/09/23 15:47 10,241 servers.dat2018/09/23 16:00 3,470 hotbar.nbt2018/09/23 15:45 106 usercache.json2018/09/23 15:46 2,141 options.txt2018/09/23 15:39 135 launcher_profiles.json saves 保存游戏世界的存档。删掉会后悔一辈子。记得常备份哦。 logs 日志文件，保存启动器和游戏的日志输出，玩家聊天记录也在里面。 resourcepacks 资源包文件夹。材质包放里面。 screenshots 截图文件夹。游戏内按下F2会保存游戏截图保存到这里来。 servers.dat 服务器数据。保存加入的服务器的名字、地址等信息。 hotbar.nbt 创造模式的快捷工具栏保存的数据。1.12版本新有的功能。按C+1保存底下那条工具栏到第一条去（注意是C不要按成Ctrl），X+1切换。 MC创造模式工具栏 usercache.json 储存玩家的ID和UUID。 options.txt 游戏里的选项里的改动保存在这里。 launcher_profiles.json 游戏启动配置文件。可以新建游戏配置，从而选择不同的游戏存档，版本。比如启动一个整合包里的游戏文件。 backups 旧版存档游戏备份文件。打开旧版本存档时，会压缩一份存档到这里备份（然而旧游戏打开新存档却不会备份）。 crash-reports 崩溃日志报告。如果你的游戏崩了，这里就会多出来一个文件。 server-resource-packs 服务器资源包文件夹。从服务器加载的材质包缓存在这里。 Optifine文件 12345678910111213141516172018/09/23 16:06 &lt;DIR&gt; .2018/09/23 16:06 &lt;DIR&gt; ..2018/09/23 13:51 &lt;DIR&gt; assets2018/09/23 15:59 &lt;DIR&gt; libraries2018/09/23 16:00 &lt;DIR&gt; logs2018/09/23 15:40 &lt;DIR&gt; resourcepacks2018/09/23 15:41 &lt;DIR&gt; saves2018/09/23 16:04 &lt;DIR&gt; screenshots2018/09/23 15:59 &lt;DIR&gt; shaderpacks2018/09/23 15:57 &lt;DIR&gt; versions2018/09/23 16:04 3,470 hotbar.nbt2018/09/23 15:59 264 launcher_profiles.json2018/09/23 16:10 2,161 options.txt2018/09/23 16:10 1,434 optionsof.txt2018/09/23 16:06 364 optionsshaders.txt2018/09/23 15:47 10,241 servers.dat2018/09/23 16:00 106 usercache.json shaderpacks 光影包文件夹。光影包放这里。 optionsof.txt Optifine的设置保存在这里。 optionsshaders.txt Optifine的光影设置保存在这里。 LiteLoader文件 12345678910111213141516171819202018/09/23 16:21 &lt;DIR&gt; .2018/09/23 16:21 &lt;DIR&gt; ..2018/09/23 16:21 &lt;DIR&gt; .mixin.out2018/09/23 13:51 &lt;DIR&gt; assets2018/09/23 15:59 &lt;DIR&gt; libraries2018/09/23 16:21 &lt;DIR&gt; liteconfig2018/09/23 16:21 &lt;DIR&gt; logs2018/09/23 16:21 &lt;DIR&gt; mods2018/09/23 15:40 &lt;DIR&gt; resourcepacks2018/09/23 15:41 &lt;DIR&gt; saves2018/09/23 16:04 &lt;DIR&gt; screenshots2018/09/23 15:59 &lt;DIR&gt; shaderpacks2018/09/23 16:20 &lt;DIR&gt; versions2018/09/23 16:04 3,470 hotbar.nbt2018/09/23 16:20 405 launcher_profiles.json2018/09/23 16:10 2,161 options.txt2018/09/23 16:10 1,434 optionsof.txt2018/09/23 16:06 364 optionsshaders.txt2018/09/23 15:47 10,241 servers.dat2018/09/23 16:22 106 usercache.json .mixin.out 不知道。可能日志文件吧。装完LiteLoader就有。 liteconfig LiteLoader的配置文件。 Forge文件 123456789101112131415161718192021222018/09/23 16:35 &lt;DIR&gt; .2018/09/23 16:35 &lt;DIR&gt; ..2018/09/23 16:21 &lt;DIR&gt; .mixin.out2018/09/23 13:51 &lt;DIR&gt; assets2018/09/23 16:34 &lt;DIR&gt; config2018/09/23 16:34 &lt;DIR&gt; libraries2018/09/23 16:21 &lt;DIR&gt; liteconfig2018/09/23 16:34 &lt;DIR&gt; logs2018/09/23 16:21 &lt;DIR&gt; mods2018/09/23 15:40 &lt;DIR&gt; resourcepacks2018/09/23 15:41 &lt;DIR&gt; saves2018/09/23 16:04 &lt;DIR&gt; screenshots2018/09/23 15:59 &lt;DIR&gt; shaderpacks2018/09/23 16:20 &lt;DIR&gt; versions2018/09/23 16:04 3,470 hotbar.nbt2018/09/23 16:20 405 launcher_profiles.json2018/09/23 16:10 2,161 options.txt2018/09/23 16:10 1,434 optionsof.txt2018/09/23 16:06 364 optionsshaders.txt2018/09/23 15:47 10,241 servers.dat2018/09/23 16:35 106 usercache.json2018/09/23 16:35 55 usernamecache.json config Forge 和 Forge 的大部分mod的配置文件都这个文件夹。 mods Forge API 的 mod 放在这里。mod 党应该最熟悉不过了。 usernamecache.json Forge 也存了一份玩家的 ID 和 UUID。 其他 把这些主要的排除了，剩下的基本上就是mod产生的文件了。基本上能够从名字上判断出来。比如CustomSkinLoader就是CustomSkinLoader的，那些waypoints之类的图片是VoxelMap的。 写完之后百度了一下，这个也不错： [教程]Minecraft 文件夹目录索引及各部分作用【minecraft吧】_百度贴吧","link":"/2018/09/23/file-structure-of-minecraft/"},{"title":"Let’s Encrypt 安装通配符证书","text":"不用为二级域名申请证书了，但是有效期只有 3 个月。 安装 certbot 官网：https://certbot.eff.org certbot 官网有安装向导。打开向导页面，选择你对应的操作系统和网页服务器，它会告诉你怎么做。 1234567891011# Apache on Ubuntu 18.04 LTS (bionic)# Add Certbot PPAsudo apt-get updatesudo apt-get install software-properties-commonsudo add-apt-repository universesudo add-apt-repository ppa:certbot/certbotsudo apt-get update# Install Certbotsudo apt-get install certbot python3-certbot-apache 申请证书 这一步需要更改 DNS 的解析记录，有个坑要注意一下：更改 DNS 记录要等大约 10 分钟才生效，最好用 screen 或者其他命令保证终端不会超时退出。 1certbot certonly -d &quot;*.beanbang.cn&quot; -d &quot;beanbang.cn&quot; --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory certonly 表示插件，Certbot 有很多插件。不同的插件都可以申请证书，用户可以根据需要自行选择。 -d 为哪些主机申请证书。如果是通配符，输入 *.xxx.com (根据实际情况替换为你自己的域名)。 --preferred-challenges dns-01 使用 DNS 方式校验域名所有权。 --server Let's Encrypt ACME v2 版本使用的服务器不同于 v1 版本，需要显示指定。 执行之后会有提示你记录 IP 地址之类的，确定就是了。之后会提示需要你验证你的域名： 12345678910Please deploy a DNS TXT record under the name_acme-challenge.beanbang.cn with the following value:ErR2BtnzPzdz8zFMW-IK663dM-sWjvXZtjFRwKkkAMUBefore continuing, verify the record is deployed.(This must be set up in addition to the previous challenges; do not remove,replace, or undo the previous challenge tasks yet. Note that you might beasked to create multiple distinct TXT records with the same name. This ispermitted by DNS standards.) 括号里的内容说，不要删除和改动先前的记录，你可能被要求向同一个名字（二级域名）添加多条 TXT 记录，这个是 DNS 标准所允许的。 去域名服务商的控制台添加解析记录。改完之后，新建一个连接，用 dig 命令来测试。 123456789101112131415161718192021$ dig -t txt _acme-challenge.beanbang.cn; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; -t txt _acme-challenge.beanbang.cn;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 38548;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;_acme-challenge.beanbang.cn. IN TXT;; ANSWER SECTION:_acme-challenge.beanbang.cn. 592 IN TXT &quot;pxQrBuCbDVTP9FIGR55BGZGjVqPXbSN2nNwN3jTUUyI&quot;_acme-challenge.beanbang.cn. 592 IN TXT &quot;shrER0qocOoMedzQGum94cb_wHihcbzIGvJWB2t7vOY&quot;;; Query time: 0 msec;; SERVER: 10.236.158.106#53(10.236.158.106);; WHEN: Mon Apr 06 23:11:01 CST 2020;; MSG SIZE rcvd: 168 改完解析记录没有立刻生效的话，可以手动刷新一下主机的 DNS 缓存再查。不同的 DNS 缓存服务刷新的命令不同： 123456# Systemd Resolvedsudo systemd-resolve --flush-caches# Dnsmasqsudo systemctl restart dnsmasq.service# Nscdsudo systemctl restart nscd.service 如果你发现解析记录已经成功改变了，就可以按下回车。 成功之后会有下面的提示： 1234567891011121314151617Waiting for verification...Resetting dropped connection: acme-v02.api.letsencrypt.orgCleaning up challengesIMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/beanbang.cn/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/beanbang.cn/privkey.pem Your cert will expire on 2020-04-06. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 这时候应该能看到 /etc/letsencrypt/live/[域名] 下的证书文件： 12$ ls /etc/letsencrypt/live/beanbang.cn/cert.pem chain.pem fullchain.pem privkey.pem README 四个证书文件 查了一下文档1，这四个证书文件分别的不同用途，大概是这样： privkey.pem 证书的私钥，必须时刻保护好。不能公开给任何人。 配置项：Apache 的 SSLCertificateKeyFile，Nginx 的 ssl_certificate_key。 fullchain.pem 完整的证书密钥链（certificate chain），包括服务端证书（server/leaf certificate）和中间证书（intermediate certificate）。在文件最开头第一个是服务端证书，接下来的是中间证书。 配置项： Apache &gt;= 2.4.8 的 SSLCertificateFile ，Nginx 的 ssl_certificate。 cert.pem 和 chain.pem （较少用） cert.pem 包含了服务器端证书，chain.pem 包含了中间证书。假如你要使用它们，必须两个文件一起使用，不然浏览器会提示“链接不受信任”。 配置项：Apache &lt; 2.4.8 的 SSLCertificateFile 和 SSLCertificateChainFile。启用了 OSCP 的 Nginx &gt;= 1.3.7，需要将 ssl_trusted_certificate 设置为 chain.pem。 配置网页服务器 Apache 找到 Apache 的配置文件 httpd-ssl.conf，并且修改相应的内容，把证书添加上去。 12cd /opt/lamppvim etc/extra/httpd-ssl.conf 1234567&lt;VirtualHost 0.0.0.0:443&gt; DocumentRoot &quot;/opt/lampp/htdocs/hexo/&quot; ServerName blog.beanbang.cn SSLEngine on SSLCertificateFile /etc/letsencrypt/live/beanbang.cn/fullchain.pem SSLCertificateKeyFile /etc/letsencrypt/live/beanbang.cn/privkey.pem&lt;/VirtualHost&gt; Nginx 1vim /etc/nginx/conf.d/blog.beanbang.cn.conf 1234567891011server { listen 443 ssl; server_name blog.beanbang.cn; ssl_certificate /etc/letsencrypt/live/beanbang.cn/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/beanbang.cn/privkey.pem; location / { root /home/ubuntu/www/hexo; try_files $uri $uri/ /index.html; }} 更新证书 通配符证书似乎不支持用 certbot renew 来更新，重新执行一下上面申请证书的命令来更新证书。证书时长是三个月，在到期的前 10 天 Let's Encrypt 会发邮件提醒你的。 参见： Let's Encrypt 终于支持通配符证书了 - 简书 Let's Encrypt 免费通配符 SSL 证书申请教程 - 运维之美 申请 Let's Encrypt 通配符 HTTPS 证书，并配置 Apache27f - 柒风博客 | 7f - 柒风博客 根证书和中间证书的区别 - FreeBuf专栏·ssl China User Guide — Certbot 1.0.0.dev0 documentation↩︎","link":"/2020/04/06/install-wildcard-certificate-using-lets-encrypt/"},{"title":"Maven 笔记","text":"平平无奇的 Java 的包管理工具。 这是《Maven实战》的读书笔记。 电子书：https://4lib.org/s/B009WMAZX4 书本实例代码：https://github.com/juven/mvn_in_action_code 概念 构件：在 Maven 世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。 坐标：每一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径。 依赖：一个 Maven 项目使用另一个 Maven 项目的构件，作为依赖。使用坐标来定位。 仓库：在某个位置储存所有 Maven 项目共享的组件。当需要的时候，Maven 会根据坐标找到仓库中的构件，使用它们。 命令 123mvn archetype:generatemvn dependency:listmvn dependency:tree 坐标和依赖 依赖范围 1234567&lt;dependency&gt; &lt;groupId&gt;javax.sql&lt;/groupId&gt; &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; Maven 在编译，测试，和运行的时候各使用一种 classpath。依赖范围就是在某个阶段是否需要这个包。 compile：编译依赖范围。默认依赖范围。对编译，测试，运行都会使用到。例如 spring-core。 test：测试依赖范围。只对于测试 classpath 有效。例如 JUnit。 provided：已提供依赖范围。对于编译和测试有效，在运行时无效。例如 servlet-api，编译和测试时需要用到该依赖，但是运行的时候容器已经提供，就不需要重复引入，再把依赖打进 jar 包。 runtime：运行时依赖范围。对测试和运行有效，但在编译时不需要。例如 JDBC 的驱动实现，在代码里面我们没有直接引用 MySQL 或者 Oracle 的 JDBC驱动，而是用 JDBC 接口去调用。所以编译的时候不需要，实际运行的时候才要。 system：系统依赖范围。范围和 provided 范围一致，但是需要使用 systemPath 指定依赖文件的路径，用来导入本级系统中的包，没有可移植性。 import：用于依赖管理，只在 dependencyManagement 标签中使用。作用是把另一个 POM 的 dependencyManagement 配置导入到当前 POM 的 dependencyManagement 里面。 依赖范围 Scope 编译 测试 运行 compile ✔ ✔ ✔ test ✔ provided ✔ ✔ runtime ✔ ✔ system ✔ ✔ 依赖传递 左边一列是第一直接依赖(A)，上面一行表示第二直接依赖(B)，单元格表示传递性依赖范围(C)。 A 依赖 B，B 依赖 C，那么 A 对 C 是什么依赖范围。 可选依赖不会被传递。即添加了标签为 &lt;optional&gt;true&lt;/optional&gt; 的。 依赖范围影响传递性依赖 compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime 依赖调解 依赖调解的原则： 路径最近者优先。依赖的路径比较短的包会被解析使用。 第一声明者优先。如果路径长度一样，在POM文件中，顺序靠前的那个依赖优胜。 仓库 123456graph TD Maven仓库 --- 本地仓库 Maven仓库 --- 远程仓库 远程仓库 --- 中央仓库 远程仓库 --- 私服 远程仓库 --- 其他公共库 仓库解析的机制 依赖范围是 system 时，直接从本地解析 计算仓库路径后，如果本地仓库存在则解析 本地不存在，依赖版本是发布版本构件，遍历远程仓库，下载到本地并解析 如果依赖版本是 RELEASE 或 LATEST，获取远程仓库元数据，计算出真实版本值，重复 2 和 3。 如果依赖版本是 SNAPSHOT，获取远程仓库元数据，得到最新版本，检查，根据需要下载。 如果版本是时间戳格式的快照，会恢复成非时间戳格式，再去找。 版本不明晰的时候，如 RELEASE、LATEST 和 SNAPSHOT，会根据远程仓库的更新策略来检查更新，和仓库看配置有关。相关的配置标签：releases、snapshots 的 enabled，和 updatePolicy 等。 镜像 &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;：匹配所有远程仓库。 &lt;mirrorOf&gt;external：*&lt;/mirrorOf&gt;：匹配所有远程仓库，使用 localhost 的除外，使用 file:// 协议的除外。也就是说，匹配所有不在本机上的远程仓库。 &lt;mirrorOf&gt;repo1，repo2&lt;/mirrorOf&gt;：匹配仓库 repo1 和 repo2，使用逗号分隔多个远程仓库。 &lt;mirrorOf&gt;*，！repo1&lt;/mirrorOf&gt;：匹配所有远程仓库，repo1 除外，使用感叹号将仓库从匹配中排除。 需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven 仍将无法访问被镜像仓库，因而将无法下载构件。 生命周期 Maven的生命周期就是为了对所有的构建过程进行抽象和统一。Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几乎所有项目的构建，都能映射到这样一个生命周期上。 Maven 的生命周期是抽象的，实现由插件来完成。有默认插件，也可以绑定其它插件。 Maven 拥有三套独立的生命周期：clean，default，site。 clean pre-clean clean post-clean default 太多了，完整的在 Lifecycle Reference。 部分重要的 validate - validate the project is correct and all necessary information is available compile - compile the source code of the project test - test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed package - take the compiled code and package it in its distributable format, such as a JAR. verify - run any checks on results of integration tests to ensure quality criteria are met install - install the package into the local repository, for use as a dependency in other projects locally deploy - done in the build environment, copies the final package to the remote repository for sharing with other developers and projects. site pre-site site post-site site-deploy 插件 Maven 生命周期和插件相互绑定。 可以自定义将某个插件目标绑定到生命周期的某个阶段上。 可以通过命令行参数 -D 对插件进行配置。例如跳过测试： 1mvn install -Dmaven.test.skip=true 聚合和继承 聚合 如果想要一次构建两个项目，而不是到两个模块的目录下面分别执行 mvn 命令，我们可以再新建一个 pom 文件。 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Account Aggregator&lt;/name&gt; &lt;modules&gt; &lt;module&gt;account-email&lt;/module&gt; &lt;module&gt;account-persist&lt;/module&gt; &lt;module&gt;account-parent&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 模块不一定要是树形嵌套的结构的，也可以平行放置，这样 module 标签要改成相对路径。 这样运行 mvn clean install 命令就会同时构建两个工程。 继承 如果多个模块都依赖了一堆相同的东西，那么可以建立一种父子结构，让子模块继承父模块。 作为父模块，打包类型需要为 pom。 123456789&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Account Parent&lt;/name&gt;&lt;/project&gt; 子模块需要继承它。 123456789101112131415161718192021&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../account-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;account-email&lt;/artifactId&gt; &lt;name&gt;Account Email&lt;/name&gt; &lt;dependencies&gt; …… &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; …… &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; relativePath 似乎可以不需要。 子模块没有配置 groupId 和 version 的话，会继承父类的配置。也可以显式声明。 最后要把父模块也添加到聚合模块里面。 所有可以被继承的POM元素 12345678910111213141516171819groupId：项目组ID，项目坐标的核心元素。version：项目版本，项目坐标的核心元素。description：项目的描述信息。organization：项目的组织信息。inceptionYear：项目的创始年份。url：项目的URL地址。developers：项目的开发者信息。contributors：项目的贡献者信息。distributionManagement：项目的部署配置。issueManagement：项目的缺陷跟踪系统信息。ciManagement：项目的持续集成系统信息。scm：项目的版本控制系统信息。mailingLists：项目的邮件列表信息。properties：自定义的Maven属性。dependencies：项目的依赖配置。dependencyManagement：项目的依赖管理配置。repositories：项目的仓库配置。build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等。reporting：包括项目的报告输出目录配置、报告插件配置等。 依赖管理 使用 dependencyManagement 元素的依赖，不会给子模块引入依赖。子模块需要引入依赖的时候，需要提供 groupId 和 artifactId，该依赖的还是要写，不过不需要提供版本号。 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; scope import maven中import scope依赖方式解决单继承问题的理解 - 花花牛 - 博客园 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 使用 import 依赖，可以把另一个 POM 中的 dependencyManagement 配置合并到 当前 POM 的 dependencyManagement 元素中。想要重复使用一批 dependencyManagement 配置，除了可以复制配置或者继承之外，还可以通过这种 import 范围依赖将这一配置导入进来。 如果有多个项目，它们使用的依赖版本都是一致的，则就可以定义一个使用 dependencyManagement 专门管理依赖的POM，然后在各个项目中导入这些依赖管理配置。 这样，用聚合代替继承，就可以解决 POM 文件只能单继承的问题，也可以更好地按功能划分 POM 文件。 插件管理 pluginManagement 也是类似的原理。 聚合和继承的关系 对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。 对于继承关系的父 POM 来说，它不知道有哪些子模块继承于它，但那些子模块都必须知道自己的父 POM 是什么。 一个 POM 可以既是聚合 POM，又是父 POM，没有什么问题。 超级POM 任何一个 Maven 项目都隐式地继承自该 POM。这个超级 POM 约定了中央仓库、项目结构、插件版本等等配置。这些配置成了 Maven 所提倡的约定，可以在 Maven 的依赖包里面找到。 反应堆 在一个多模块的Maven项目中，反应堆（Reactor）是指所有模块组成的一个构建结构。对于单模块的项目，反应堆就是该模块本身，但对于多模块项目来说，反应堆就包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序。 Maven 会根据模块之间的依赖关系，决定构建模块的顺序。如果一个模块依赖于另一个模块，就先构建那个模块。这么递归下去，直到找到没有依赖的模块。 模块之间的依赖关系会构成一个有向无环图（DAG），所以说不能出现环，要是出现了循环依赖，Maven 就会报错。 用户可以裁剪反应堆，也就是可以选择只构建反应堆中的一些个模块，加速构建。","link":"/2021/07/16/maven-note/"},{"title":"MultiMC的离线模式启动","text":"新发现了一个功能强大的启动器：MultiMC。这是一个第三方开源的 Minecraft 启动器，由于是用 Qt 编写的，启动器可以在多个平台上运行。 MultiMC主界面 MultiMC 有丰富的启动选项，能够方便地安装 Forge mod，Optifine 等插件。它的 UI 和官方启动器，HMCl 都有点不同。文件结构也和原版游戏不一样（不过大体的结构还是相似的），这样更容易在启动器中管理 mod，截图等资源。第一次运行时 MultiMC 会下载对应版本的游戏，不想等的话可以去已有的游戏的.minecraft文件夹下把assets和libraries文件夹拷贝到 MultiMC 的目录下来。 MultiMC无账号提示 不过呢，不像其他的第三方启动器，MultiMC必须要登录游戏账号后才能启用离线模式，这么做的目的应该是为了支持正版。其实无正版账号体验这个启动器也是可以的:P。 MultiMC的账号配置文件内容 登录一次后，我的accounts.json文件多了一些参数。只要稍加改动，确保包含这些参数项就可以了，比如这样： 123456789101112131415161718192021{ &quot;accounts&quot;: [ { &quot;accessToken&quot;: &quot;0&quot;, &quot;activeProfile&quot;: &quot;0&quot;, &quot;clientToken&quot;: &quot;0&quot;, &quot;profiles&quot;: [ { &quot;id&quot;: &quot;0&quot;, &quot;legacy&quot;: false, &quot;name&quot;: &quot;你的名字&quot; } ], &quot;user&quot;: { &quot;id&quot;: &quot;0&quot; }, &quot;username&quot;: &quot;一个离线账号&quot; } ], &quot;formatVersion&quot;: 2} 打开启动器就能用这个空的账号启动离线模式游戏了。 另见： 强大的 Minecraft 启动器：MultiMC - 少数派 Github: MultiMC/MultiMC5 MultiMC（官网）","link":"/2018/12/11/launch-mc-offline-with-multimc/"},{"title":"内网穿透和反向代理软件","text":"内网穿透，又叫NAT穿透、端口映射、端口转发、反向代理、内网转外网/公网…… 原理 由于IPv4地址的缺乏，运营商们越来越少给我们提供公网IP，即使能够分配到公网IP，也是动态ip，在网络断开重新链接后IP地址就会改变。而我们使用交换机、路由器，使得我们处于“专用网”中，用ipconfig(Linux用ifconfig)查询本机IP会得到下面的几类局域网地址： 123A类：10.0.0.0 到 10.255.255.255 (10.0.0.0/8)B类：172.16.0.0 到 172.31.255.255 (172.16.0.0/12)C类：192.168.0.0 到 192.168.255.255 (192.168.0.0/16) 校园网经常分配到上面的A类地址，运营商的宽带可能分配到172开头的地址；而家用路由器分配的是192.168开头的地址。然后我们通过网络地址转换协议 NAT 转换IP地址进行上网。 反向代理图解|Imperva 所以，拥有一个公网IP就相当于处在各种网络的最外层，可以直接和其他主机进行通信。而处在NAT路由器内的主机的通信必须由专用网内的主机发起。因为如果是外部主机发起的通信的话，路由器不知道要将数据包转发给专用网中的哪一个主机。于是就有了反向代理的工作方式，把一台处于内网中的主机和一台拥有公网IP的主机的端口绑定，然后由公网主机将来自外部的请求转交给内网主机。这样，就实现了内网主机作为服务器的功能。 软件 接下来推荐几个好用的内网穿透/反向代理软件： DDNS (动态域名解析+端口映射) 这个其实不算是软件吧，算是路由器应用… 路由器/猫 有动态公网IP 管理员权限 大多数的家庭宽带还是会分配公网IP地址的（除了一些二级运营商比如移动），只不过是临时的动态IP，断开重新拨号后IP地址就会改变。大部分路由器会提供动态域名解析的功能，虽然IP会经常变化，只要有一个域名指向这个IP地址就可以了。 打开路由器的设置界面，通常有一个叫DDNS或类似域名动态解析的选项。在动态域名服务的提供商那里注册账号，选一个二级域名，然后在路由器里面填上用户名和密码。设置完ping一下你的二级域名比如xxx.wicp.net，如果返回的是你的路由器的IP地址，就说明设置成功了。 路由器的端口映射设置 现在外部请求已经能够到达路由器了，接下来在路由器里设置端口映射(有的叫虚拟服务器)，将路由器的特定端口和局域网内的主机绑定，这样特定的服务就能够和局域网内特定的主机通信了。 通过动态域名和端口映射的方法局限性很大。在家里，我们知道路由器的密码，有更改路由器设置的权限；在学校的校园网，宿舍的个人网呢？如果被分配在多层子网中，你需要一层一层地联络网络管理员给你开放端口，还不能保证他们一定会给你开……遇到这种情况我们还是另辟蹊径吧。 ssh -R 最最方便的方法 无需额外软件 跨平台 需要VPS 新版的Win10已经自带OpenSSH了，在设置 -&gt; 应用 -&gt; 应用和功能 -&gt; 管理可选功能中可以启用。 win10开启OpenSSH OpenSSH 提供了三种端口转发功能：正向代理（local），反向代理（remote），以及动态代理（dynamic）。在这里，我们用到的是它的反向代理功能。 只需要一句命令即可开启端口转发： 1ssh -o ServerAliveInterval=60 -R 8888:127.0.0.1:3389 beanbang@121.29.54.117 执行命令，输入密码，进入终端就已经建立了从本机的3389端口到服务器的8888端口的链接。现在，你就可以在远程桌面中通过地址121.29.54.117:8888来连接你的主机了。其中-o ServerAliveInterval=60项是为了防止长时间无操作被关闭连接，每隔60秒向服务器发送信号。 如果开启失败可能是服务器端没有启用： 12sudo vim /etc/ssh/sshd_config #添加一行 GatewayPorts yessudo service sshd restart 以及记得在防火墙中允许特定端口的通信。 frp 安装方便 跨平台 功能强大 需要VPS frp（fast reverse proxy） 是一个功能强大的开源反向代理软件。在GitHub上面有详细的中文说明。 可以很轻松地配置简单的端口转发。只要下载对应架构的程序放到相应的操作系统上。公网IP的主机使用 frps 和 frps.ini，内网主机则使用 frpc 和 frpc.ini。 解压： 1tar -zxvf frp_0.21.0_linux_amd64.tar.gz 编辑frps.ini： 123456789# frps.ini[common]bind_port = 7000dashboard_port = 7500dashboard_user = usernamedashboard_pwd = passwordlog_file = ./frps.loglog_level = infolog_max_days = 3 启动 frps： 1./frps -c ./frps.ini 编辑frpc.ini： 12345678910# frpc.ini[common]server_addr = 121.29.54.117server_port = 7000[rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389remote_port = 8888 启动 frpc： 1./frpc -c ./frpc.ini 服务端和客户端都启动后，就可以通过121.29.54.117:8888来连接远程主机了，还可以访问 http://121.29.54.117:7500 来打开frp的 Dashboard 界面，用网页的形式查看各种相关信息。 frps的dashboard界面 开发者细心地编译了多种操作系统架构的程序使得我们可以方便地下载和使用，比如树莓派就可以使用其 arm-64 版本来架设小型服务器。 路由侠等内网映射服务 Windows系统 图形界面，操作简单 服务型，额外付费 路由侠适合那些没有自己的公网服务器，只需要临时连接，或者不想要自己折腾的人。类似的这种软件还有 花生壳、net123、蛤蟆吃（hamachi）等等。这些算是提供服务类型的软件了。只要安装上客户端，进行简单的配置就可以使用它们的服务了。 不过没有免费的午餐，这些软件往往提供有限制的免费套餐，然后提供附加的服务进行收费。比如路由侠就限制1个月1G的流量，1Mb的带宽。提供给你一个二级域名和端口号，用这个域名和端口来访问服务。 想当年和小伙伴玩Minecraft开服用的就是路由侠。在电脑上架上CraftBukkit服务器，然后开放地址开一起来开荒。后来买了vps，服务器就搬到vps上面去了。 mstsc开启映射网络驱动器 其实，端口映射我用的最多的还是远程桌面。去机房上机的时候，打开 mstsc ，远程桌面连上自己的电脑。这样避免了机房电脑渣机运行缓慢，而且实验结束不用拿U盘拷走实验结果，文件也可以直接传回电脑去。特别的方便有木有？ 参考资料： What is a Reverse Proxy Server | Reverse vs. Forward Proxy | CDN Guide | Incapsula [云路由器] 如何映射服务器到外网 - TP-LINK 服务支持 使用 ssh -R 穿透局域网访问内部服务器主机，反向代理 无人值守化 - phpdragon - 博客园 内网穿透工具frp Windows客户端frpc安装及使用教程 | 直呼过瘾 frp-中文文档-GitHub","link":"/2018/10/21/nat-penetration-and-reverse-proxy/"},{"title":"备份和迁移 Linux 系统","text":"最近折腾了一下，把装在移动硬盘的 Manjaro 复制到笔记本的硬盘里面了。如果你需要备份自己的的 Linux 系统，然后到另一台电脑上安装的话，这篇文章可能会帮到你。 如果你只是想创建一个系统快照，方便将来搞砸的时候还原回来，可以不用这么麻烦，用 Timeshift 就可以了。 准备工作 / 配置要求 一个安装好的，可以启动的 Linux 系统，使用启动引导是 GRUB 2 硬盘分区格式是 GPT，BIOS 引导模式是 UEFI 待备份的系统分区有超过一半的未使用空间（得放得下备份文件） 目标电脑的硬盘上分好分区，准备存放迁移过来的系统 一个 Linux Live CD 启动盘U盘，最好就是安装 Linux 时用的那个镜像 准备完成后就可以开始了！ 备份系统 Wiki 上面提供了很多方式1，我从中选了最简单的一种，就是打包成 tar 压缩包2。 从 Live CD 启动后，查询和挂载你的 Linux 分区： 123su rootfdisk -l # 查看分区信息mount /dev/sda2 /mnt # 假设 sda2 是你的 linux 分区，把它挂载上 要使用的其他分区（如果有的话）需要装载到适当的位置（例如，如果有单独的 /home 分区，就把它挂载到 /mnt/home）。 然后，使用 chroot 把环境切换到分区，准备备份： 1chroot /mnt 执行 tar 命令： 123# -p、--acls 和 --xattrs 存储所有权限、ACL 和扩展属性。如果没有这些属性，许多程序会停止工作！# 可以安全地移除详细信息标志（-v）。如果使用的终端速度较慢，这可以加快备份过程。tar --exclude='/tmp' --exclude='/opt/backup' --acls --xattrs -cpvf /opt/backup/$(date &quot;+%F&quot;).tar.gz / 执行之后，会开始备份系统到 /opt/backup 目录下。--exclude 可以指定想要排除的文件和目录。等到备份结束，把压缩包拷贝出来，放到新电脑的磁盘里面。 恢复系统 在新电脑用 Live CD 启动后，挂载并 cd 到想要还原的分区，解压文件： 1tar --acls --xattrs -xpf backupfile 修改 fstab 文件 接下来需要修改 fstab 文件。fstab 文件是系统开机时需要挂载的分区信息，我们只需要稍加修改，把 UUID 改成新分区的 UUID 就可以了。 1cat /etc/fstab 我的 fstab 是这样： 123456789# /etc/fstab: static file system information.## Use 'blkid' to print the universally unique identifier for a device; this may# be used with UUID= as a more robust way to name devices that works even if# disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;UUID=86A4-0D24 /boot/efi vfat umask=0077 0 2UUID=55ac4657-1043-4cb2-a727-3936a83c8d87 / ext4 defaults,noatime 0 1 这些命令都可以查询磁盘的信息： 123fdisk -lblkidlsblk -o NAME,RM,SIZE,RO,FSTYPE,UUID,MOUNTPOINTS 这一步的 fstab 文件也可以通过挂载好所有目录之后使用 genfstab -U &lt;挂载根目录&gt;来生成。 重建 initramfs initramfs 包含了能够让系统访问根文件系统的模块。如果迁移的设备有变化，就需要重新生成。 我们需要准备 chroot 环境： 12mount /dev/sda2 /mntmount /dev/sda1 /mnt/boot/efi 挂载临时文件系统目录： 12345cd /mntmount -t proc /proc proc/mount --rbind /sys sys/mount --rbind /dev dev/chroot /mnt /bin/bash 如果你用的是 Arch，可以不需要挂载上面的临时文件系统： 1arch-chroot /mnt 重建 initramfs： 1mkinitcpio -p linux 安装启动引导 目前新系统还是没有启动引导的，需要手动安装引导。 在之前 chroot 环境，执行命令安装 grub。 12grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB --recheckgrub-mkconfig -o /boot/grub/grub.cfg 没有报错的话，就是成功了，可以重启系统。 进入系统之后，再执行一次 update-grub 或者 grub-mkconfig -o /boot/grub/grub.cfg。如果启用了os-probe3，会扫描磁盘上的其他系统，比如 Windows，会被添加到启动菜单中。 附：手动引导 如果由于一些原因，比如你的 Live CD 里面没有 grub-install 命令，或者不想安装启动引导到磁盘里面，只是临时启动一下系统，那么可以利用 GRUB 的命令行手动引导启动系统4。 要进入到 GRUB 命令行，可以在开机进入 Live CD 的 GRUB 启动菜单页面的时候按 C。 1234grub&gt; ls -lgrub&gt; linux /boot/vmlinuz-6.1-x86_64 root=UUID=55ac4657-1043-4cb2-a727-3936a83c8d86grub&gt; initrd /boot/initramfs-6.1-x86_64.imggrub&gt; boot ls -l 是可以查看分区信息和对应的 UUID，linux 命令找 /boot 下 vmlinuz 开头的文件，initrd 命令找 initrd 开头的文件。命令和文件都可以按 Tab 自动补全，但是那个 UUID 参数得手打，有点累。 进入系统后，也可以再把启动引导装回来： 123# bootloader-id 会成为 BIOS 启动项的文本sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=manjaro --recheck --verbosesudo update-grub 参见 How to reinstall the GRUB boot loader | Support | SUSE Grub-probe: error: cannot find a GRUB drive for /dev/sda1 - Support - Manjaro Linux Forum 迁移到新硬件 - Arch Linux 中文维基 https://wiki.archlinuxcn.org/wiki/系统备份↩︎ https://wiki.archlinuxcn.org/wiki/使用_tar_备份整个系统↩︎ https://wiki.archlinuxcn.org/wiki/GRUB#探测其他操作系统↩︎ https://www.linuxfoundation.org/blog/blog/classic-sysadmin-how-to-rescue-a-non-booting-grub-2-on-linux↩︎","link":"/2023/01/01/backup-and-migrate-linux/"},{"title":"利用 mDNS 协议来定位局域网主机","text":"再也不用费劲去找树莓派的 IP 地址了！你的操作系统自带了“网络发现”功能。 在一个平常的局域网（开启了 DHCP）下面，获得一台主机的 IP 地址常常有这么几种方法： 用 arp -a 命令查询 arp 缓存； 在目标主机上查找本机的 IP 地址，使用例如 ipconfig 命令； 浏览器登录路由器的后台，从连接的主机列表中查找； 给目标主机设置静态IP。 曾几何时，我一直用上面的方法来连接我的树莓派。树莓派没接显示器，没办法在主机上操作，每次要么使用手机热点（设备管理里面能显示 IP），要么直接改配置分配静态IP。这些方法都有局限性，网络环境一变化，又得配置半天。 现在，一个新的方法出现了！（其实一直就有）只要知道你的设备的主机名，你就可以得到你的设备的 IP 地址。例如，我的树莓派是 Raspbian 系统，它的默认主机名是 raspberrypi，就可以通过域名 raspberrypi.local 来连接，像这样： 1ssh pi@raspberrypi.local 这就是 mDNS （Multicast DNS）协议给我们提供的便利。 偶然的发现 在研究 IGMP 协议的时候，我用 Wireshark 对无线网卡抓取 IGMP 数据包，想看看有没有什么服务是在使用组播（Multicast）地址的。 Wireshark软件截图 之后我看到了局域网内的电脑基本上都会加入这几个组播地址：224.0.0.251，224.0.0.252，239.255.255.250。 经过查找，这三个组播地址分别是协议 mDNS，LLMNR 和 SSDP 协议的。mDNS实现了类似 DNS 的功能，使得主机在局域网内能够加入和通信；LLMNR 的功能和 mDNS 类似；SSDP 是 UPnP 协议的一部分，也是用来实现设备和服务的发现的。 在一段 mDNS 报文中，我看到了这样的内容： 1234567891011121314Multicast Domain Name System (response) [Request In: 172] [Time: 0.205589000 seconds] Transaction ID: 0x0000 Flags: 0x8400 Standard query response, No error Questions: 0 Answer RRs: 4 Authority RRs: 0 Additional RRs: 0 Answers 9.c.4.3.e.b.a.3.5.6.5.3.2.8.e.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa: type PTR, class IN, cache flush, raspberrypi.local raspberrypi.local: type A, class IN, cache flush, addr 192.168.10.108 108.10.168.192.in-addr.arpa: type PTR, class IN, cache flush, raspberrypi.local raspberrypi.local: type AAAA, class IN, cache flush, addr fe80::e82:3565:3abe:34c9 来源是 192.168.10.108，目的是 224.0.0.251。 返回的记录中有我的树莓派的 IPv4 和 IPv6 地址，以及一个相同的字段 raspberrypi.local。 难道说 raspberrypi.local 就是我树莓派的域名？我立马 ping 了一下： 123456789101112131415161718192021222324PS C:\\WINDOWS\\system32&gt; ping raspberrypi.local正在 Ping raspberrypi.local [fe80::e82:3565:3abe:34c9%13] 具有 32 字节的数据:来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=5ms来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=2ms来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=4ms来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=5msfe80::e82:3565:3abe:34c9%13 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 2ms，最长 = 5ms，平均 = 4msPS C:\\WINDOWS\\system32&gt; ping raspberrypi.local -4正在 Ping raspberrypi [192.168.10.109] 具有 32 字节的数据:来自 192.168.10.109 的回复: 字节=32 时间=2ms TTL=64来自 192.168.10.109 的回复: 字节=32 时间=1ms TTL=64来自 192.168.10.109 的回复: 字节=32 时间=2ms TTL=64来自 192.168.10.109 的回复: 字节=32 时间=3ms TTL=64192.168.10.109 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 1ms，最长 = 3ms，平均 = 2ms 确实可以。我流下了激动的泪水：这么好的东西怎么没早发现呢！ mDNS 查询过程 通过分析抓包数据，mDNS 协议在局域网内的 IP 地址查询过程大致是这样的： A：发起查询的主机 B：被查询的主机 A，B 在加入网络时都会发 IGMP 报文加入组 224.0.0.251； A 向组 224.0.0.251 发送 mDNS 组播报文查询 B 的主机名，所有在组内的主机都会收到这个查询请求； B 向组 224.0.0.251 发送回应 mDNS 报文，内容包括自己的主机名和 IP 地址； A 得到 B 的 IP 地址。 其中，mDNS 报文是包装在 UDP 组播报文中的，使用 5353 端口。 主机名的查询和修改 Windows 系统的主机名在环境变量 COMPUTERNAME 查看，可以在系统设置中修改。 1echo %COMPUTERNAME% Windows更改主机名 Linux 系统主机名存在 /etc/hostname 中。使用 hostnamectl 可以查询和修改。/etc/hosts 里也有主机名的记录，也要一并修改。 12345678#查询主机名hostname#临时更改，重启失效sudo hostname &lt;newhostname&gt;#hostnamectl只更改/etc/hostname，记得改/etc/hostssudo hostnamectl set-hostname &lt;newhostname&gt; 我的系统支持吗 Windows 10 以后，系统就能够支持 mDNS 协议了。Windows 10 以下的系统怎么办？你可以： 给 Windows 安装苹果公司的 Bonjour，只有 5 Mb 大小，推荐。 使用 NetBIOS 协议，这是微软的网络发现服务。Linux 系统上安装 samba，它的 nmbd 服务使得能被 Windows 主机发现。使用方法： Windows上：主机名即为域名。主机名是 raspberrypi，直接 ping raspberrypi。 Linux上：默认不解析 NetBIOS 主机名，使用 nmblookup 主机名 来得到 Windows 主机 IP。如果要实现解析 NetBIOS 主机名，需要修改配置文件，没折腾了，看这篇文章 -&gt; 在 Linux 解析 Netbios 名稱。 Linux 一般是安装了 avahi-daemon 服务。使用指令 systemctl status avahi-daemon.service 来查看服务运行状态。 avahi-daemon 安卓系统似乎不支持，我的华为手机没有。 还可以查询 UDP 5353 端口。 Windows： 1netstat -ano | findstr 5353 Linux： 1sudo netstat -nap | grep 5353 其实最简单的就是 ping 一下 主机名.local 看看有没有就知道了。 参见： 3种方法更改Linux系统的主机名(hostname) - ZhangYaohui专栏 - CSDN博客 技术|使用 mDNS 在局域网中轻松发现系统 LLMNR, Multicast DNS and names on your LAN Multicast DNS - Wikipedia Standard mDNS service on Windows - Stack Overflow","link":"/2019/08/07/locate-hosts-using-mdns/"},{"title":"树莓派折腾日记 一：从拆包到点亮","text":"最近从淘宝买来了树莓派3B+，一个基于ARM架构的微型电脑。接下来就要开始折腾之旅了~ 树莓派3B+官方照片 安装系统 到树莓派的官网下载系统Raspbian，这是树莓派官方基于Debian改编的系统。选择“Raspbian Stretch with desktop”，带桌面的系统。虽然我没有显示器，但是如果想要远程桌面登陆树莓派也是需要桌面程序的。“Lite”版不带桌面，体积会小很多。 树莓派没有硬盘，它的的储存用的是SD卡。用SDFormatter格式化SD卡后，用Win32DiskImager刷入镜像。等待大约10分钟后就刷入结束了。这时候把卡插入卡槽就可以启动系统了。 记得不要点错按钮 但是不急。因为我们没有接入显示器，所以没有办法控制树莓派。需要获得树莓派的IP地址以通过SSH连接。 配置连接 在写好的SD卡下有2个分区。一个是/boot，FAT32分区，一个是/，EXT4分区。在Windows系统只看到boot分区。向boot分区根目录新建一个文件名为ssh，无后缀名的空文件。这样树莓派在开机启动时会启用SSH。 如果使用网线连接，可以打开路由器设置查看树莓派的IP地址，或者使用cmd命令arp -a查看局域网下的IP地址。 还可以手动设置ip地址： 打开boot分区下的cmdline.txt： 1dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=PARTUUID=c8d656f3-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles 在最开头添加IP，如ip=172.31.8.8： 1ip=172.31.8.8 dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=PARTUUID=c8d656f3-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles 如果使用WiFi连接，可以在SD卡根目录下建立wpa_supplicant.conf文件。例子如下： 1234567891011121314151617181920212223242526272829303132333435country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1 network={ssid=&quot;WiFi-A&quot;psk=&quot;12345678&quot;key_mgmt=WPA-PSKpriority=1} network={ssid=&quot;WiFi-B&quot;psk=&quot;12345678&quot;key_mgmt=WPA-PSKpriority=2scan_ssid=1}network={ssid=&quot;你的无线网络名称（ssid）&quot;key_mgmt=NONE}network={ssid=&quot;你的无线网络名称（ssid）&quot;key_mgmt=NONEwep_key0=&quot;你的wifi密码&quot;}network={ssid=&quot;你的无线网络名称（ssid）&quot;key_mgmt=WPA-PSKpsk=&quot;你的wifi密码&quot;} 启动后，这个文件将会替换 /etc/wpa_supplicant/wpa_supplicant.conf ，树莓派便会连接相应的WiFi。priority 为优先级，优先级越高的WiFi会先连接。 如果出现网络无法连接的情况，检查一下路由器是否能够联网。如果连接了多个网络（wifi+网线），树莓派可能会使用网线的网络，即使是在网线不能连接到互联网的情况下。这时候拔掉网线就可以让树莓派使用Wifi网络。 启动 插入电源，红灯(PWR)亮，绿灯(ACT)闪烁。顺带一说，树莓派最好用专用的电源，即5V2.5A的电源。如果出现红灯灭或者闪烁的情况就说明供电不足了。红灯指示电源，绿灯指示SD卡的读写状况。第一次启动的时候记得多等一会，毕竟是小电脑，速度比较慢。千万不要在这个时候拔掉电源，等到SD卡绿灯闪烁停止了再操作。我前几次就是因为没有耐心拔掉了电源导致进不了SSH。使用Putty或者Win10自带的ssh连接。 Raspbian的ssh默认登陆用户名：pi，密码：raspberry。 成功！ putty登陆树莓派 换软件源 Raspbian自带的源慢且不稳定，软件安装到80%下载不下来就是这个原因。换成镜像源速度会快很多。 注释掉原有的源，换成中科大的。 1sudo vi /etc/apt/sources.list 1234deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi#deb http://raspbian.raspberrypi.org/raspbian/ stretch main contrib non-free rpi# Uncomment line below then 'apt-get update' to enable 'apt-get source'#deb-src http://raspbian.raspberrypi.org/raspbian/ stretch main contrib non-free rpi 1sudo vi /etc/apt/sources.list.d/raspi.list 1234deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian stretch main ui#deb http://archive.raspberrypi.org/debian/ stretch main ui# Uncomment line below then 'apt-get update' to enable 'apt-get source'#deb-src http://archive.raspberrypi.org/debian/ stretch main ui 改完更新： 1sudo apt-get update 远程桌面 安装tightvncserver和xrdp。教程上说一定要先安装 tightvncserver 再安装 xrdp 不然会出问题。 123456sudo apt-get install tightvncserversudo apt-get install xrdpsudo service xrdp restart#sudo ufw allow 3389 #如果开着防火墙ufw，那么打开服务器上的远程桌面访问端口#sudo service ufw restart win+R输入mstsc打开远程桌面连接界面，输入树莓派IP地址进行连接。 mstsc 输入用户名和密码，就可以进桌面了。 树莓派的桌面 想不到，里面居然有MC，真是个好东西🤭。 拍个照： 树莓派照片 关机 下面的命令都可以让树莓派关机，不到万不得已不要用拔电源的方式来关机。 1234sudo haltsudo poweroffsudo shutdown nowsudo init 0 参考资料： 无屏幕和键盘配置树莓派WiFi和SSH | 树莓派实验室 没有显示器情况下，安装和使用树莓派 windows远程桌面连接树莓派通过xrdp服务 树莓派无法上网 – 钝钝的blog – CSDN博客","link":"/2018/06/23/raspberry-diary-01/"},{"title":"安装完 Ubuntu 18.04 要做的 n 件事","text":"以此做为备忘，以防不时之需。 调整时区 换软件源 安装额外驱动 调整色彩空间 主目录下的文档文件夹改回英文 安装字体 安装 gnome/unity 界面优化工具 安装Ubuntu受限的解码器 安装flash Gnome桌面Dock点击最小化 安装Fcitx和搜狗输入法 安装vim，mplayer等其他软件 命令 1234567891011121314151617181920212223242526272829303132#调整时区和windows一致timedatectl set-local-rtc 1 --adjust-system-clock#切换软件包语言sudo dpkg-reconfigure locales#文泉驿点阵正黑字体 sudo apt-get install fonts-wqy-zenhei#开启Gnome隐藏设置sudo apt-get install gnome-tweak-tool#安装ubuntu受限的额外的解码器sudo apt-get install ubuntu-restricted-extras#flash浏览器插件 (要勾选&quot;软件和更新&quot;中的&quot;Canonical 合作伙伴&quot;)sudo apt install adobe-flashplugin#gvim相比vim对图形化支持比较好sudo apt-get install vim-gtk3#mplayer：无图形化的视频播放器sudo apt-get install mplayer# 18.04gnome桌面Dock点击最小化 (或者用dconf-config图形化配置)#gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize-or-overview'#后来发现还是默认的好用，还是不要改好了#安装搜狗输入法 (https://pinyin.sogou.com/linux/)wget &quot;http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb&quot;sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.debsudo apt-get --fix-broken install #这会自动安装Fcitx 换软件源 有图形化的方法可以更换软件源，在 软件和更新 -&gt; Ubuntu 软件 -&gt; 下载自 里面可以选择其他站点。有上海交大、兰州大学、阿里云、南大、南邮、中科大等镜像源可以选择（列表里居然没看到网易的…）。选择离你地理位置较近的源，因为这样速度快。然后在 其他软件 中勾选 Canonical 合作伙伴 ，因为里面有包括我们需要的flash插件。 更改软件源 安装额外驱动 在 软件和更新 -&gt; 附加驱动 中有闭源的专用驱动，比如Nvidia的显卡驱动，安装上以达到最佳效果。 安装附加驱动 装完上面的驱动后，整个桌面变得更卡了，拖动窗口都有残影……就像游戏里没有开垂直同步的效果一样。事实证明，显卡驱动最好还是要到官网上下载和使用才能找到适合自己的版本。 调整色彩空间 我在用Ubuntu上的图片查看器的时候总觉得图片比原始图片看起来更加鲜艳。后来在知乎上看到了一篇文章才知道是色彩管理没有设置好。在 设置 -&gt; 设备 -&gt; 色彩 里面添加配置，选择合适自己显示器的色彩空间。 调整色彩空间 色彩空间不正确的色差 色彩空间不正确的话可能会导致图片过于黯淡或鲜艳，连续截图几次看到的效果更明显。 安装 gnome/unity 界面优化工具 gnome-tweak-tool 是适用于Gnome桌面的，而unity-tweak-tool则适用于Unity桌面。虽然说Ubuntu即将抛弃Unity桌面，但是登录界面还是留下了两个桌面的选项让用户选择。Ubuntu的新桌面比较适合触屏，但是Bug比较多，优化也比较不好。另一个Unity就是经典的Ubuntu桌面。 这两个工具的功能是相近的，都是可以打开桌面的隐藏设置，比如桌面动画，显示字体，主题，图标，还有各种窗口，鼠标键盘的设置，功能十分强大。 gnome-tweak-tool界面 安装字体 新建 ~/.local/share/fonts/ 文件夹，然后就可以把ttf、ttc格式的字体放进去。我们可以从windows系统里把微软的中文字体拷过来（在 C:\\windows\\system32\\fonts 下)。这样我们就能够在文本编辑器等其他地方选择我们需要的字体了。 添加微软字体后的字体菜单 推荐安装文泉驿点阵正黑字体（fonts-wqy-zenhei），这个字体在合适的字体大小时显示点阵字体，在超出点阵字体范围时显示为渲染字体。在 gnome-tweaks 里设置界面和窗口字体。对于分辨率比较低的屏幕来说，点阵字体将会显示得更加清晰。 点阵字体和默认字体的对比 安装Fcitx和搜狗输入法 目前的搜狗输入法在18.04上还有一些问题，会导致fcitx的一些菜单项点不开。Unity桌面fcitx图标都显示不出来，只是勉强可以用。 先写这些吧，以后有想到再加上。","link":"/2018/08/17/n-things-to-do-after-installing-ubuntu-18-04/"},{"title":"树莓派折腾日记 二：网络相关配置","text":"主要是解决两个问题： 同时连接两个网络时由于默认网卡不对导致不能上网； 开机的时候等n久都连不上 WiFi，但是一插上网线，WiFi 就通了。 WiFi 相关 查看和连接 查找附近的无线网络： 12sudo iwlist wlan0 scansudo iwlist wlan0 scan | grep &quot;ESSID&quot; 查看当前的 WiFi 网络： 12iwgetidiwconfig 编辑连接： 1sudo vim /etc/wpa_supplicant/wpa_supplicant.conf 123456network={ssid=&quot;abc&quot;psk=&quot;12345678&quot;key_mgmt=WPA-PSKpriority=17} 更新配置： 1wpa_cli -i wlan0 reconfigure 开关 WiFi 临时开关： 12sudo ifconfig wlan0 downsudo ifconfig wlan0 up 永久关闭： 1echo &quot;dtoverlay=pi3-disable-wifi&quot; | sudo tee -a /boot/config.txt 其他开关（蓝牙）： How to disable onboard WiFi and Bluetooth on Raspberry Pi 3 静态 IP 第一次连接树莓派的时候为了确定 ip 可能会将 ip=xxxx 的信息写在 /boot/cmdline.txt 里面，不过后期要用静态 IP 的时候不建议这么写，否则树莓派在启动的时候为了连接有线网络会等待很长时间。如果仍要设置静态 IP ，这么配置比较好： 1sudo vim /etc/dhcpcd.conf 在最后添加如下内容： 12345interface eth0 #网络名static ip_address=172.31.31.35/26 #ipv4地址 / 网络前缀#static ip6_address=fd51:42f8:caae:d92e::ff/64 #ipv6static routers=172.31.0.1 #网关tatic domain_name_servers=202.99.166.4 8.8.8.8 #DNS域名解析服务器 它的网络配置和其他的有些不同，dhcpcd 用的不是子网掩码，而是 CIDR 的斜线记法，两者之间需要稍微换算一下。比如 ip 地址 192.168.191.1，子网掩码 255.255.255.0，就可以记为 192.168.191.1/24。 为什么不去编辑/etc/network/interfaces呢？在我这个版本（2018-04-18-raspbian-stretch）中 interfaces 里面说静态 IP 得去 dhcpcd.conf 里面配置： 1234567# interfaces(5) file used by ifup(8) and ifdown(8)# Please note that this file is written to be used with dhcpcd# For static IP, consult /etc/dhcpcd.conf and 'man dhcpcd.conf'# Include files from /etc/network/interfaces.d:source-directory /etc/network/interfaces.d raspbian - Multiple IP addresses being assigned - Raspberry Pi Stack Exchange 路由选择网卡上网 我的网线走的是联通的个人网，需要设置 Netkeeper 才能上网。所以为了给树莓派联网，我只能用手机或电脑开热点。但是在同时连接网线和WiFi的时候，树莓派上不了网，只有拔掉网线之后，树莓派才能打开网页。 不仅仅是树莓派，我装在电脑上的 Ubuntu 也是这样，每次上网总得拔掉网线，再连wifi，很麻烦。 上过组网课后今天再次想到这个问题，这应该和路由协议有关。查看路由表： 12345678pi@raspberrypi:~ $ routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault 172.31.0.1 0.0.0.0 UG 202 0 0 eth0default 192.168.191.1 0.0.0.0 UG 303 0 0 wlan0172.31.0.1 0.0.0.0 255.255.255.255 UH 202 0 0 eth0172.31.31.0 0.0.0.0 255.255.255.192 U 202 0 0 eth0192.168.191.0 0.0.0.0 255.255.255.0 U 303 0 0 wlan0 发现默认路由 default （有时候显示为0.0.0.0）转发的网关有两个，一个是 eth0 （网线）的 172.31.0.1 ，一个是 wlan0 （WiFi）的 192.168.191.1 。由于 eth0 排在 wlan0 的前面，发给因特网的请求会转发给网关，然后联通把数据包吞了。看下面的 ping 测试： 1234567891011pi@raspberrypi:~ $ ping -c 4 baidu.comPING baidu.com (123.125.114.144) 56(84) bytes of data.From 172.31.31.35 icmp_seq=1 Destination Host UnreachableFrom 172.31.31.35 icmp_seq=2 Destination Host UnreachableFrom 172.31.31.35 icmp_seq=3 Destination Host UnreachableFrom 172.31.31.35 icmp_seq=4 Destination Host Unreachable--- baidu.com ping statistics ---4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 23107mspipe 4 既然 172.31.0.1 的路由转发记录无效，不妨把它删除。 1234567891011121314151617181920pi@raspberrypi:~ $ sudo route del default gw 172.31.0.1 eth0pi@raspberrypi:~ $ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 192.168.191.1 0.0.0.0 UG 303 0 0 wlan0172.31.0.1 0.0.0.0 255.255.255.255 UH 202 0 0 eth0172.31.31.0 0.0.0.0 255.255.255.192 U 202 0 0 eth0192.168.191.0 0.0.0.0 255.255.255.0 U 303 0 0 wlan0pi@raspberrypi:~ $ ping -c 4 baidu.comPING baidu.com (220.181.57.216) 56(84) bytes of data.64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=1 ttl=53 time=13.7 ms64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=2 ttl=53 time=15.0 ms64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=3 ttl=53 time=17.6 ms64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=4 ttl=53 time=16.7 ms--- baidu.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3004msrtt min/avg/max/mdev = 13.730/15.800/17.656/1.515 ms 移除完这条记录，地址就能够正常解析了，百度也 ping 得通了。所以原因在于存在多个默认网关，并且那个首选的网关是不可到达的。重启系统或网络后路由表就会恢复，可以把它当作一个临时的做法。如果要永久生效的话也有办法的，我就没折腾了，文末的参考连接里面有。 回头一看，上一篇树莓派日记已经是快一年前的事情了……惭愧，或许叫吃灰日记比较好（ 参考资料： 鸟哥的 Linux 私房菜 -- 架设 Router linux route命令的使用详解 - 一个人的旅行的博客 - CSDN博客 双网卡服务器选择默认路由 - Avalon - CSDN博客 【树莓派】双网卡添加多路由静态路由持久化的问题处理 - 念槐聚 - 博客园","link":"/2019/05/17/raspberry-diary-02-network-configure/"},{"title":"XML 语法笔记","text":"XML 光速入门！教程来自 W3school。 什么是 XML？ 可扩展标记语言（EXtensible Markup Language） 用于数据传输 自行定义标签 方便程序读取 组成成分：元素、属性和文本 RFC 4825 TL;DR 下面这张图是网站“Linux中国”的 RSS 片段，很有代表性，我把各个字段的含义都标出来了，基本上包括了 XML 的所有语法。 一张图看懂 XML！ 元素 元素（Element）是指从开始标签到结束标签的部分，包括标签本身和标签包括的内容。 一个元素里面可以有： 属性 子元素 文本 子元素还能继续包含其他元素，所以是一个树形结构。 注意：XML 没有预定义的标签，这和 HTML 不同，HTML 中的 &lt;p&gt;、&lt;h1&gt; 标签都是预定义的。XML 所有的标签和属性都是创作者自定义的。 例子 1234567891011121314151617181920&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; XML 的树形结构 | W3school 语法规则 所有的元素必须关闭标签 对大小写敏感 标签必须正确的嵌套 文档必须有根元素 特殊意义的字符使用实体引用（Entity References） 实体引用以 &amp; 开头，以 ; 结尾，比如 &lt; 字符用 &amp;lt; 替换。 注释：&lt;!-- 注释内容 --&gt; XML 中空格会被保留，而 HTML 会把多个空格合并成一个 属性 属性（Attribute）提供关于元素的额外（附加）信息。 附加的存在 属性值双引号 难以维护 属性通常提供不属于数据组成部分的信息，但这些信息对于处理这个元素的软件来说很重要。 1&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt; 包含双引号的属性值用单引号包围： 1&lt;gangster name='George &quot;Shotgun&quot; Ziegler'&gt; 或者可以使用实体引用： 1&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt; 元素还是属性？ 12345678910&lt;person sex=&quot;female&quot;&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt;&lt;person&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 这两个例子传递的信息都是相同的，只是 sex 一个是作为属性存在，一个是作为字段存在。什么时候用属性，什么时候用字段是没有规定的。教程里面建议，如果信息看起来很像数据，就使用子元素。 元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。 命名空间 命名空间可以避免元素名冲突。 使用前缀可以避命名冲突。前缀是在标签名的前面加上前缀名称，用冒号隔开： 123456&lt;h:table&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt; 而命名空间对标签进行限定，声明某个前缀属于一个特定的命名空间，采用的方法是添加一个 xmlns 属性： 1xmlns:namespace-prefix=&quot;namespaceURI&quot; 123456&lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt; 命名空间地址的作用是唯一性，不会被解析，通常是对应的开发者的网站。 用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。 如果省略了前缀名字，则表示所有子元素都属于这个命名空间。 1xmlns=&quot;namespaceURI&quot; 123456&lt;table xmlns=&quot;http://www.w3.org/TR/html4/&quot;&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; CDATA XML 解析器不会解析 CDATA 部分内的文本，常用来保存大段原始数据。 CDATA 部分以 &lt;![CDATA[ 开始，以 ]]&gt; 结束： 1&lt;![CDATA[不会被解析的内容]]&gt; CDATA 部分不能包含字符串 ]]&gt;。也不允许嵌套的 CDATA 部分。 标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行。 XML 相关技术 名称 描述 XML HttpRequest 用于在网页服务器之间传递数据，比如 AJAX XML Parser 解析器，用来将 XML 文本解析成 DOM 对象 XML DOM 定义了操作 XML 文档的规范，把 XML 展示为树形结构 XML XPath XPath 表达式使用类似文件路径的语句来选取 XML 中的节点 XML CSS 用 CSS 样式表来格式化 XML 文档 XML XSLT 同样是用来格式化 XML 的，比 CSS 复杂，功能更多 XML XQuery XML 的查询语言，如同 SQL 之于数据库 XML XLink XML 里的超链接 XML DTD 规范化，用来定义 XML 文档元素和属性的结构 XML Schema 描述 XML 文档结构，自己也是 XML 语法，功能和 DTD 一样 参考资料： XML 教程 | W3school XML Tutorial | W3Schools 技术|XML 与 JSON 优劣对比 | Linux中国 为什么都反对 XML 而支持使用 JSON？ - 知乎","link":"/2020/02/19/xml-syntax-note/"},{"title":"给站点开启SSL&#x2F;HTTPS","text":"给网站地址栏上添加绿色小锁：我变绿了，也变安全了。 国庆旅游归来早，忙趁假期瞎折腾。 为什么要使用https SSL是应用层和运输层之间的加密协议，相比于http的明文传输来的更加安全。SSL能够有效降低中间人攻击的风险。比如使用Fiddler软件抓取https包的时候就需要先向浏览器添加自己的CA证书，因为没有证书信任的话就无法获得加密的内容。 SSL安全会话建立过程 | 《计算机网络》 全站https有利于提升网站在搜索引擎的收入率。在相同权重的情况下，搜索引擎会认为https站点的安全性更高而将网站排在前面。 站点使用https可以让自己的站点更加醒目（说白了就是想装13啦）。 申请SSL证书 有许多的免费SSL证书提供商。我用的是腾讯云的DV SSL证书。在这里可以申请TrustAsia提供的免费证书，为期1年。（顺便瞟了一眼OV和EV的企业付费证书，价格基本5k以上…） 申请需要验证你的主机和域名，会要求在指定位置放置验证文件或者给域名添加一条解析记录。如果你的域名也是从腾讯云买的，它会给你自动添加。验证的速度很快，大约10分钟就能审核通过。 如果你等了1小时还没通过就别等了，赶紧检查一下自己填的信息有没有错吧，不要像我一样把域名打错了然后傻等了一天T T。 证书文件 审核通过后会颁发的证书可以下载到本地。打开后里面有为各种http服务器使用的证书和密钥文件。我用的是Apache，就把Apache文件夹下的3个文件上传到服务器上。 编辑Apache配置 编辑 etc/httpd.conf 文件，找到#LoadModule ssl_module modules/mod_ssl.so 和#Include conf/extra/httpd-ssl.conf，去掉前面的#号注释，启用SSL模组。 编辑/lampp/etc/extra/httpd-ssl.conf文件添加主机和证书： 12345678&lt;VirtualHost 0.0.0.0:443&gt; DocumentRoot &quot;/opt/lampp/htdocs/wordpress/&quot; ServerName blog.beanbang.cn SSLEngine on SSLCertificateFile /opt/lampp/ssl-crt/2_blog.beanbang.cn.crt SSLCertificateKeyFile /opt/lampp/ssl-crt/3_blog.beanbang.cn.key SSLCertificateChainFile /opt/lampp/ssl-crt/1_root_bundle.crt&lt;/VirtualHost&gt; 完成后需要重启Apache服务器。 开启443端口 https协议使用的不是80端口而是443端口。如果有防火墙记得允许443端口的TCP数据包通过。 在安全组中允许TCP443端口 Wordpress设置 wordpress目录下的.htaccess文件： 123456&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteBase /RewriteCond %{HTTPS} !=onRewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]&lt;/IfModule&gt; 这样使用http访问网页会被301永久重定向至https页面。 编辑wp-config.php： 在 “if ( !defined('ABSPATH') )” 前面，即\"请不要再继续编辑”的提示前面添加。这样登陆博客时会强制使用https以保障安全。 123456$_SERVER['HTTPS'] = 'ON'; //网页下的链接全部由'http://'转换为'https://'define('FORCE_SSL_LOGIN', true);define('FORCE_SSL_ADMIN', true); //管理员登陆博客时跳转为https/* 好了！请不要再继续编辑。请保存本文件。使用愉快！ */if ( !defined('ABSPATH') ) 更改域名信息、固定链接？ 在有的教程里面还说需要像更换域名那样把全站的数据库中所有的“http”链接全部转换成“https”。其实不推荐也不需要这么做。上面的$_SERVER['HTTPS'] = 'ON';设置过以后，wordpress是会自动识别转换的。 结束 现在，打开网站 https://blog.beanbang.cn 就可以正常访问了。即使是不加https前缀也能自动跳转到https。由于中间环节多了一个验证加密的步骤，网站打开的时间会比以往更长一些。 网站https标志 参考资料 证书安装指引 - SSL 证书 - 文档平台 - 腾讯云 wordpress http强制跳转https，我是这么做的，真正的零故障|永云博客 WordPress启用https访问实战教程 | 王商博客 Wordpress使用SSL证书开启HTTPS最简单的办法 - 四座 十大免费SSL证书：网站免费添加HTTPS加密 - 阳光岛主 - CSDN博客","link":"/2018/10/09/enable-ssl-https-for-website/"},{"title":"再见了，Netkeeper！","text":"终于解决了 Netkeeper 占用后台和开热点的问题。 Netkeeper登陆界面 假如你用的是联通提供的个人网，那你应该很熟悉这个叫WO的校园的软件了。它的下载地址在这里。这是联通用来拨号上网的客户端软件。 购买了联通的个人网后（当时是被“强制”订的，奸商太坑），在客户端输入联通提供的用户名和密码，连通之后就可以上网了。曾几何时，我以为这是一个简单的拨号上网辅助软件。日子一天天过去，有一次我要用电脑开热点给手机用的时候，网络断开了，并弹出了这样的提示：发现共享软件。 Netkeeper发现网络共享软件后的提示 这个时候，我才发现了这个软件的真正目的：限制网络共享。在程序的安装目录可以看到这个软件的真正名字叫Netkeeper。原来，联通给我们的上网密码并不是PPPoE协议的拨号上网密码。真正的拨号密码是用这个软件的算法算出来的。这就使得用户不得不使用这个软件来上网。拨号成功后，Netkeeper继续留在后台监控是否有网络共享软件，若发现如猎豹Wifi之类软件的进程名，就会断开网络。如果直接退出Netkeeper，网络也会断开。这样，黑心的运营商便达到了它的目的： 一机一号 限制网络共享 真是名副其实的 “个人网”啊。但我怎能就这样轻易放弃？打开进程管理器发现有2个乱码进程，结束其中一个，Netkeeper提示“软件运行环境被破坏！”,然后就退出了。这两个进程还互相守护，结束其中一个，另一个就会发现并断网。 于是使用管理员打开CMD，tasklist如下： 1234567891011C:\\WINDOWS\\system32&gt;tasklist映像名称 PID 会话名 会话# 内存使用========================= ======== ================ =========== ============System Idle Process 0 Services 0 8 KSystem 4 Services 0 1,952 K...702C4F30-F8C4-49EC-A1BD-5 11996 Console 1 22,680 K702C4F30-F8C4-49EC-A1BD-5 6564 Console 1 77,028 KWmiPrvSE.exe 13884 Services 0 9,672 Ktasklist.exe 11780 Console 1 7,780 K 123C:\\WINDOWS\\system32&gt;taskkill /f /pid 11996 /pid 6564成功: 已终止 PID 为 11996 的进程。成功: 已终止 PID 为 6564 的进程。 taskkill成功结束进程，网络也没有断开。爽哉，终于可以开热点了~ 不过每次启动都要打进程名字还是比较麻烦。查看netkeeper的安装目录： 12345678910111213141516D:\\Program Files\\NetKeeper&gt;tree卷 Software 的文件夹 PATH 列表卷序列号为 0EEF-2F34D:.├─config├─help│ └─picture├─logs├─run│ └─FF8AF4B3-DEC7-421A-948B-D24571B95BE0│ ├─config│ ├─help│ │ └─picture│ ├─logs│ └─skin└─skin 在刚安装完软件的时候，run文件夹是空的，第一次运行后，netkeeper把目录下所有文件拷贝一份进run/乱码里，并且把NetKeeper.exe改名为乱码.exe，并且每次启动程序都改变一次乱码。这样就避免了自动化程序发现并结束掉自己。 经过一番百度，发现了神奇的wmic命令，可以查询程序的运行路径。 123456789101112131415161718192021C:\\WINDOWS\\system32&gt;wmic process get executablepath,captionCaption ExecutablePathSystem Idle ProcessSystemsmss.execsrss.exewininit.execsrss.exeservices.exelsass.exe C:\\WINDOWS\\system32\\lsass.exesvchost.exe c:\\windows\\system32\\svchost.exe...5D5AEDF7-DBDB-4CF8-B41A-9F4A00E17552.exe D:\\Program Files\\NetKeeper\\run\\FF8AF4B3-DEC7-421A-948B-D24571B95BE0\\5D5AEDF7-DBDB-4CF8-B41A-9F4A00E17552.exe5D5AEDF7-DBDB-4CF8-B41A-9F4A00E17552.exe D:\\Program Files\\NetKeeper\\run\\FF8AF4B3-DEC7-421A-948B-D24571B95BE0\\5D5AEDF7-DBDB-4CF8-B41A-9F4A00E17552.exeWmiPrvSE.exe C:\\WINDOWS\\system32\\wbem\\wmiprvse.execmd.exe C:\\WINDOWS\\system32\\cmd.execonhost.exe C:\\WINDOWS\\system32\\conhost.exeSearchFilterHost.exe C:\\WINDOWS\\system32\\SearchFilterHost.exebackgroundTaskHost.exe C:\\WINDOWS\\system32\\backgroundTaskHost.exenotepad.exe C:\\WINDOWS\\System32\\NOTEPAD.EXEWMIC.exe C:\\WINDOWS\\System32\\Wbem\\WMIC.exe 可以看到，netkeeper已经露出马脚啦。无论进程的名字如何变化，程序的启动路径是不变的，其中都会含有 netkeeper\\run 字样。这样，写出自动化的批处理脚本就容易了。 最终KillNetkeeper.bat文件编写如下： 123456789101112131415161718192021222324252627282930313233343536@echo offchcp 936&gt;nulset PATH=%SystemRoot%;%SystemRoot%\\system32;%SystemRoot%\\System32\\Wbemset PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSCtitle killNetKeeper by Beanbangecho 本批处理用于结束联通wo的校园NetKeeper软件进程echo 请右键使用管理员权限来运行:bacecho ----------------------------------------------------------------------echo 开始查找NetKeeper进程名...echo+for /f &quot;delims= &quot; %%i in ('wmic process get executablepath^,caption^|findstr NetKeeper\\run') do ( if not &quot;%%i&quot;==&quot;update.exe&quot; set name=%%i )if not defined name echo 未找到&amp;echo 进程可能已结束,或没有以管理员权限运行&amp;goto exitif defined name echo 找到了！进程名为 %name%TASKKILL /F /IM %name% ||echo 进程可能已结束&amp;goto bye:exitecho+echo+echo 退出...ping -n 3 127.1&gt;nulexit:byeecho+echo+echo 再见了,NetKeeper! :Pping -n 2 127.1&gt;nulexit 运行文件就能自动查找并结束进程。 之后我又发现了netkeeper每次启动都会运行update.exe文件来检查更新。于是打开codeblocks，写了一个简短的文件。 123456789#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int main(){ system(&quot;cmd /c killNetkeeper.bat&amp;exit&quot;); return 0;} 目的就是运行killNetkeeper.bat，编译成update.exe。没错，偷梁换柱！当netkeeper启动后，想要检查更新时，它不知道已经打开了结束自己的文件。 KN运行后自动退出 从此以后，被限制网络的日子终于一去不复返了，也可以给自己和小伙伴开热点了。再见了，NetKeeper！ 下载 killNetkeeper.exe 自解压文件，可以直接运行，也可以用WinRAR打开。将文件重命名替换掉’Netkeeper/run/乱码’下update.exe即可。 后记 这个方法只能在Windows下能用，Mac没用过，Linux…连客户端都没有。 做这个软件的叫西安信利软件科技公司，产品的定义是“防私接客户端”，从功能上看确实做得挺好的。 有研究Netkeeper算法的项目叫SimpleNetkeeper，曾经一段时间用这个可以代替联通客户端，很好用。但是后来联通更新了算法，SN就不能用了，不过他们的通过路由器拨号的方法还是可以的（但我自己没试成功，而且个人网限速2mb/s，也不适合集体网使用）。不过最近好像不维护了，看官网和这里。","link":"/2018/03/10/good-bye-netkeeper/"},{"title":"获取 Mybatis-Plus Wrapper 生成的SQL语句","text":"最近遇到一个需求：不执行数据库查询，而是把查询的逻辑，也就是 SQL 语句，传递给另一个微服务，让它去查。于是就想到，如果可以用 Mybatis-Plus 拼好的 Wrapper 构造器来生成 SQL，就可以不用在代码里面拼 SQL 语句了。 解决办法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@AutowiredSqlSessionFactory sqlSessionFactory;public void getSelectListSQL() { // wrapper 拼查询条件 QueryWrapper&lt;TaskUser&gt; ew = new QueryWrapper&lt;&gt;(); ew.lambda() .select(TaskUser::getTaskId) .eq(TaskUser::getUserId, &quot;123456&quot;) .like(TaskUser::getNodeName, &quot;123456&quot;) .and(w -&gt; w.likeLeft(TaskUser::getOrgCode, &quot;546&quot;)) .orderByAsc(TaskUser::getCreateTime); // wrapper 会作为参数传入 mapper Map&lt;String, Object&gt; params = Collections.singletonMap(&quot;ew&quot;, ew); // sqlSessionFactory 从 Spring 容器中获得 Configuration configuration = sqlSessionFactory.getConfiguration(); // 使用类引用+方法名得到 mapper 语句 MappedStatement mappedStatement = configuration.getMappedStatement(&quot;cn.beanbang.spi.mapper.TaskUserMapper.selectList&quot;); BoundSql boundSql = mappedStatement.getBoundSql(params); String sql = getExecuteSql(boundSql, params); System.out.println(sql);}private String getExecuteSql(BoundSql boundSql, Object paramObject) { // 带有问号占位符的 SQL 语句 String sql = boundSql.getSql(); // 参数信息列表 List&lt;ParameterMapping&gt; paramMappings = boundSql.getParameterMappings(); // MetaObject 是 mybatis 通过表达式取出对象内容的工具 MetaObject metaObject = sqlSessionFactory.getConfiguration().newMetaObject(paramObject); for (ParameterMapping p : paramMappings) { String paramName = p.getProperty(); Object paramValue = metaObject.getValue(paramName); String value = &quot;&quot;; if (paramValue instanceof String) { value = &quot;'&quot; + paramValue + &quot;'&quot;; } else { // todo 其他类型的参数的对应的拼接方式 } sql = sql.replaceFirst(&quot;\\\\?&quot;, value); } return sql;} 输出的语句： 123456SELECTtask_id FROM TASK_USER WHERE IS_DELETED=2AND (user_id = '123456' AND node_name LIKE '%123456%' AND (org_code LIKE '%546')) ORDER BY CREATE_TIME ASC 下面是摸索出结论的过程（心路历程： JDBC 所有的 ORM 框架，最后都是要通过 JDBC 去和数据库交互的。类似这样： 123456789101112131415try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) { try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;)) { ps.setObject(1, &quot;M&quot;); // 注意：索引从1开始 ps.setObject(2, 3); try (ResultSet rs = ps.executeQuery()) { while (rs.next()) { long id = rs.getLong(&quot;id&quot;); long grade = rs.getLong(&quot;grade&quot;); String name = rs.getString(&quot;name&quot;); String gender = rs.getString(&quot;gender&quot;); } } }}// 来自 https://www.liaoxuefeng.com/wiki/1252599548343744/1321748435828770 为了避免注入问题，基本上所有的语句执行都会使用 PreparedStatement。而 prepared statement 的执行过程是这样的： 带占位符的语句被发送到数据库服务器，先被解析成某种数据结构并储存在内存中； 绑定的参数被发送到服务器； 整个语句被执行。 所以事实上整个查询的过程中都不会有“最终的”SQL 语句生成，没有办法从 JDBC 的执行过程得到 SQL 语句。 不过，一些数据库驱动的实现是可以得到语句的。比如 MySQL 的 PreparedStatement 的 toString() 方法可以输出拼接参数的完整语句。但是并不是所有数据库厂商都有去实现的，而我们这个项目也是需要支持多种类型的数据库，所以这样也不是很通用。 所以，我们只能手动拼接语句和参数来得到完整的 SQL 语句了。接下来就是要知道 Mybatis 是怎么调用 JDBC 的了。 MyBatis MyBatis 的原理是，在 XML 文件中用模板语言编写 SQL 语句，然后在代码里面编写一个和 XML 的参数和返回值相匹配的接口（Mapper）。调用接口，并传递相应的参数，MyBatis 就会把参数和模板语句结合起来，生成最终需要执行的参数和语句，然后调用 PreparedStatement 执行。 12345&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #{id} &lt;/select&gt;&lt;/mapper&gt; 123try (SqlSession session = sqlSessionFactory.openSession()) { Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);} Mybatis 的核心是 SqlSessionFactory 类。执行查询，或者获取配置信息都是从这里开始的。程序启动后，Mapper 文件到了代码里面就加载成了一个个的 MappedStatement 对象，一个 MappedStatement 实例对应着一个 Mapper 文件里的一个查询语句： 12Configuration configuration = sqlSessionFactory.getConfiguration();MappedStatement mappedStatement = configuration.getMappedStatement(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;); 那 MappedStatement 是怎么和我们传入的参数组合，最后生成 PreparedStatement 的呢？经过一段时间顺藤摸瓜地查找，终于找到了处理逻辑所在的地方：DefaultParameterHandler#setParameters。 boundSql：SQL 语句和参数信息。储存了用问号占位符标记的生成的 SQL 语句，以及每一个参数的类型信息和参数符号表达式（就是用 #{} 包起来的部分）； parameterObject：传入的参数； MetaObject：这个工具可以读取参数对象，然后根据表达式从参数对象取出对应的值。 有了 BoundSql 和 MetaObject 我们就可以手动把问号 SQL 拼成完整 SQL 了。 最后一个问题：Mybatis-Plus Wrapper 的原理是什么？它是怎么调用 Mybatis 的？ MyBatis-Plus Mybatis-Plus 全面接管了 Mybatis。结合 Spring 框架，从头到尾都不需要手动加载配置，创建连接了。并且内置了很多方便的增删改查接口，以及条件构造器，可以很方便地进行条件查询。 通过对生成的 QueryWrapper 断点调试我们可以发现，wrapper 自己本身就是传递给 mapper 的参数。Wrapper 负责的是生成 where 部分的语句和参数。wrapper 得到的 SQL 语句里面的参数是 #{ew.paramNameValuePairs.MPGENVALx} 的形式，很明显引用了自己（ew 即 EntityWrapper，是 MP 旧版本的 Wrapper 类名）。 在项目启动的时候，MP 会找到 selectList 方法的实现类 SelectList，然后把所有的 SQL 片段拼接起来，动态生成一个 MappedStatement，然后放入 mybatis 的 sqlSessionFactory 里面。 假如我们调用了 service.selectList(wrapper)，其实也相当于执行了一次 Mybatis 查询，只不过 Mapper 语句是 MP 帮你生成的（BaseMapper 方法注入），传入的参数也是 MP 帮你生成的（在 wrapper 里面）。 这样，完整的链条就串起来了： SqlSessionFactory + Mapper id =&gt; MappedStatement（SQL 模板） 拼接查询条件 Wrapper（参数） Wrapper + MappedStatement =&gt; BoundSql（占位符 SQL + 参数信息） BoundSql + Wrapper =&gt; 完整 SQL 参见 MyBatis 原理系列(六)-手把手带你了解 BoundSql 的创建过程 - 掘金 (juejin.cn) Java 获取 Mybatis 动态生成的 sql - yinder - 博客园 (cnblogs.com) java - MyBatis 3 - get SQL string from mapper - Stack Overflow MyBatis-Plus 简介和原理解析 | 码农家园 (codenong.com) MyBatis-Plus 的 BaseMapper 实现原理 - 掘金 (juejin.cn) 面试官：Mybatis 如何将数据库类型转换成 Java 类型？如何创建 SQL 返回的对象？如何起别名？ - 知乎 (zhihu.com) java - How can I get the SQL of a PreparedStatement? - Stack Overflow","link":"/2022/01/26/get-sql-statement-from-mybatis-plus/"},{"title":"让Minecraft用上独立显卡","text":"在默认的情况下，我的世界是不会以独立显卡运行的。在电脑既有独显的情况下，MC会用集显来运行。所以想让你的游戏运行得更流畅，就要更改显卡设置。 1. 首先，检查自己的电脑是否有独立显卡。 在我的电脑上右键 –&gt; 管理 管理 设备管理器 –&gt; 显示适配器 查看显卡 如果看到两个显卡设备，通常一个是集成显卡，一个是独立显卡。我的电脑有两个显卡，一个是英特尔，一个是英伟达。显然N卡是高性能显卡啦。 2. 接下来就是更改相应的显卡设置。 打开显卡的设置界面，可以在桌面右键找到，也可以在控制面板里找到。 显卡设置 找到用于运行游戏的Java，并将其设为高性能或非省电模式。 选中Java 最后不要忘了点右下角确定。 设为高性能 这样显卡设置就完成了。 3. 最后打开游戏检查一下吧。 在游戏内按下F3，在右边可以看到使用的显卡。现在，玩玩游戏，是不是帧率提升了好多，开光影也不卡了呢？ 游戏内检查 以上就是MC更改设置使用独显的所有内容。理论上本设置对所有程序都是通用的。玩其他游戏的朋友也可以试一试哦。","link":"/2017/07/10/gui-config-for-minecraft/"}],"tags":[{"name":"Windows","slug":"windows","link":"/tags/windows/"},{"name":"系统","slug":"os","link":"/tags/os/"},{"name":"Java","slug":"java","link":"/tags/java/"},{"name":"Hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"博客","slug":"blog","link":"/tags/blog/"},{"name":"Linux","slug":"linux","link":"/tags/linux/"},{"name":"IDEA","slug":"idea","link":"/tags/idea/"},{"name":"安全","slug":"security","link":"/tags/security/"},{"name":"虚拟化","slug":"virtualization","link":"/tags/virtualization/"},{"name":"KMS","slug":"kms","link":"/tags/kms/"},{"name":"树莓派","slug":"raspberry-pi","link":"/tags/raspberry-pi/"},{"name":"网络","slug":"network","link":"/tags/network/"},{"name":"算法","slug":"algorithm","link":"/tags/algorithm/"},{"name":"Arch Linux","slug":"archlinux","link":"/tags/archlinux/"},{"name":"Gnome","slug":"gnome","link":"/tags/gnome/"},{"name":"优化","slug":"optimize","link":"/tags/optimize/"},{"name":"Minecraft","slug":"minecraft","link":"/tags/minecraft/"},{"name":"Apache","slug":"apache","link":"/tags/apache/"},{"name":"HTTPS","slug":"https","link":"/tags/https/"},{"name":"SSL","slug":"ssl","link":"/tags/ssl/"},{"name":"DDNS","slug":"ddns","link":"/tags/ddns/"},{"name":"frp","slug":"frp","link":"/tags/frp/"},{"name":"SSH","slug":"ssh","link":"/tags/ssh/"},{"name":"内网穿透","slug":"nat-penetration","link":"/tags/nat-penetration/"},{"name":"反向代理","slug":"reverse-proxy","link":"/tags/reverse-proxy/"},{"name":"远程桌面","slug":"remote-desktop","link":"/tags/remote-desktop/"},{"name":"无线","slug":"wireless","link":"/tags/wireless/"},{"name":"Ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"Wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"Netkeeper","slug":"netkeeper","link":"/tags/netkeeper/"},{"name":"数据库","slug":"database","link":"/tags/database/"},{"name":"SQL","slug":"sql","link":"/tags/sql/"},{"name":"Nvidia","slug":"nvidia","link":"/tags/nvidia/"},{"name":"显卡","slug":"gpu","link":"/tags/gpu/"}],"categories":[{"name":"软件","slug":"software","link":"/categories/software/"},{"name":"日志","slug":"log","link":"/categories/log/"},{"name":"MC","slug":"mc","link":"/categories/mc/"}],"pages":[{"title":"","text":"5cbf351c89b3c6854d6fa9160b8522a1","link":"/baidu_verify_code-qsEGLKKDrM.html"},{"title":"","text":"google-site-verification: google9a60d401bbf7a968.html","link":"/google9a60d401bbf7a968.html"},{"title":"关于","text":"在17年的春天，抢到了腾讯云1元1月的云主机名额，于是便开始了探索之路。 备案是一件麻烦的事情。幸运的是网站备案的拍照点就在市中心，所以我不用申请邮寄幕布，直接去那个照相馆拍照就可以了。在那个狭小的照相馆里面，老板拉出了褪色了的，蓝底白字的幕布。十几天后，网站终于可以挂网页了。 博客将用来记录我的学习和生活，以及各种折腾，努力从小白变成……大白。 仰望无法企及的牛人，在他们所走过的路上前进。路漫漫其修远兮，吾将上下而求索。","link":"/about/index.html"}]}