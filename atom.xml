<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰棒实验室</title>
  
  <subtitle>仰望星空，脚踏实地</subtitle>
  <link href="https://blog.beanbang.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.beanbang.cn/"/>
  <updated>2023-12-09T09:14:36.064Z</updated>
  <id>https://blog.beanbang.cn/</id>
  
  <author>
    <name>Lazyb0x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PVE 安装 OpenWrt 作为旁路由</title>
    <link href="https://blog.beanbang.cn/2023/11/26/pve-install-openwrt-as-secondary-router/"/>
    <id>https://blog.beanbang.cn/2023/11/26/pve-install-openwrt-as-secondary-router/</id>
    <published>2023-11-26T12:33:15.000Z</published>
    <updated>2023-12-09T09:14:36.064Z</updated>
    
    <content type="html"><![CDATA[<p>双11入手了一台 J4125 的小主机作为软路由，在上面安装了虚拟化系统Proxmox VE。这是安装 OpenWrt 的记录。</p><span id="more"></span><h2 id="题外话">题外话</h2><p>为什么选择 All-in-One 这样的方案？知乎上面有很多 AIO 的劝退贴<ahref="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>，主要的观点例如：部署稳定的AIO需要比较高的技术门槛，并且一旦出现故障会影响家庭网路，数据安全很难保证云云，这些对于小白来说确实是不小的问题。然而，作为一个相关领域的从业人员，并且有玩过VPS和虚拟机经验的我来说，装装系统，改改配置文件啥的已经是轻车熟路了（<del>bushi</del>）</p><p>我的主要需求一个是软路由，一个是离线下载和在局域网共享电影，还有就是想试一试<a href="https://www.home-assistant.io/">Home Assistant</a>这个系统，据说可以统一所有的智能家居设备。这些都是需要长期运行的服务，如果用台式机做这些事情也是可以的，但是用电量就比较大了。工控小主机的低功耗就很适合这种场景，J4125CPU 最大功率是 10W，整机待机的功率也很少超过 10瓦，特别省电。至于安全问题，影音娱乐啥的算不上重要数据，路由的话使用旁路网关的方式就可以避免一出问题全屋上不了网的情况了。</p><h2 id="组网">组网</h2><p>在设备 IP地址的配置中通常有一项是“默认网关”，当计算机要发送数据到不在其直接连接的网络上的目标时，就会把数据包发送到默认网关，由默认网关负责将数据包转发到目标网络。我们的设备访问互联网的时候就是先把数据包发给默认网关（路由器），然后数据包会被发送给互联网上的目标。</p><p>“旁路由”的实现方式正是利用了这一点。通常情况下默认网关就是路由器的 IP地址，如果把默认网关配置成其他的设备，让别的设备进行路由和转发，我们就能在不修改原有网络的情况下更好地控制网络流量了。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/network-graph.svg" class="" alt="网络拓扑图"><p>拓扑图如上面所示，路由器的 LAN 口和 PVE 主机的网口连接。在 PVE里面把连路由器的接口、Openwrt 的接口分配到相同的虚拟网桥（LinuxBridge）上面。其他设备还是正常用 Wi-Fi 或者网线连接路由器。</p><h2 id="准备">准备</h2><ol type="1"><li>安装好的 PVE 系统</li><li>OpenWrt 系统镜像。为了扩容方便，选择使用 Ext4 分区的<code>generic-ext4-combined-efi.img.gz</code> 文件。<ahref="https://downloads.openwrt.org/releases/23.05.2/targets/x86/64/">下载页面</a>，在root 首页找最新版本</li><li>GParted Live CD 镜像，用来修改系统分区大小。<ahref="https://gparted.org/download.php">下载页面</a></li></ol><h2 id="创建虚拟机">创建虚拟机</h2><p>Openwrt 需要的资源并不多，可以根据自己需要划分内存和CPU。选择的镜像是 efi 的，所以 BIOS 要选择 UEFI 的，不需要勾选添加 EFI磁盘。在磁盘页面也不需要添加磁盘，稍后会从镜像导入。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/bios-setting-uefi.png" class="" alt="BIOS 选择支持 UEFI 的"><p>由于是旁路由，网络设置使用默认的桥接就好了。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/vm-overview.png" class="" alt="创建完成的虚拟机信息"><p>登录 PVE，下载镜像文件，并解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/vz/template/iso</span><br><span class="line"></span><br><span class="line">wget https://downloads.openwrt.org/releases/23.05.2/targets/x86/64/openwrt-23.05.2-x86-64-generic-ext4-combined-efi.img.gz</span><br><span class="line"></span><br><span class="line">gunzip openwrt-23.05.2-x86-64-generic-ext4-combined-efi.img.gz</span><br></pre></td></tr></table></figure><p>将磁盘镜像文件导入到刚刚创建的虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># qm disk import &lt;vmid&gt; &lt;source&gt; &lt;storage&gt; [OPTIONS]</span></span><br><span class="line">qm disk import 103 openwrt-23.05.2-x86-64-generic-ext4-combined-efi.img local-lvm</span><br></pre></td></tr></table></figure><p>然后回到 PVE 管理网页，选中新的磁盘编辑，添加。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/add-imported-disk.png" class="" alt="编辑使用刚刚导入的磁盘"><p>现在可以开机进入系统了。但是不急，默认磁盘的剩余空间很小，放不了很多东西。为了以后考虑，还要给磁盘扩容。</p><h2 id="磁盘扩容">磁盘扩容</h2><p>磁盘操作 &gt; 调整磁盘大小，扩大虚拟磁盘的大小。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/disk-resize.png" class="" alt="调整虚拟磁盘大小"><p>接下来是调整分区大小。这一步是可以用命令做的，我偷了一点懒，懒得学分区操作的命令，用了图形化分区工具GParted，操作起来比较简单。</p><p>先在 PVE 的 ISO 镜像储存界面上传 GParted 镜像，然后给 OpenWrt的虚拟机的 CD/DVD 添加上。在 选项 &gt; 引导顺序 中调整到光盘最高。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/boot-order.png" class="" alt="修改启动顺序"><p>进入系统之后，操作很方便了。根据提示修复错误，然后右键 rootfs分区调整大小，拖动箭头，把剩余空间拉满就可以了。最后点击打勾保存关机。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/gparted-warning.png" class="" alt="因为扩容，GParted 警告分区表和磁盘空间不符"><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/gparted-resize-disk.png" class="" alt="GParted 调整分区大小界面"><p>移除光盘，调整启动顺序，重新启动，就能够进入系统了。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/openwrt-df.png" class="" alt="df -h"><p>可以看到根分区的大小已经是合适的了。</p><h2 id="网络配置">网络配置</h2><p>用 <code>ip addr</code> 查看 IP地址，发现不对，无法连接。去修改配置文件。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/openwrt-network-not-configured.png" class="" alt="没有正确获取 IP 地址"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure><p>把 <code>lan</code> 的配置改成自己网络的 IP 地址。我这里用 DHCP自动获得 IP 地址，并且加上了 IPv6 的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">config interface &#x27;lan&#x27;</span><br><span class="line">        option device &#x27;br-lan&#x27;</span><br><span class="line">        option proto &#x27;dhcp&#x27;</span><br><span class="line">        #option proto &#x27;static&#x27;</span><br><span class="line">        #option ipaddr &#x27;192.168.1.1&#x27;</span><br><span class="line">        #option netmask &#x27;255.255.255.0&#x27;</span><br><span class="line">        #option ip6assign &#x27;60&#x27;</span><br><span class="line"></span><br><span class="line">config interface &#x27;lan6&#x27;</span><br><span class="line">        option device &#x27;br-lan&#x27;</span><br><span class="line">        option proto &#x27;dhcpv6&#x27;</span><br></pre></td></tr></table></figure><p>修改完成后重启网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/openwrt-network-restart.png" class="" alt="重启网络之后"><p>现在已经正确获取了 IP 地址，可以用 SSH连接或者浏览器访问管理页面了。</p><p>一些基础配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 软件源换成清华镜像源</span></span><br><span class="line">sed -i <span class="string">&#x27;s_downloads.openwrt.org_mirrors.tuna.tsinghua.edu.cn/openwrt_&#x27;</span> /etc/opkg/distfeeds.conf</span><br><span class="line"><span class="comment"># 更新软件包索引</span></span><br><span class="line">opkg update</span><br><span class="line"><span class="comment"># 中文包</span></span><br><span class="line">opkg install luci-i18n-base-zh-cn</span><br><span class="line">opkg install luci-i18n-firewall-zh-cn</span><br><span class="line"><span class="comment"># mDNS 支持，安装后可以用 http://openwrt.local 打开管理页面</span></span><br><span class="line">opkg install avahi-daemon-service-http</span><br></pre></td></tr></table></figure><p>在 OpenWrt 网页管理页面，网络 &gt; 接口 里面，把 DHCP相关的设置关掉，因为旁路由不需要提供 DHCP 服务。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/disable-dhcp.png" class="" alt="关闭 DHCP 相关服务"><h2 id="终端配置">终端配置</h2><p>有两种办法，一种是在设备上手动设置网关为软路由的IP地址，另一种是在主路由上面把DHCP 默认网关设置为软路由的IP。为了稳定，我用手动配置的办法。主路由有两个 WiFi 信号，一个 2.4G的一个 5G 的，把 2.4G 的设置成手动 IP 和软路由的网关，5G的那个保持默认，这样切换起来也还算方便。</p><img src="/2023/11/26/pve-install-openwrt-as-secondary-router/client-ip-config.png" class="" alt="在网络设置里面把网关和 DNS 设置为软路由的 IP 地址"><p>配置完成之后进行简单的 traceroute 验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;tracert -4 blog.beanbang.cn</span><br><span class="line"></span><br><span class="line">通过最多 30 个跃点跟踪</span><br><span class="line">到 pybkxhsa.slt-dk.sched.tdnsv8.com [120.226.2.7] 的路由:</span><br><span class="line"></span><br><span class="line">  1     8 ms     3 ms     3 ms  192.168.31.246</span><br><span class="line">  2    19 ms     4 ms     4 ms  192.168.31.1</span><br><span class="line">  3    10 ms     6 ms     4 ms  192.168.1.1</span><br><span class="line">  4     6 ms     5 ms     5 ms  100.86.64.1</span><br><span class="line">  5     *        *        *     请求超时。</span><br><span class="line">  6     *        *        *     请求超时。</span><br><span class="line">  7    36 ms     *        *     221.183.44.38</span><br><span class="line">  8    33 ms    36 ms    33 ms  221.183.91.202</span><br><span class="line">  9    55 ms     *        *     183.214.150.214</span><br><span class="line"> 10     *       33 ms     *     36.158.200.206</span><br><span class="line"> 11     *        *        *     请求超时。</span><br><span class="line"> 12     *        *        *     请求超时。</span><br><span class="line"> 13    42 ms   134 ms    35 ms  120.226.2.7</span><br><span class="line"></span><br><span class="line">跟踪完成。</span><br></pre></td></tr></table></figure><p>可以看到第一跳、第二跳、第三跳分别是软路由、我的硬路由和光猫，然后是联通的网络，最后到达目标地址。</p><blockquote><p>参见：</p><ul><li><p><ahref="https://easonyang.com/posts/transparent-proxy-in-router-gateway/">旁路由的原理与配置一文通- Eason Yang's Blog</a></p></li><li><p><a href="https://sspai.com/post/68511">Openwrt作为旁路网关（不是旁路由、单臂路由）的终极设置方法，破解迷思 - 少数派(sspai.com)</a></p></li><li><p><ahref="https://blog.csdn.net/u012374381/article/details/130650909">超详细,多图PVE 安装 OpenWRT教程(个人记录)_pve安装openwrt_优雅码农的博客-CSDN博客</a></p></li></ul></blockquote><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://www.zhihu.com/question/496124999">什么样的 NAS 方案（AllIn One）比较好？ - 知乎</a><a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">&lt;p&gt;双11入手了一台 J4125 的小主机作为软路由，在上面安装了虚拟化系统
Proxmox VE。这是安装 OpenWrt 的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="Linux" scheme="https://blog.beanbang.cn/tags/linux/"/>
    
    <category term="系统" scheme="https://blog.beanbang.cn/tags/os/"/>
    
    <category term="虚拟化" scheme="https://blog.beanbang.cn/tags/virtualization/"/>
    
    <category term="网络" scheme="https://blog.beanbang.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>备份和迁移 Linux 系统</title>
    <link href="https://blog.beanbang.cn/2023/01/01/backup-and-migrate-linux/"/>
    <id>https://blog.beanbang.cn/2023/01/01/backup-and-migrate-linux/</id>
    <published>2023-01-01T14:43:00.000Z</published>
    <updated>2023-05-23T16:01:20.809Z</updated>
    
    <content type="html"><![CDATA[<p>最近折腾了一下，把装在移动硬盘的 Manjaro复制到笔记本的硬盘里面了。如果你需要备份自己的的 Linux系统，然后到另一台电脑上安装的话，这篇文章可能会帮到你。</p><p>如果你只是想创建一个系统快照，方便将来搞砸的时候还原回来，可以不用这么麻烦，用<a href="https://aur.archlinux.org/packages/timeshift">Timeshift</a>就可以了。</p><span id="more"></span><h2 id="准备工作-配置要求">准备工作 / 配置要求</h2><ol type="1"><li>一个安装好的，可以启动的 Linux 系统，使用启动引导是 GRUB 2</li><li>硬盘分区格式是 GPT，BIOS 引导模式是 UEFI</li><li>待备份的系统分区有超过一半的未使用空间（得放得下备份文件）</li><li>目标电脑的硬盘上分好分区，准备存放迁移过来的系统</li><li>一个 Linux Live CD 启动盘U盘，最好就是安装 Linux 时用的那个镜像</li></ol><p>准备完成后就可以开始了！</p><p><img src="Konqi.svg" width="150" alt="Konqi 也准备好了！（" title="Konqi 也准备好了！（"/></p><h2 id="备份系统">备份系统</h2><p>Wiki 上面提供了很多方式<a href="#fn1" class="footnote-ref"id="fnref1"role="doc-noteref"><sup>1</sup></a>，我从中选了最简单的一种，就是打包成tar 压缩包<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>。</p><p>从 Live CD 启动后，查询和挂载你的 Linux 分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">fdisk -l              <span class="comment"># 查看分区信息</span></span><br><span class="line">mount /dev/sda2 /mnt  <span class="comment"># 假设 sda2 是你的 linux 分区，把它挂载上</span></span><br></pre></td></tr></table></figure><p>要使用的其他分区（如果有的话）需要装载到适当的位置（例如，如果有单独的<code>/home</code> 分区，就把它挂载到 <code>/mnt/home</code>）。</p><p>然后，使用 <ahref="https://wiki.archlinuxcn.org/wiki/Chroot"><code>chroot</code></a>把环境切换到分区，准备备份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt</span><br></pre></td></tr></table></figure><p>执行 tar 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p、--acls 和 --xattrs 存储所有权限、ACL 和扩展属性。如果没有这些属性，许多程序会停止工作！</span></span><br><span class="line"><span class="comment"># 可以安全地移除详细信息标志（-v）。如果使用的终端速度较慢，这可以加快备份过程。</span></span><br><span class="line">tar --exclude=<span class="string">&#x27;/tmp&#x27;</span> --exclude=<span class="string">&#x27;/opt/backup&#x27;</span> --acls --xattrs -cpvf /opt/backup/$(<span class="built_in">date</span> <span class="string">&quot;+%F&quot;</span>).tar.gz /</span><br></pre></td></tr></table></figure><p>执行之后，会开始备份系统到 <code>/opt/backup</code>目录下。<code>--exclude</code>可以指定想要排除的文件和目录。等到备份结束，把压缩包拷贝出来，放到新电脑的磁盘里面。</p><h2 id="恢复系统">恢复系统</h2><p>在新电脑用 Live CD 启动后，挂载并 <code>cd</code>到想要还原的分区，解压文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --acls --xattrs -xpf backupfile</span><br></pre></td></tr></table></figure><h3 id="修改-fstab-文件">修改 fstab 文件</h3><p>接下来需要修改 fstab 文件。fstab文件是系统开机时需要挂载的分区信息，我们只需要稍加修改，把 UUID改成新分区的 UUID 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>我的 fstab 是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># /etc/fstab: static file system information.</span><br><span class="line">#</span><br><span class="line"># Use &#x27;blkid&#x27; to print the universally unique identifier for a device; this may</span><br><span class="line"># be used with UUID= as a more robust way to name devices that works even if</span><br><span class="line"># disks are added and removed. See fstab(5).</span><br><span class="line">#</span><br><span class="line"># &lt;file system&gt;             &lt;mount point&gt;  &lt;type&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line">UUID=86A4-0D24                            /boot/efi      vfat    umask=0077 0 2</span><br><span class="line">UUID=55ac4657-1043-4cb2-a727-3936a83c8d87 /              ext4    defaults,noatime 0 1</span><br></pre></td></tr></table></figure><p>这些命令都可以查询磁盘的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">blkid</span><br><span class="line">lsblk -o NAME,RM,SIZE,RO,FSTYPE,UUID,MOUNTPOINTS</span><br></pre></td></tr></table></figure><p>这一步的 fstab 文件也可以通过挂载好所有目录之后使用<code>genfstab -U &lt;挂载根目录&gt;</code>来生成。</p><h3 id="重建-initramfs">重建 initramfs</h3><p>initramfs包含了能够让系统访问根文件系统的模块。如果迁移的设备有变化，就需要重新生成。</p><p>需要准备 chroot 环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /mnt</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br></pre></td></tr></table></figure><p>挂载临时文件系统目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line">mount -t proc /proc proc/</span><br><span class="line">mount --rbind /sys sys/</span><br><span class="line">mount --rbind /dev dev/</span><br><span class="line"><span class="built_in">chroot</span> /mnt /bin/bash</span><br></pre></td></tr></table></figure><p>如果你用的是 Arch，可以不需要挂载上面的临时文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>重建 initramfs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitcpio -p linux</span><br></pre></td></tr></table></figure><h3 id="安装启动引导">安装启动引导</h3><p>目前新系统还是没有启动引导的，需要手动安装引导。</p><p>在之前 chroot 环境，执行命令安装 grub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB --recheck</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>没有报错的话，就是成功了，可以重启系统。</p><p>进入系统之后，再执行一次 <code>update-grub</code> 或者<code>grub-mkconfig -o /boot/grub/grub.cfg</code>。如果启用了os-probe<ahref="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a>，会扫描磁盘上的其他系统，比如Windows，会被添加到启动菜单中。</p><h3 id="附手动引导">附：手动引导</h3><p>如果由于一些原因，比如你的 Live CD 里面没有 <code>grub-install</code>命令，或者不想安装启动引导到磁盘里面，只是临时启动一下系统，那么可以利用GRUB 的命令行手动引导启动系统<a href="#fn4" class="footnote-ref"id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p><p>要进入到 GRUB 命令行，可以在开机进入 Live CD 的 GRUB启动菜单页面的时候按 <kbd>C</kbd>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; ls -l</span><br><span class="line">grub&gt; set root=(hd0,msdos1)</span><br><span class="line">grub&gt; linux /boot/vmlinuz-6.1-x86_64 root=UUID=55ac4657-1043-4cb2-a727-3936a83c8d86</span><br><span class="line">grub&gt; initrd /boot/initramfs-6.1-x86_64.img</span><br><span class="line">grub&gt; boot</span><br></pre></td></tr></table></figure><p><code>ls -l</code> 是可以查看分区信息和对应的UUID，<code>linux</code> 命令找 /boot 下 vmlinuz开头的文件，<code>initrd</code> 命令找 initrd开头的文件。命令和文件都可以按 <kbd>Tab</kbd> 自动补全，但是那个 UUID参数得手打，有点累。</p><img src="/2023/01/01/backup-and-migrate-linux/grub-command-line.png" class="" alt="GRUB 2 的命令行模式界面"><p>进入系统后，也可以再把启动引导装回来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bootloader-id 会成为 BIOS 启动项的文本</span></span><br><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=manjaro --recheck --verbose</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><blockquote><p>参见</p><ul><li><a href="https://www.suse.com/support/kb/doc/?id=000016528">How toreinstall the GRUB boot loader | Support | SUSE</a></li><li><ahref="https://forum.manjaro.org/t/grub-probe-error-cannot-find-a-grub-drive-for-dev-sda1/13445/3">Grub-probe:error: cannot find a GRUB drive for /dev/sda1 - Support - Manjaro LinuxForum</a></li><li><ahref="https://wiki.archlinuxcn.org/wiki/迁移到新硬件#自上而下">迁移到新硬件- Arch Linux 中文维基</a></li></ul></blockquote><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><a href="https://wiki.archlinuxcn.org/wiki/系统备份"class="uri">https://wiki.archlinuxcn.org/wiki/系统备份</a><ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><ahref="https://wiki.archlinuxcn.org/wiki/使用_tar_备份整个系统"class="uri">https://wiki.archlinuxcn.org/wiki/使用_tar_备份整个系统</a><ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><ahref="https://wiki.archlinuxcn.org/wiki/GRUB#探测其他操作系统"class="uri">https://wiki.archlinuxcn.org/wiki/GRUB#探测其他操作系统</a><ahref="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><ahref="https://www.linuxfoundation.org/blog/blog/classic-sysadmin-how-to-rescue-a-non-booting-grub-2-on-linux"class="uri">https://www.linuxfoundation.org/blog/blog/classic-sysadmin-how-to-rescue-a-non-booting-grub-2-on-linux</a><ahref="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近折腾了一下，把装在移动硬盘的 Manjaro
复制到笔记本的硬盘里面了。如果你需要备份自己的的 Linux
系统，然后到另一台电脑上安装的话，这篇文章可能会帮到你。&lt;/p&gt;
&lt;p&gt;如果你只是想创建一个系统快照，方便将来搞砸的时候还原回来，可以不用这么麻烦，用
&lt;a href=&quot;https://aur.archlinux.org/packages/timeshift&quot;&gt;Timeshift&lt;/a&gt;
就可以了。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Linux" scheme="https://blog.beanbang.cn/tags/linux/"/>
    
    <category term="系统" scheme="https://blog.beanbang.cn/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>获取 Mybatis-Plus Wrapper 生成的SQL语句</title>
    <link href="https://blog.beanbang.cn/2022/01/26/get-sql-statement-from-mybatis-plus/"/>
    <id>https://blog.beanbang.cn/2022/01/26/get-sql-statement-from-mybatis-plus/</id>
    <published>2022-01-26T11:37:00.000Z</published>
    <updated>2022-09-14T11:31:40.973Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个需求：不执行数据库查询，而是把查询的逻辑，也就是 SQL语句，传递给另一个微服务，让它去查。于是就想到，如果可以用 Mybatis-Plus拼好的 Wrapper 构造器来生成 SQL，就可以不用在代码里面拼 SQL 语句了。</p><span id="more"></span><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSelectListSQL</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// wrapper 拼查询条件</span></span><br><span class="line">    QueryWrapper&lt;TaskUser&gt; ew = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    ew.lambda()</span><br><span class="line">            .select(TaskUser::getTaskId)</span><br><span class="line">            .eq(TaskUser::getUserId, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">            .like(TaskUser::getNodeName, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">            .and(w -&gt; w.likeLeft(TaskUser::getOrgCode, <span class="string">&quot;546&quot;</span>))</span><br><span class="line">            .orderByAsc(TaskUser::getCreateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrapper 会作为参数传入 mapper</span></span><br><span class="line">    Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="string">&quot;ew&quot;</span>, ew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sqlSessionFactory 从 Spring 容器中获得</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> sqlSessionFactory.getConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类引用+方法名得到 mapper 语句</span></span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> configuration.getMappedStatement(<span class="string">&quot;cn.beanbang.spi.mapper.TaskUserMapper.selectList&quot;</span>);</span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> mappedStatement.getBoundSql(params);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> getExecuteSql(boundSql, params);</span><br><span class="line">    System.out.println(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getExecuteSql</span><span class="params">(BoundSql boundSql, Object paramObject)</span> &#123;</span><br><span class="line">    <span class="comment">// 带有问号占位符的 SQL 语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line">    <span class="comment">// 参数信息列表</span></span><br><span class="line">    List&lt;ParameterMapping&gt; paramMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="comment">// MetaObject 是 mybatis 通过表达式取出对象内容的工具</span></span><br><span class="line">    <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> sqlSessionFactory.getConfiguration().newMetaObject(paramObject);</span><br><span class="line">    <span class="keyword">for</span> (ParameterMapping p : paramMappings) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">paramName</span> <span class="operator">=</span> p.getProperty();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">paramValue</span> <span class="operator">=</span> metaObject.getValue(paramName);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (paramValue <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            value = <span class="string">&quot;&#x27;&quot;</span> + paramValue + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// todo 其他类型的参数的对应的拼接方式</span></span><br><span class="line">        &#125;</span><br><span class="line">        sql = sql.replaceFirst(<span class="string">&quot;\\?&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">task_id</span><br><span class="line">  <span class="keyword">FROM</span> TASK_USER</span><br><span class="line"> <span class="keyword">WHERE</span>  IS_DELETED<span class="operator">=</span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span> (user_id <span class="operator">=</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">AND</span> node_name <span class="keyword">LIKE</span> <span class="string">&#x27;%123456%&#x27;</span> <span class="keyword">AND</span> (org_code <span class="keyword">LIKE</span> <span class="string">&#x27;%546&#x27;</span>)) <span class="keyword">ORDER</span> <span class="keyword">BY</span> CREATE_TIME <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><p>下面是摸索出结论的过程（<del>心路历程</del>：</p><h2 id="jdbc">JDBC</h2><p>所有的 ORM 框架，最后都是要通过 JDBC 去和数据库交互的。类似这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;</span>)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">&quot;M&quot;</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> rs.getLong(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">grade</span> <span class="operator">=</span> rs.getLong(<span class="string">&quot;grade&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 来自 https://www.liaoxuefeng.com/wiki/1252599548343744/1321748435828770</span></span><br></pre></td></tr></table></figure><p>为了避免注入问题，基本上所有的语句执行都会使用<code>PreparedStatement</code>。而 prepared statement的执行过程是这样的：</p><ol type="1"><li>带占位符的语句被发送到数据库服务器，先被解析成某种数据结构并储存在内存中；</li><li>绑定的参数被发送到服务器；</li><li>整个语句被执行。</li></ol><p>所以事实上整个查询的过程中都不会有“最终的”SQL 语句生成，没有办法从JDBC 的执行过程得到 SQL 语句。</p><p>不过，一些数据库驱动的实现是可以得到语句的。比如 MySQL 的<code>PreparedStatement</code> 的 <code>toString()</code>方法可以输出拼接参数的完整语句。但是并不是所有数据库厂商都有去实现的，而我们这个项目也是需要支持多种类型的数据库，所以这样也不是很通用。</p><p>所以，我们只能手动拼接语句和参数来得到完整的 SQL语句了。接下来就是要知道 Mybatis 是怎么调用 JDBC 的了。</p><h2 id="mybatis">MyBatis</h2><p>MyBatis 的原理是，在 XML 文件中用模板语言编写 SQL语句，然后在代码里面编写一个和 XML的参数和返回值相匹配的接口（Mapper）。调用接口，并传递相应的参数，MyBatis就会把参数和模板语句结合起来，生成最终需要执行的参数和语句，然后调用PreparedStatement 执行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis 的核心是 <code>SqlSessionFactory</code>类。执行查询，或者获取配置信息都是从这里开始的。程序启动后，Mapper文件到了代码里面就加载成了一个个的 <code>MappedStatement</code>对象，一个 MappedStatement 实例对应着一个 Mapper文件里的一个查询语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> sqlSessionFactory.getConfiguration();</span><br><span class="line"><span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> configuration.getMappedStatement(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/2022/01/26/get-sql-statement-from-mybatis-plus/image-20211219222232863.png" class="" alt="可以从 SqlSessionFactory 中获得 MappedStament 的列表"><p>那 MappedStatement 是怎么和我们传入的参数组合，最后生成PreparedStatement的呢？经过一段时间顺藤摸瓜地查找，终于找到了处理逻辑所在的地方：<code>DefaultParameterHandler#setParameters</code>。</p><img src="/2022/01/26/get-sql-statement-from-mybatis-plus/image-20211219225136988.png" class="" alt="MyBatis 对语句传入参数的地方"><p><code>boundSql</code>：SQL语句和参数信息。储存了用问号占位符标记的生成的 SQL语句，以及每一个参数的类型信息和参数符号表达式（就是用 <code>#&#123;&#125;</code>包起来的部分）；</p><p><code>parameterObject</code>：传入的参数；</p><p><code>MetaObject</code>：这个工具可以读取参数对象，然后根据表达式从参数对象取出对应的值。</p><p>有了 BoundSql 和 MetaObject 我们就可以手动把问号 SQL 拼成完整 SQL了。</p><p>最后一个问题：Mybatis-Plus Wrapper 的原理是什么？它是怎么调用 Mybatis的？</p><h2 id="mybatis-plus">MyBatis-Plus</h2><p>Mybatis-Plus 全面接管了 Mybatis。结合 Spring框架，从头到尾都不需要手动加载配置，创建连接了。并且内置了很多方便的增删改查接口，以及条件构造器，可以很方便地进行条件查询。</p><img src="/2022/01/26/get-sql-statement-from-mybatis-plus/image-20211219233724643.png" class="" alt="QueryWrapper 里的内容"><p>通过对生成的 QueryWrapper 断点调试我们可以发现，wrapper自己本身就是传递给 mapper 的参数。Wrapper 负责的是生成 where部分的语句和参数。wrapper 得到的 SQL 语句里面的参数是<code>#&#123;ew.paramNameValuePairs.MPGENVALx&#125;</code>的形式，很明显引用了自己（ew 即 EntityWrapper，是 MP 旧版本的 Wrapper类名）。</p><img src="/2022/01/26/get-sql-statement-from-mybatis-plus/image-20211219232000301.png" class="" alt="MPP selectList 查询方法的注入"><p>在项目启动的时候，MP 会找到 selectList 方法的实现类<code>SelectList</code>，然后把所有的 SQL 片段拼接起来，动态生成一个<code>MappedStatement</code>，然后放入 mybatis 的 sqlSessionFactory里面。</p><p>假如我们调用了<code>service.selectList(wrapper)</code>，其实也相当于执行了一次 Mybatis查询，只不过 Mapper 语句是 MP 帮你生成的（BaseMapper方法注入），传入的参数也是 MP 帮你生成的（在 wrapper 里面）。</p><p>这样，完整的链条就串起来了：</p><ol type="1"><li>SqlSessionFactory + Mapper id =&gt; MappedStatement（SQL 模板）</li><li>拼接查询条件 Wrapper（参数）</li><li>Wrapper + MappedStatement =&gt; BoundSql（占位符 SQL +参数信息）</li><li>BoundSql + Wrapper =&gt; 完整 SQL</li></ol><blockquote><p>参见</p><ul><li><a href="https://juejin.cn/post/6996218774286237704">MyBatis原理系列(六)-手把手带你了解 BoundSql 的创建过程 - 掘金(juejin.cn)</a></li><li><a href="https://www.cnblogs.com/huyande/p/12423544.html">Java 获取Mybatis 动态生成的 sql - yinder - 博客园 (cnblogs.com)</a></li><li><ahref="https://stackoverflow.com/questions/33197085/mybatis-3-get-sql-string-from-mapper">java- MyBatis 3 - get SQL string from mapper - Stack Overflow</a></li><li><a href="https://www.codenong.com/cs106993191/">MyBatis-Plus简介和原理解析 | 码农家园 (codenong.com)</a></li><li><a href="https://juejin.cn/post/7002423698565103653">MyBatis-Plus 的BaseMapper 实现原理 - 掘金 (juejin.cn)</a></li><li><a href="https://zhuanlan.zhihu.com/p/393204656">面试官：Mybatis如何将数据库类型转换成 Java 类型？如何创建 SQL 返回的对象？如何起别名？- 知乎 (zhihu.com)</a></li><li><ahref="https://stackoverflow.com/questions/2382532/how-can-i-get-the-sql-of-a-preparedstatement">java- How can I get the SQL of a PreparedStatement? - StackOverflow</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个需求：不执行数据库查询，而是把查询的逻辑，也就是 SQL
语句，传递给另一个微服务，让它去查。于是就想到，如果可以用 Mybatis-Plus
拼好的 Wrapper 构造器来生成 SQL，就可以不用在代码里面拼 SQL 语句了。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Java" scheme="https://blog.beanbang.cn/tags/java/"/>
    
    <category term="数据库" scheme="https://blog.beanbang.cn/tags/database/"/>
    
    <category term="SQL" scheme="https://blog.beanbang.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下的软件安利</title>
    <link href="https://blog.beanbang.cn/2021/10/25/awesome-linux-software/"/>
    <id>https://blog.beanbang.cn/2021/10/25/awesome-linux-software/</id>
    <published>2021-10-25T11:11:23.000Z</published>
    <updated>2022-10-26T23:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>把 Manjaro Gnome 当作生产环境，用了大概一个月的时间后…</p><span id="more"></span><p>就体验来看呢，如果日常用的软件在 Linux上都有相同版本或者替代的话，感觉还是不错的。就是驱动和字体渲染比不上Windows。</p><img src="/2021/10/25/awesome-linux-software/manjaro-meme.png" class=""><p>下面是一些好用的软件推荐。虽然很多链接标的是 Arch Linux软件包的地址，但是对其他的发行版也基本都是支持的。很多软件都提供了 <ahref="https://snapcraft.io/">Snap</a> 或者 <ahref="https://flatpak.org/">FlatPak</a> 或者 <ahref="https://appimage.org/">AppImage</a>这些通用的打包方式，在不同的发行版都是可以运行的。</p><h2 id="效率工具">效率工具</h2><ul><li><p>文本：<ahref="https://aur.archlinux.org/packages/typora/">Typora</a></p><p>最好用的 Markdown 编辑器。</p></li><li><p>SSH 客户端：<ahref="https://aur.archlinux.org/packages/termius/">Termius</a></p><p>终端连接工具，颜值很高。支持所有平台，包括 Windows 和Android。免费的版本提供 SSH客户端和端口映射工具，付费的还提供帐号间连接的同步等等功能。</p></li><li><p>记事本：<a href="https://simplenote.com/">Simplenote</a> （<ahref="https://aur.archlinux.org/packages/simplenote-electron-bin/">AUR</a>）</p><p>Simplenote是一个功能简单的记事本软件，只能记录纯文本内容。它的优点在于全平台支持，并且实时同步。一个设备上输入的文字马上可以在另一个设备看到（甚至可以当作跨设备的剪切板用）。我把它当作备忘录来用。这个软件和Wordpress 是一个公司，所以稳定性也是有所保证的。</p></li><li><p>截图工具</p><p>推荐两个截图工具，分别是深度截图（<ahref="https://archlinux.org/packages/community/x86_64/deepin-screenshot/">deepin-screenshot</a>）和火焰截图（<ahref="https://archlinux.org/packages/community/x86_64/flameshot/">flameshot</a>）。它们都能做到像QQ 截图那样方便地截图。</p></li><li><p>文档处理</p><p>这个肯定是 <ahref="https://aur.archlinux.org/packages/wps-office-mui-zh-cn/">WPSOffice</a> 了，国产良心。除此之外 <ahref="https://aur.archlinux.org/packages/onlyoffice-bin/">OnlyOffice</a> 和 Libre Office 也值得一试。</p></li><li><p>即时通讯</p><p>微信：用 <ahref="https://aur.archlinux.org/packages/deepin-wine-wechat/">deepin-wine-wechat</a>，或者用wine-for-wechat 和 <ahref="https://aur.archlinux.org/packages/com.qq.weixin.spark">com.qq.weixin.spark</a>。</p><p>QQ：官方 Electron 版本上线了，用 <ahref="https://aur.archlinux.org/pkgbase/linuxqq">linuxqq</a>！<del>或者用<ahref="https://aur.archlinux.org/pkgbase/icalingua++">icalingua++</a>，第三方的QQ 客户端，或者 <ahref="https://aur.archlinux.org/packages/deepin-wine-qq/">deepin-wine-qq</a>，或者<ahref="https://aur.archlinux.org/packages/deepin-wine-tim/">deepin-wine-tim</a></del>。</p></li><li><p>剪切板管理：<ahref="https://archlinux.org/packages/community/x86_64/copyq/">CopyQ</a></p><p>不错的剪切板管理工具，记录剪切板的历史，文本和图片都支持，可以自定义快捷键激活。</p></li><li><p>远程桌面：<ahref="https://archlinux.org/packages/community/x86_64/remmina/">Remmina</a></p><p>支持 RDP、VNC、SFTP 等协议，功能强大。</p></li><li><p>文件查找：<ahref="https://archlinux.org/packages/community/any/catfish/">catfish</a></p><p>全局的文件搜索。类似 Windows 下的软件 Everything。配合 <ahref="https://archlinux.org/packages/core/x86_64/mlocate/">mlocate</a>缓存食用，可以加快查找速度。</p></li></ul><h2 id="系统工具">系统工具</h2><ul><li><p>分区管理：<ahref="https://archlinux.org/packages/extra/x86_64/gparted/">GParted</a></p><p>和 Windows 下的 DiskGenius 类似的分区编辑工具。</p></li><li><p>输入法：<a href="https://rime.im/">RIME</a></p><p>全平台的开源的可定制化程度很高的输入法引擎。IBus 和 Fcitx都支持。</p></li><li><p>网络代理：<a href="https://v2raya.org/">V2rayA</a></p><p>为 Linux 设计的 V2ray 客户端，用网页的形式来管理连接。用 <ahref="https://v2raya.org/docs/prologue/installation/docker/">Docker部署</a>很方便。最大的特点就是提供了一键开启透明代理，不需要手动去配置iptables 了。</p></li><li><p>容器：<ahref="https://archlinux.org/packages/community/x86_64/docker/">Docker</a></p><p>各种服务类的工具，比如数据库，中间件，Web服务端等等，都可以用 Docker来部署，省时省力。以前安装 MySQL，Oracle数据库需要配置很多东西，现在一行命令就可以启动起来了。甚至图形化应用也可以用Docker 来跑，比如 <ahref="https://github.com/RokasUrbelis/docker-wine-linux">docker-wine-linux</a>。</p></li><li><p><ahref="https://archlinux.org/packages/extra/any/gnome-tweaks/">GnomeTweaks</a>：可以改 Gnome桌面系统设置里没有的项目，比如字体和主题。</p></li><li><p><ahref="https://aur.archlinux.org/packages/timeshift">Timeshift</a>：可以创建文件系统增量快照，和Windows 还原点类似，再也不怕更新滚挂了。</p></li></ul><h2 id="多设备协同">多设备协同</h2><ul><li><a href="https://kdeconnect.kde.org/">KDEConnect</a>：功能强大的协同软件。Gnome 桌面可以用 <ahref="https://extensions.gnome.org/extension/1319/gsconnect/">GSConnect</a>。它可以做到电脑和手机文件共享、剪切板共享、把手机屏幕当作触摸板和键盘、同步显示手机的通知、多媒体控制、查找手机等等非常实用的功能。只需要电脑和手机都安装了软件，并且处在同一个局域网中就可以。</li><li><ahref="https://github.com/Genymobile/scrcpy">scrcpy</a>：一款安卓手机投屏到电脑的软件。使用adb协议，可以用鼠标和键盘操作手机，向手机发送文件等。需要用数据线连接手机和电脑。adb协议也支持远程连接，所以稍微配置一下也可以无线使用。</li><li><a href="https://github.com/Unrud/remote-touchpad">RemoteTouchpad</a>：手机控制电脑的软件。通过网页的形式提供触摸屏和键盘数据的功能。手机浏览器扫描电脑上的二维码就可以操作。比KDE Connect 简单，好处是不用安装额外软件。</li><li><ahref="https://termux.com/">Termux</a>：这是一个安卓软件，命令行工具。提供完整的Linux 环境。有了它，手机直接变成一台 Linux 服务器 / 终端。电脑可以通过ssh 连接手机，然后就能为所欲为了。</li></ul><h2 id="多媒体">多媒体</h2><ul><li><a href="https://music.163.com/#/download">网易云音乐</a>：官方支持Linux。提供deb格式的安装包。Arch 用户可以从 AUR 软件源安装（<ahref="https://aur.archlinux.org/packages/netease-cloud-music/">netease-cloud-music</a>）。</li><li><ahref="http://cidian.youdao.com/index-linux.html">有道词典</a>：Deepin 和有道一起推出的 Linux 版本。AUR：<ahref="https://aur.archlinux.org/packages/youdao-dict/">youdao-dict</a>。可惜没有账户功能，不能同步生词本。</li><li><ahref="https://aur.archlinux.org/packages/yesplaymusic/">YesPlayMusic</a>：第三方的网易云客户端，颜值很高。去掉了网易云的社交功能。并且集成了另一个工具：<ahref="https://github.com/nondanee/UnblockNeteaseMusic">UnblockNeteaseMusic</a>，能自动从别的音乐平台获取变灰的歌曲。</li><li><ahref="https://archlinux.org/packages/extra/x86_64/vlc/">VLC</a>：全能的视频播放器。</li><li><ahref="https://archlinux.org/packages/extra/x86_64/gimp/">GIMP</a>：开源的画图工具，位图图像编辑。如果是编辑矢量图用<ahref="https://archlinux.org/packages/extra/x86_64/inkscape/">Inkscape</a>。</li></ul><h2 id="gnome-桌面插件">Gnome 桌面插件</h2><ul><li><ahref="https://extensions.gnome.org/extension/2015/no-title-bar-forked/">NoTitle Bar -Forked</a>：一个可以把窗口的标题栏和状态栏合并的插件。窗口最大化的时候不显示标题栏，扩大了屏幕的显示区域。</li><li><ahref="https://extensions.gnome.org/extension/543/backslide/">BackSlide</a>：随时间变化的壁纸，可以选择一个文件夹的壁纸作为幻灯片展示。和Windows 的变化壁纸功能一样。</li><li><ahref="https://extensions.gnome.org/extension/675/lunar-calendar/">LunarCalendar</a>：在日历栏显示农历和节假日。</li><li><ahref="https://extensions.gnome.org/extension/307/dash-to-dock/">Dash toDock</a>：应用栏可以移动到屏幕的其他位置。</li><li><ahref="https://extensions.gnome.org/extension/615/appindicator-support/">AppIndicatorand KStatusNotifierItemSupport</a>：会把旧版的状态图标放置到顶部的状态栏。比如 Wine程序的状态图标，没开启这个插件图标就会显示在状态栏对面。</li><li><ahref="https://extensions.gnome.org/extension/3814/system-action-hibernate/">SystemAction - Hibernate</a>：<ahref="https://www.vegard.net/manjaro-enable-hibernate/">开启了挂起功能</a>之后，用这个插件会在关机的菜单多一项“休眠”按钮。</li></ul><h2 id="联想专用">联想专用</h2><p><ahref="https://aur.archlinux.org/packages/battmngr/">battmngr</a>：这个命令行工具能改变联想电脑的电源管理设置，也就是在Windows 上的快捷键 <kbd>Fn + Q</kbd> 一键性能切换功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把 Manjaro Gnome 当作生产环境，用了大概一个月的时间后…&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="Linux" scheme="https://blog.beanbang.cn/tags/linux/"/>
    
    <category term="Arch Linux" scheme="https://blog.beanbang.cn/tags/archlinux/"/>
    
    <category term="Gnome" scheme="https://blog.beanbang.cn/tags/gnome/"/>
    
    <category term="优化" scheme="https://blog.beanbang.cn/tags/optimize/"/>
    
  </entry>
  
  <entry>
    <title>Maven 笔记</title>
    <link href="https://blog.beanbang.cn/2021/07/16/maven-note/"/>
    <id>https://blog.beanbang.cn/2021/07/16/maven-note/</id>
    <published>2021-07-16T04:47:55.000Z</published>
    <updated>2022-09-10T10:44:47.630Z</updated>
    
    <content type="html"><![CDATA[<p>平平无奇的 Java 的包管理工具。</p><span id="more"></span><p>这是<ahref="https://book.douban.com/subject/5345682/">《Maven实战》</a>的读书笔记。</p><p>电子书：<a href="https://4lib.org/s/B009WMAZX4"class="uri">https://4lib.org/s/B009WMAZX4</a></p><p>书本实例代码：<a href="https://github.com/juven/mvn_in_action_code"class="uri">https://github.com/juven/mvn_in_action_code</a></p><h2 id="概念">概念</h2><p>构件：在 Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。</p><p>坐标：每一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径。</p><p>依赖：一个 Maven 项目使用另一个 Maven项目的构件，作为依赖。使用坐标来定位。</p><p>仓库：在某个位置储存所有 Maven 项目共享的组件。当需要的时候，Maven会根据坐标找到仓库中的构件，使用它们。</p><h2 id="命令">命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br><span class="line">mvn dependency:list</span><br><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure><h2 id="坐标和依赖">坐标和依赖</h2><h3 id="依赖范围">依赖范围</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Maven 在编译，测试，和运行的时候各使用一种classpath。依赖范围就是在某个阶段是否需要这个包。</p><p><strong>compile</strong>：编译依赖范围。默认依赖范围。对编译，测试，运行都会使用到。例如spring-core。</p><p><strong>test</strong>：测试依赖范围。只对于测试 classpath 有效。例如JUnit。</p><p><strong>provided</strong>：已提供依赖范围。对于编译和测试有效，在运行时无效。例如servlet-api，编译和测试时需要用到该依赖，但是运行的时候容器已经提供，就不需要重复引入，再把依赖打进jar 包。</p><p><strong>runtime</strong>：运行时依赖范围。对测试和运行有效，但在编译时不需要。例如JDBC 的驱动实现，在代码里面我们没有直接引用 MySQL 或者 Oracle 的JDBC驱动，而是用 JDBC接口去调用。所以编译的时候不需要，实际运行的时候才要。</p><p><strong>system</strong>：系统依赖范围。范围和 provided范围一致，但是需要使用 systemPath指定依赖文件的路径，用来导入本级系统中的包，没有可移植性。</p><p><strong>import</strong>：用于依赖管理，只在 dependencyManagement标签中使用。作用是把另一个 POM 的 dependencyManagement 配置导入到当前POM 的 dependencyManagement 里面。</p><table><caption>依赖范围</caption><thead><tr class="header"><th style="text-align: center;">Scope</th><th style="text-align: center;">编译</th><th style="text-align: center;">测试</th><th style="text-align: center;">运行</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">compile</td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td></tr><tr class="even"><td style="text-align: center;">test</td><td style="text-align: center;"></td><td style="text-align: center;">✔</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">provided</td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">runtime</td><td style="text-align: center;"></td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td></tr><tr class="odd"><td style="text-align: center;">system</td><td style="text-align: center;">✔</td><td style="text-align: center;">✔</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="依赖传递">依赖传递</h3><p>左边一列是第一直接依赖(A)，上面一行表示第二直接依赖(B)，单元格表示传递性依赖范围(C)。</p><p>A 依赖 B，B 依赖 C，那么 A 对 C 是什么依赖范围。</p><p>可选依赖不会被传递。即添加了标签为<code>&lt;optional&gt;true&lt;/optional&gt;</code> 的。</p><table><caption>依赖范围影响传递性依赖</caption><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">compile</th><th style="text-align: center;">test</th><th style="text-align: center;">provided</th><th style="text-align: center;">runtime</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">compile</td><td style="text-align: center;">compile</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">runtime</td></tr><tr class="even"><td style="text-align: center;">test</td><td style="text-align: center;">test</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">test</td></tr><tr class="odd"><td style="text-align: center;">provided</td><td style="text-align: center;">provided</td><td style="text-align: center;">-</td><td style="text-align: center;">provided</td><td style="text-align: center;">provided</td></tr><tr class="even"><td style="text-align: center;">runtime</td><td style="text-align: center;">runtime</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">runtime</td></tr></tbody></table><h3 id="依赖调解">依赖调解</h3><p>依赖调解的原则：</p><ol type="1"><li>路径最近者优先。依赖的路径比较短的包会被解析使用。</li><li>第一声明者优先。如果路径长度一样，在POM文件中，顺序靠前的那个依赖优胜。</li></ol><h2 id="仓库">仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">Maven仓库 --- 本地仓库</span><br><span class="line">Maven仓库 --- 远程仓库</span><br><span class="line">远程仓库 --- 中央仓库</span><br><span class="line">远程仓库 --- 私服</span><br><span class="line">远程仓库 --- 其他公共库</span><br></pre></td></tr></table></figure><h3 id="仓库解析的机制">仓库解析的机制</h3><ol type="1"><li>依赖范围是 system 时，直接从本地解析</li><li>计算仓库路径后，如果本地仓库存在则解析</li><li>本地不存在，依赖版本是发布版本构件，遍历远程仓库，下载到本地并解析</li><li>如果依赖版本是 RELEASE 或LATEST，获取远程仓库元数据，计算出真实版本值，重复 2 和 3。</li><li>如果依赖版本是SNAPSHOT，获取远程仓库元数据，得到最新版本，检查，根据需要下载。</li><li>如果版本是时间戳格式的快照，会恢复成非时间戳格式，再去找。</li><li>版本不明晰的时候，如 RELEASE、LATEST 和SNAPSHOT，会根据远程仓库的更新策略来检查更新，和仓库看配置有关。相关的配置标签：releases、snapshots的 enabled，和 updatePolicy 等。</li></ol><h3 id="镜像">镜像</h3><p><code>&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</code>：匹配所有远程仓库。</p><p><code>&lt;mirrorOf&gt;external：*&lt;/mirrorOf&gt;</code>：匹配所有远程仓库，使用localhost 的除外，使用 file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。</p><p><code>&lt;mirrorOf&gt;repo1，repo2&lt;/mirrorOf&gt;</code>：匹配仓库repo1 和 repo2，使用逗号分隔多个远程仓库。</p><p><code>&lt;mirrorOf&gt;*，！repo1&lt;/mirrorOf&gt;</code>：匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。</p><p>需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。</p><h2 id="生命周期">生命周期</h2><blockquote><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。也就是说，几乎所有项目的构建，都能映射到这样一个生命周期上。</p></blockquote><p>Maven的生命周期是抽象的，实现由插件来完成。有默认插件，也可以绑定其它插件。</p><p>Maven 拥有三套独立的生命周期：clean，default，site。</p><h3 id="clean">clean</h3><ul><li>pre-clean</li><li>clean</li><li>post-clean</li></ul><h3 id="default">default</h3><p>太多了，完整的在 <ahref="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference">LifecycleReference</a>。</p><p>部分重要的</p><ul><li><code>validate</code> - validate the project is correct and allnecessary information is available</li><li><code>compile</code> - compile the source code of the project</li><li><code>test</code> - test the compiled source code using a suitableunit testing framework. These tests should not require the code bepackaged or deployed</li><li><code>package</code> - take the compiled code and package it in itsdistributable format, such as a JAR.</li><li><code>verify</code> - run any checks on results of integration teststo ensure quality criteria are met</li><li><code>install</code> - install the package into the localrepository, for use as a dependency in other projects locally</li><li><code>deploy</code> - done in the build environment, copies thefinal package to the remote repository for sharing with other developersand projects.</li></ul><h3 id="site">site</h3><ul><li>pre-site</li><li>site</li><li>post-site</li><li>site-deploy</li></ul><h2 id="插件">插件</h2><p>Maven 生命周期和插件相互绑定。</p><p>可以自定义将某个插件目标绑定到生命周期的某个阶段上。</p><p>可以通过命令行参数 -D 对插件进行配置。例如跳过测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><h2 id="聚合和继承">聚合和继承</h2><h3 id="聚合">聚合</h3><p>如果想要一次构建两个项目，而不是到两个模块的目录下面分别执行 mvn命令，我们可以再新建一个 pom 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-aggregator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Account Aggregator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>account-email<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>account-persist<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>account-parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块不一定要是树形嵌套的结构的，也可以平行放置，这样 module标签要改成相对路径。</p><p>这样运行 <code>mvn clean install</code>命令就会同时构建两个工程。</p><h3 id="继承">继承</h3><p>如果多个模块都依赖了一堆相同的东西，那么可以建立一种父子结构，让子模块继承父模块。</p><p>作为父模块，打包类型需要为 <code>pom</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Account Parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块需要继承它。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../account-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Account Email<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        ……</span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>relativePath 似乎可以不需要。</p><p>子模块没有配置 groupId 和 version的话，会继承父类的配置。也可以显式声明。</p><p>最后要把父模块也添加到聚合模块里面。</p><h3 id="所有可以被继承的pom元素">所有可以被继承的POM元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">groupId：项目组ID，项目坐标的核心元素。</span><br><span class="line">version：项目版本，项目坐标的核心元素。</span><br><span class="line">description：项目的描述信息。</span><br><span class="line">organization：项目的组织信息。</span><br><span class="line">inceptionYear：项目的创始年份。</span><br><span class="line">url：项目的URL地址。</span><br><span class="line">developers：项目的开发者信息。</span><br><span class="line">contributors：项目的贡献者信息。</span><br><span class="line">distributionManagement：项目的部署配置。</span><br><span class="line">issueManagement：项目的缺陷跟踪系统信息。</span><br><span class="line">ciManagement：项目的持续集成系统信息。</span><br><span class="line">scm：项目的版本控制系统信息。</span><br><span class="line">mailingLists：项目的邮件列表信息。</span><br><span class="line">properties：自定义的Maven属性。</span><br><span class="line">dependencies：项目的依赖配置。</span><br><span class="line">dependencyManagement：项目的依赖管理配置。</span><br><span class="line">repositories：项目的仓库配置。</span><br><span class="line">build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等。</span><br><span class="line">reporting：包括项目的报告输出目录配置、报告插件配置等。</span><br></pre></td></tr></table></figure><h3 id="依赖管理">依赖管理</h3><p>使用 <code>dependencyManagement</code>元素的依赖，不会给子模块引入依赖。子模块需要引入依赖的时候，需要提供groupId 和 artifactId，该依赖的还是要写，不过不需要提供版本号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="scope-import">scope import</h4><blockquote><p><ahref="https://www.cnblogs.com/huahua035/p/7680607.html">maven中importscope依赖方式解决单继承问题的理解 - 花花牛 - 博客园</a></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 import 依赖，可以把另一个 POM 中的 dependencyManagement配置合并到 当前 POM 的 dependencyManagement 元素中。想要重复使用一批dependencyManagement 配置，除了可以复制配置或者继承之外，还可以通过这种import 范围依赖将这一配置导入进来。</p><blockquote><p>如果有多个项目，它们使用的依赖版本都是一致的，则就可以定义一个使用dependencyManagement专门管理依赖的POM，然后在各个项目中导入这些依赖管理配置。</p></blockquote><p>这样，用聚合代替继承，就可以解决 POM文件只能单继承的问题，也可以更好地按功能划分 POM 文件。</p><h3 id="插件管理">插件管理</h3><p><code>pluginManagement</code> 也是类似的原理。</p><h3 id="聚合和继承的关系">聚合和继承的关系</h3><ul><li><p>对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。</p></li><li><p>对于继承关系的父 POM来说，它不知道有哪些子模块继承于它，但那些子模块都必须知道自己的父 POM是什么。</p></li><li><p>一个 POM 可以既是聚合 POM，又是父 POM，没有什么问题。</p></li></ul><h3 id="超级pom">超级POM</h3><p>任何一个 Maven 项目都隐式地继承自该 POM。这个超级 POM约定了中央仓库、项目结构、插件版本等等配置。这些配置成了 Maven所提倡的约定，可以在 Maven 的依赖包里面找到。</p><h3 id="反应堆">反应堆</h3><blockquote><p>在一个多模块的Maven项目中，反应堆（Reactor）是指所有模块组成的一个构建结构。对于单模块的项目，反应堆就是该模块本身，但对于多模块项目来说，反应堆就包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序。</p></blockquote><p>Maven会根据模块之间的依赖关系，决定构建模块的顺序。如果一个模块依赖于另一个模块，就先构建那个模块。这么递归下去，直到找到没有依赖的模块。</p><p>模块之间的依赖关系会构成一个有向无环图（DAG），所以说不能出现环，要是出现了循环依赖，Maven就会报错。</p><p>用户可以裁剪反应堆，也就是可以选择只构建反应堆中的一些个模块，加速构建。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;平平无奇的 Java 的包管理工具。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Java" scheme="https://blog.beanbang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR 4 笔记</title>
    <link href="https://blog.beanbang.cn/2020/10/21/antlr-v4-note/"/>
    <id>https://blog.beanbang.cn/2020/10/21/antlr-v4-note/</id>
    <published>2020-10-21T02:46:13.000Z</published>
    <updated>2022-09-10T10:45:01.074Z</updated>
    
    <content type="html"><![CDATA[<p>“语言的边界就是思想的边界。”</p><span id="more"></span><blockquote><p><a href="http://www.yinwang.org/blog-cn/2017/05/25/dsl">DSL 的误区 |王垠</a></p><p><ahref="https://zhuanlan.zhihu.com/p/20178871">如何愉快地写个小parser -知乎</a></p><p><ahref="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md">GettingStarted with ANTLR v4 | GitHub</a></p><p><a href="https://book.douban.com/subject/27082372/">ANTLR 4权威指南(豆瓣)</a></p><p><ahref="https://pragprog.com/titles/tpantlr2/the-definitive-antlr-4-reference/">TheDefinitive ANTLR 4 Reference</a> 英文版和示例代码</p></blockquote><h2 id="是什么">是什么</h2><p>ANTLR 是：</p><ul><li><p>语法分析器的生成器：可以根据一个程序设计语言的语法描述自动生成语法分析器。</p></li><li><p>扫描器的生成器：可以根据一个语言的语法单元的正则表达式描述生成词法分析器。</p></li><li><p>语法制导的翻译引擎：ANTLR会生成语法树并生成相应的访问器或者监听器类来遍历语法树。</p></li><li><p>使用 LL(*) 文法的解析器。</p></li><li><p>包含很多现成的语法定义，解析主流的语言都可以开箱即用：<ahref="https://github.com/antlr/grammars-v4">antlr/grammars-v4 ·GitHub</a>。</p></li></ul><h2 id="安装">安装</h2><h3 id="命令行">命令行</h3><p>https://www.antlr.org/download/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH =.;D:\javalib\*;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: antlr4.bat</span><br><span class="line">@java -cp .;D:\javalib\antlr-4.8-complete.jar org.antlr.v4.Tool %*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::grun.bat</span><br><span class="line">@java -cp .;D:\javalib\antlr-4.8-complete.jar org.antlr.v4.gui.TestRig %*</span><br></pre></td></tr></table></figure><h3 id="idea">IDEA</h3><ol type="1"><li>安装插件 <ahref="https://plugins.jetbrains.com/plugin/7358-antlr-v4-grammar-plugin">ANTLRv4 grammar plugin</a></li><li>在语法文件的规则上 右键 -&gt; Test Rule ... ，来实时测试语法树</li><li>在语法文件里面 右键 -&gt; Generate ANTLR Recognizer 来生成代码</li></ol><h3 id="vs-code">VS Code</h3><p>安装插件 <ahref="https://marketplace.visualstudio.com/items?itemName=mike-lischke.vscode-antlr4">ANTLR4grammar syntax support</a>。</p><h2 id="hello-world">Hello world</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Define a grammar called Hello</span><br><span class="line">grammar Hello;</span><br><span class="line">r  : &#x27;hello&#x27; ID ;         // match keyword hello followed by an identifier</span><br><span class="line">ID : [a-z]+ ;             // match lower-case identifiers</span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip ; // skip spaces, tabs, newlines</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grun Hello r -gui</span><br><span class="line">grun Hello r -tokens</span><br><span class="line">grun Hello r -tree</span><br><span class="line">antlr4 -no-listener -visitor xxx.g4</span><br></pre></td></tr></table></figure><p>退出：Windows 按下 <kbd>Ctrl</kbd> + <kbd>Z</kbd>，<kbd>Enter</kbd>退出。</p><h2 id="遍历语法树">遍历语法树</h2><p>ANTLR的监听器和访问器能够将语法和程序逻辑代码解耦，可以不需要在语法中内嵌动作。</p><blockquote><p>使用访问器和监听器机制，我们可以完成一切与语法相关的事情。一旦进入Java的领域，就没有什么ANTLR的相关内容值得学习了。我们需要谨记在心的是，语法及其对应的语法分析树，以及访问器或者监听器事件方法之间的关系。除此之外，剩下的仅仅是普通的代码。在对输入文本进行识别时，我们可以产生输出、收集信息（正如本例中我们所做的）、用某种方式验证输入文本，或者执行计算。</p></blockquote><h3 id="listener监听器">Listener（监听器）</h3><p>类似于 XML 的 SAX 解析。监听器的方法会被 Antlr提供的遍历器对象自动调用。</p><p>可以用 ParseTreeProperty 来储存和获取变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTreeProperty&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">ParseTreeProperty</span>&lt;Integer&gt;();</span><br><span class="line">values.put(ctx, values.get(ctx.getChild(<span class="number">0</span>)));</span><br><span class="line">values.get(ctx.e(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="visitor访问器">Visitor（访问器）</h3><p>访问器方法中，需要显式地调用 visit()方法来访问子节点，可以自己定义怎么访问子树。</p><h3 id="代码生成">代码生成</h3><ul><li>Parser.java</li><li>Lexer.java</li><li>.tokens</li><li>Listener.java</li></ul><h2 id="入门">入门</h2><h3 id="语法导入">语法导入</h3><p>使用 <code>import</code> 可以让语法文件模块化。</p><h3 id="标签">标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat:   expr NEWLINE                # printExpr</span><br><span class="line">    |   ID &#x27;=&#x27; expr NEWLINE         # assign</span><br><span class="line">    |   NEWLINE                     # blank</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>加了标签的备选分支，会生成相应的访问器方法。</p><h3 id="语法分析">语法分析</h3><p>语法中嵌入动作</p><p>使用语义判定改变语法分析过程</p><h3 id="词法分析">词法分析</h3><p>孤岛语法。例子：解析xml</p><p>重写输入流。例子：java代码添加序列化标识符</p><p>将词法送入不同通道。例子：忽略却保留注释和空白字符</p><h2 id="开发">开发</h2><h3 id="设计语法">设计语法</h3><p>起始规则，词法符号，语法规范</p><h3 id="常见的语言模式">常见的语言模式</h3><ol type="1"><li>序列（sequence）</li><li>选择（choice）</li><li>词法符号依赖（token dependency）</li><li>嵌套结构（nested phrase）</li></ol><h4 id="序列模式">序列模式</h4><p>比如一个协议语言POP，由关键字、整数和换行组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retr : &#x27;RETR&#x27; INT &#x27;\n&#x27;</span><br></pre></td></tr></table></figure><p>任意长度序列可以用 <code>+</code> 字符。<code>(INT)+</code> 或者<code>INT+</code>。</p><p>可以为空，零个或多个用 <code>*</code>。</p><p>零个或一个：<code>?</code>。</p><h4 id="选择模式多个备选分支">选择模式（多个备选分支）</h4><p>使用符号 <code>|</code>作为“或者”来表达编程语言中的选择模式。备选分支（alternative）或者可生成的结果（productions）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type : &#x27;float&#x27; | &#x27;int&#x27; | &#x27;void&#x27;</span><br></pre></td></tr></table></figure><h4 id="词法符号依赖模式">词法符号依赖模式</h4><p>依赖符号的语法，比如数组的括号。表达对符号的依赖的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector : &#x27;[&#x27; INT+ &#x27;]&#x27; ; // [1], [1 2], [1 2 3], ...</span><br></pre></td></tr></table></figure><h4 id="嵌套模式">嵌套模式</h4><p>自己引用自己。如果一条规则定义中的伪代码引用了它自身，就需要一条递归规则（自引用规则）。</p><p>直接递归和间接递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : ID &#x27;[&#x27; expr &#x27;]&#x27;</span><br><span class="line">     | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">     | INT</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure><img src="/2020/10/21/antlr-v4-note/5-1-antlr-core-notation.png" class="" alt="ANTLR核心标记"><img src="/2020/10/21/antlr-v4-note/5-2-common-computer-patterns.png" class="" alt="几种常见的计算机语言的模式"><h3 id="左递归和优先级">左递归和优先级</h3><p>经典的从左到右自顶向下的语法分析器无法处理左递归。算符优先级带来的问题。ANTLR解决的方式是，写在前面的语法拥有较高的优先级。如果遇到了从右向左结合的，需要使用assoc 手工指定结合性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr : &lt;assoc=right&gt; expr &#x27;^&#x27; expr</span><br><span class="line">     | INT</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure><p>ANTLR 4 可以能够处理直接左递归，但是不能处理间接左递归。</p><h3 id="识别词法">识别词法</h3><h4 id="匹配标识符">匹配标识符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID : (&#x27;a&#x27;..&#x27;z&#x27;|&#x27;A&#x27;..&#x27;Z&#x27;)+ ; //匹配1个或多个大小写字母</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID : [a-zA-z]+ ;</span><br></pre></td></tr></table></figure><p>ID 规则可能和其他规则冲突，比如其他关键字 enum 或 for。所以要把 ID规则放在所有关键字规则之后。</p><h4 id="匹配数字">匹配数字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INT : &#x27;0&#x27;..&#x27;9&#x27;+ ;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INT : [0-9]+ ;</span><br></pre></td></tr></table></figure><p>浮点数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FLOAT : DIGIT+ &#x27;.&#x27; DIGIT*  // 1. 3.14</span><br><span class="line">      |        &#x27;.&#x27; DIGIT+  // .1 .1415</span><br><span class="line">      ;</span><br><span class="line">fragment</span><br><span class="line">DIGIT : [0-9] ; // 单个数字</span><br></pre></td></tr></table></figure><p>将一条规则声明为 fragment可以告诉ANTLR，该规则本身不是一个词法符号，它只会被其他的词法规则使用。</p><h4 id="字符串">字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRING : &#x27;&quot;&#x27; .*? &#x27;&quot;&#x27; ;</span><br></pre></td></tr></table></figure><p><code>.</code> 匹配任意单个字符，<code>.*</code>匹配零个或多个，<code>?</code> 标记表示使用非贪婪匹配子规则（nongreedysubrule）。</p><p>转义字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STRING : &#x27;&quot;&#x27; (ESC|.)*? &#x27;&quot;&#x27; ;</span><br><span class="line">fragment</span><br><span class="line">ESC : &#x27;\\&quot;&#x27; | &#x27;\\\\&#x27; ; // 转义 \&quot; 和 \\</span><br></pre></td></tr></table></figure><h4 id="注释和空白字符">注释和空白字符</h4><p>C 中的单行和多行注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINE_COMINT : &#x27;//&#x27; .*? &#x27;\r&#x27;? &#x27;\n&#x27; -&gt; skip ; // 消费掉双斜杠后面的一切字符，直到遇到换行符</span><br></pre></td></tr></table></figure><p>空白字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WS : [ \t\r\n]+ -&gt; skip ;</span><br></pre></td></tr></table></figure><img src="/2020/10/21/antlr-v4-note/5-3-lexer-starter-kit.png" class="" alt="一些基础的语法规则"><h2 id="解析现成的语言">解析现成的语言</h2><blockquote><p>要想揭开一门语言的神秘面纱，我们需要分析不同来源的信息。语言的规模越大，我们需要的参考文档和各式各样的范例代码就越多。有时候，只有设法对语言现有的实现进行试探，才能发现边界情况。语言的参考文档通常并非一目了然。</p></blockquote><ul><li>CSV</li><li>JSON</li><li>DOT</li><li>Cymbol</li></ul><h2 id="语法和程序逻辑">语法和程序逻辑</h2><h3 id="在事件方法中共享信息">在事件方法中共享信息</h3><ol type="1"><li><p>使用访问器的方法来返回值</p><p>继承 BasicVisitor 的时候指定泛型</p></li><li><p>使用类的成员在事件方法之间共享数据</p><p>比如在监听器的类中声明一个栈，每个子表达式的结果退入栈中，然后在更高层的节点中取出来。</p></li><li><p>对语法分析树的结点进行标注</p><p>可以直接将语句绑定在语法上，这样每一个节点都会有这个值：<code>e returns [int value] ...;</code>。</p><p>使用 <code>ParseTreeProperty</code> 的辅助类，本质上是IdentityHashMap，用节点对象作为键。</p></li></ol><h2 id="高级特性">高级特性</h2><h3 id="上下文相关的词法问题">上下文相关的词法问题</h3><p>（12章第二节）</p><blockquote><p>因为ANTLR自动生成的语法分析器经常在词法符号流中进行非常远的前瞻以作出语法分析决策。这意味着，远在语法分析器能够执行提供上下文信息的行为之前，词法分析器就需要将字符流处理为词法符号。</p></blockquote><p>因为这样，处理上下文相关的词法问题变得比较困难。</p><p>关键字作为标识符的问题的解决方法是，令词法分析器将所有关键字当作词法符号送给语法分析器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“语言的边界就是思想的边界。”&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Java" scheme="https://blog.beanbang.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Dokcer 的远程连接和部署</title>
    <link href="https://blog.beanbang.cn/2020/08/31/remote-access-and-deployment-of-docker/"/>
    <id>https://blog.beanbang.cn/2020/08/31/remote-access-and-deployment-of-docker/</id>
    <published>2020-08-31T08:08:21.000Z</published>
    <updated>2022-09-13T12:32:00.009Z</updated>
    
    <content type="html"><![CDATA[<p>让远程部署和本地一样简单！</p><span id="more"></span><h2 id="tldr">TL;DR</h2><ul><li>Docker 是 C/S 架构的，服务端和客户端可以在不同主机运行</li><li>无加密的 TCP 连接配置简单，但不安全</li><li>TLS 加密的连接需要创建和配置证书，最常用</li><li>SSH 连接使用方便，但是 IDE 不大兼容，比较局限</li><li>命令行、IDEA、VS Code 怎么连接 Docker daemon</li><li>一个小 demo，用 Dokcer client 部署 Spring Boot 项目</li></ul><p>20220913 更新：现在 SSH连接的方式已经被大部分软件支持了，别的方式的可以不用看了。</p><h2 id="docker-的架构">Docker 的架构</h2><p>最近在学习用 Docker 来部署项目。我按照这个<ahref="https://www.thisfaner.com/p/configure-docker-in-intellij-idea/">教程</a>来把Java 项目部署到了服务器的 Docker 上面。IDEA 的 Dokcer插件真的是特别方便，配置好之后一键就能部署上去，而且 Windows本机上也不需要安装几百兆的 Docker Desktop，不用开启Hyper-V。这是怎么实现的呢？</p><p>从 Docker 的<ahref="https://docs.docker.com/get-started/overview/#docker-architecture">官方文档</a>里面可以看到，Docker使用的是 C/S 架构的系统，分为客户端和服务端。客户端（Dockerclient）使用命令和服务端（Dokcerdaemon，守护进程）进行交互。守护进程负责干重活，比如构建、运行和分发你的容器。客户端和守护进程可以运行在同一台主机，也就是我们常规的安装；也可以让客户端连接到一台远程的守护进程。客户端和守护进程使用REST API 进行交互，通过 UNIX sockets 或者网络接口进行传输。</p><img src="/2020/08/31/remote-access-and-deployment-of-docker/docker-architecture.svg" class="" alt="Docker的架构 | Docker Documentation"><p>所以我们如果只需要连接远程服务器的 Docker的话，就没有必要在本地安装完整的 Docker，不需要安装 Dockerdaemon，只需要有能与 Docker daemon 进行交互的客户端，比如 Dockerclient，就可以了。</p><h2 id="连接-docker-daemon">连接 Docker daemon</h2><p>在默认的设置下，Docker daemon 只监听来自本地的 UNIX socket 连接。</p><p>在 <code>/lib/systemd/system/docker.service</code> 下面可以看到<code>dockerd</code>，即 Docker daemon 的启动参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>我们需要修改这个 <code>systemd</code> 的启动参数来开启外部访问。</p><h3 id="使用无加密-tcp-连接">使用无加密 TCP 连接</h3><ol type="1"><li><p>使用 <code>sudo systemctl edit docker.service</code> 来编辑<code>docker.service</code>，这会在它的基础上重写配置。</p></li><li><p>写上下面的内容，保存文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>上面这个 <code>ExecStart=</code>的作用是清空原来项目的值，然后用新的值替代。官方文档这么写的，我之前还以为是笔误……</p></li><li><p>更新 systemctl 配置和重启 Docker。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure></li><li><p>检查 dockerd 是否运行起来 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -lntp | grep dockerd</span><br></pre></td></tr></table></figure></p></li></ol><p>现在我们已经开放了 TCP 的 2375端口，只要在执行命令的时候加上参数就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://docker.beanbang.cn:2375 version</span><br></pre></td></tr></table></figure><p>也可以设置环境变量<code>DOCKER_HOST</code>，这样就不用每次都带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=tcp://docker.beanbang.cn:2375</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用这种连接方式是<strong>不安全</strong>的，端口并没有加密，这意味者任何人都可以连接你的Dockerdaemon，往里面运行容器。虚拟机用还好，云服务器上要是被别有用心的人发现了不是纯白给了。所以加密你的Docker 端口还是很有必要的。</p><h3 id="使用-tls-加密的-tcp-连接">使用 TLS 加密的 TCP 连接</h3><p>需要使用 OpenSSL生成密钥，证书。客户端和守护进程使用这些证书和密钥来进行认证。只要照着官方文档的这篇文章，一步一步做下来就可以了:</p><blockquote><p><a href="https://docs.docker.com/engine/security/https/">Protect theDocker daemon socket | Docker Documentation</a></p></blockquote><p>生成证书的大致过程是，生成 CA 的密钥和 CA证书，生成客户端和服务端的密钥；生成客户端和服务端的签名请求，然后 CA分别对客户端和服务端的签名请求生成证书。</p><p>跟着教程一顿操作之后，可以得到下面的几个文件。</p><table><thead><tr class="header"><th>文件</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ca-key.pem</td><td>CA 密钥</td></tr><tr class="even"><td>ca.pem</td><td>CA 证书</td></tr><tr class="odd"><td>server-key.pem</td><td>服务端密钥</td></tr><tr class="even"><td>server-cert.pem</td><td>服务端证书</td></tr><tr class="odd"><td>key.pem</td><td>客户端密钥</td></tr><tr class="even"><td>cert.pem</td><td>客户端证书</td></tr></tbody></table><p>然后我们接着修改 docker.service。虽然可以这么写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl edit docker.service</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/home/ubuntu/certificate/ca.pem --tlscert=/home/ubuntu/certificate/server-cert.pem --tlskey=/home/ubuntu/certificate/server-key.pem \</span><br><span class="line">  -H tcp://0.0.0.0:2376 -H fd://</span><br></pre></td></tr></table></figure><p>不过，这样大长串的参数很不直观。下面我们换成使用 Docker提供的另一种配置 dockerd 的方式，就是 <code>daemon.json</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;fd://&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tcp://0.0.0.0:2376&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tlsverify&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tlscacert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ubuntu/certificate/ca.pem&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tlscert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ubuntu/certificate/server-cert.pem&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tlskey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ubuntu/certificate/server-key.pem&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>原本的 docker.service 只保留一点东西：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br></pre></td></tr></table></figure><p>然后重启 Docker 就可以了。</p><p><strong>注意：</strong>Docker 在启动的时候会同时使用<code>systemd</code> 和 <code>daemon.json</code>文件。如果两个文件的配置项冲突了，会造成无法启动。所以配置要么写docker.service 里面，要么写 daemon.json里面，不要两个都写，防止出现问题。</p><p><strong>注意2：</strong>按照惯例，不加密的 TCP 连接使用 2375端口，TLS 加密的 TCP 连接使用 2376 端口。</p><p>运行起来后，客户端连接需要 ca.pem，cert.pem，key.pem三个文件。我们可以把它们从主机上拷贝下来，放在自己用户目录的<code>.docker</code> 目录下，这是证书文件的默认查找目录。</p><p>纯命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem \</span><br><span class="line">  -H=docker.beanbang.cn:2376 version</span><br></pre></td></tr></table></figure><p>使用环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=tcp://docker.beanbang.cn:2376 DOCKER_TLS_VERIFY=1</span><br><span class="line">export DOCKER_CERT_PATH=$HOME/.docker # 证书在默认查找目录可以不用指定</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="使用-ssh-连接">使用 SSH 连接</h3><p>从 Docker 的 18.09 版本开始，Docker client 支持通过 SSH 来连接远程daemon 了。但是到了今天（2020年8月），我能直接下载到的最新 Dokcer clientfor Windows 版本是 17.09。IDEA 和 VS Code 这些 IDE我也试过，同样不能使用 SSH协议来连接。所以这种方法虽然特别方便，但是目前还是比较有局限性的。</p><p>要使用 SSH 协议来连接 Docker daemon，你可以使用 Linux 或者 WSL安装新版的 docker-cli。</p><p>服务端不需要任何配置，只需要在客户端执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H ssh://ubuntu@192.168.43.220 version</span><br></pre></td></tr></table></figure><p>注意，这边主机名只能使用 IP 地址，不能使用域名。</p><p>这种方式是使用 SSH密钥登录和认证的，如果你没有使用密钥来登录主机，可以现配置一个：</p><ol type="1"><li><p>检查一下你的用户目录下的 <code>.ssh</code> 文件夹下面有没有<code>id_rsa</code> 和 <code>id_rsa.pub</code> 文件。如果你在用Git，可能已经创建过密钥了。</p><p>没有的话就创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>把你的公钥添加到远程主机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id ubuntu@192.168.43.220</span><br></pre></td></tr></table></figure><p>Windows 没有这个命令的话就手动把 <code>id_rsa.pub</code>里面的内容添加到远程主机用户的 <code>~/.ssh/authorized_keys</code>里面。</p></li></ol><p>这就行了。同样可以把这个连接串设置到环境变量中，方便使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=ssh://ubuntu@192.168.43.220</span><br></pre></td></tr></table></figure><h2 id="客户端配置">客户端配置</h2><h3 id="命令行">命令行</h3><h4 id="windows">Windows</h4><p>直接安装 Docker desktop 是可以的，安装完成之后就可以使用 docker命令了。但是假如我们本地只想用客户端的功能，不想安装它那厚重的 DockerEngine，可以只下载几个二进制可执行文件。下面是下载地址:</p><p>Docker CLI Windows：<ahref="https://download.docker.com/win/static/stable/x86_64/"class="uri">https://download.docker.com/win/static/stable/x86_64/</a></p><p>Docker compose：<a href="https://github.com/docker/compose/releases"class="uri">https://github.com/docker/compose/releases</a></p><p>下载完成后，重命名成 <code>docker.exe</code> 和<code>docker-compose.exe</code>，丢进设置过 <code>Path</code>环境变量的文件夹里就可以了。</p><h4 id="linux">Linux</h4><p>Linux 客户端只需要安装 <code>docker-ce-cli</code>。这里推荐一下<ahref="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">清华 tuna镜像源</a>，提供了 docker-ce 的镜像和安装教程。</p><h3 id="intellij-idea">IntelliJ IDEA</h3><p>IDEA 里面图形化的设置很方便。如果使用了加密的TCP，要选定证书的文件夹，并且 URL 要写成<code>https://docker.beanbang.cn:2376</code> 这样的以 https开头的形式。</p><figure><img src="https://www.z4a.net/images/2020/08/31/IDEA-Docker.png"alt="IDEA 添加 Docker 连接" /><figcaption aria-hidden="true">IDEA 添加 Docker 连接</figcaption></figure><h3 id="vs-code">VS Code</h3><p>首先安装 Docker 插件，然后修改配置文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;docker.host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp://docker.beanbang.cn:2376&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docker.tlsVerify&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docker.certPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\GYM\\.docker&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure><img src="https://www.z4a.net/images/2020/08/31/vscode-docker.png"alt="VS Code 配置连接 Docker" /><figcaption aria-hidden="true">VS Code 配置连接 Docker</figcaption></figure><h2 id="试试看">试试看！</h2><p>连接上远程 Docker 之后，我们就可以尝试远程部署了。这是一个例子，在Windows 10 上用 Dokcer CLI 部署一个 Spring Boot项目到远程服务器上。我使用的是 TLS 加密的TCP，就是上面的提到的配置。</p><p>环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ set | findstr DOCKER</span><br><span class="line">DOCKER_HOST=tcp://docker.beanbang.cn:2376</span><br><span class="line">DOCKER_TLS_VERIFY=1</span><br></pre></td></tr></table></figure><p>在 Spring initializr 上面<ahref="https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=2.3.3.RELEASE&amp;packaging=jar&amp;jvmVersion=14&amp;groupId=cn.beanbang&amp;artifactId=rest-test&amp;name=rest-test&amp;description=Demo%20project%20for%20Spring%20Boot%20and%20Docker&amp;packageName=cn.beanbang.demo&amp;dependencies=web">创建项目</a>并下载到本地。</p><figure><img src="https://www.z4a.net/images/2020/08/31/spring-initializr.png"alt="使用 Spring initializr 来初始化项目" /><figcaption aria-hidden="true">使用 Spring initializr来初始化项目</figcaption></figure><p>添加一个控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.beanbang.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;world&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Hello, %s!&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>mvnw package</code> 命令打包。会在 <code>target</code>目录下生成 <code>rest-test-0.0.1-SNAPSHOT.jar</code> 文件。</p><p>在项目的目录下创建 <code>Dockerfile</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre</span><br><span class="line">ADD target/rest-test-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><p>然后可以开始部署了。</p><p>创建容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t rest-test .</span><br><span class="line">Sending build context to Docker daemon  16.78MB</span><br><span class="line">Step 1/4 : FROM openjdk:8-jre</span><br><span class="line"> ---&gt; 2e2653debbe9</span><br><span class="line">Step 2/4 : ADD target/rest-test-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line"> ---&gt; a80c846520e1</span><br><span class="line">Step 3/4 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in 68400e62b5cd</span><br><span class="line">Removing intermediate container 68400e62b5cd</span><br><span class="line"> ---&gt; fb69206fbe08</span><br><span class="line">Step 4/4 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br><span class="line"> ---&gt; Running in 3e03c7f8804e</span><br><span class="line">Removing intermediate container 3e03c7f8804e</span><br><span class="line"> ---&gt; df0e8cc51568</span><br><span class="line">Successfully built df0e8cc51568</span><br><span class="line">Successfully tagged rest-test:latest</span><br><span class="line">SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have &#x27;-rwxr-xr-x&#x27; permissions. It is recommended to double check and reset permissions for sensitive files and directories.</span><br></pre></td></tr></table></figure><p>运行容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name rest-demo -p 8081:8080 -d rest-test</span><br><span class="line">dd164ec7f237ba8736f2253ab2b226a66700733ed85e52cacee52345ec28f71b</span><br></pre></td></tr></table></figure><figure><imgsrc="https://www.z4a.net/images/2020/08/31/docker-remote-success.png"alt="显示容器日志和测试接口" /><figcaption aria-hidden="true">显示容器日志和测试接口</figcaption></figure><p>这样，一个简单的 Java Web 服务就搭建起来了。在执行<code>docker build</code> 命令的时候，Docker会把构建所需要的文件上传到服务端的 daemon，然后 daemon负责创建镜像和后续的容器运行等流程。</p><hr /><blockquote><p>参见：</p><ul><li><a href="https://docs.docker.com/engine/security/https/">Protect theDocker daemon socket | Docker Documentation</a></li><li><ahref="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file">dockerd| Docker Documentation</a></li><li><ahref="https://docs.docker.com/engine/install/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections">Post-installationsteps for Linux | Docker Documentation</a></li><li><ahref="https://medium.com/better-programming/docker-tips-access-the-docker-daemon-via-ssh-97cd6b44a53">DockerTips: Access the Docker Daemon via SSH | by Luc Juggery |Medium</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;让远程部署和本地一样简单！&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="Windows" scheme="https://blog.beanbang.cn/tags/windows/"/>
    
    <category term="Linux" scheme="https://blog.beanbang.cn/tags/linux/"/>
    
    <category term="IDEA" scheme="https://blog.beanbang.cn/tags/idea/"/>
    
    <category term="系统" scheme="https://blog.beanbang.cn/tags/os/"/>
    
    <category term="安全" scheme="https://blog.beanbang.cn/tags/security/"/>
    
    <category term="虚拟化" scheme="https://blog.beanbang.cn/tags/virtualization/"/>
    
  </entry>
  
  <entry>
    <title>Let’s Encrypt 安装通配符证书</title>
    <link href="https://blog.beanbang.cn/2020/04/06/install-wildcard-certificate-using-lets-encrypt/"/>
    <id>https://blog.beanbang.cn/2020/04/06/install-wildcard-certificate-using-lets-encrypt/</id>
    <published>2020-04-06T11:45:47.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>不用为二级域名申请证书了，但是有效期只有 3 个月。</p><span id="more"></span><h2 id="安装-certbot">安装 certbot</h2><p>官网：https://certbot.eff.org</p><p>certbot 官网有安装向导。打开<ahref="https://certbot.eff.org/lets-encrypt/ubuntubionic-apache">向导页面</a>，选择你对应的操作系统和网页服务器，它会告诉你怎么做。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Apache on Ubuntu 18.04 LTS (bionic)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add Certbot PPA</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Certbot</span></span><br><span class="line">sudo apt-get install certbot python3-certbot-apache</span><br></pre></td></tr></table></figure><h2 id="申请证书">申请证书</h2><p>这一步需要更改 DNS 的解析记录，有个坑要注意一下：更改 DNS记录要等大约 10 分钟才生效，最好用 <code>screen</code>或者其他命令保证终端不会超时退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly -d &quot;*.beanbang.cn&quot; -d &quot;beanbang.cn&quot; --manual --preferred-challenges dns-01  --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure><ul><li><code>certonly</code> 表示插件，Certbot有很多插件。不同的插件都可以申请证书，用户可以根据需要自行选择。</li><li><code>-d</code> 为哪些主机申请证书。如果是通配符，输入 *.xxx.com(根据实际情况替换为你自己的域名)。</li><li><code>--preferred-challenges dns-01</code> 使用 DNS方式校验域名所有权。</li><li><code>--server</code> Let's Encrypt ACME v2 版本使用的服务器不同于v1 版本，需要显示指定。</li></ul><p>执行之后会有提示你记录 IP地址之类的，确定就是了。之后会提示需要你验证你的域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.beanbang.cn with the following value:</span><br><span class="line"></span><br><span class="line">ErR2BtnzPzdz8zFMW-IK663dM-sWjvXZtjFRwKkkAMU</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">(This must be set up in addition to the previous challenges; do not remove,</span><br><span class="line">replace, or undo the previous challenge tasks yet. Note that you might be</span><br><span class="line">asked to create multiple distinct TXT records with the same name. This is</span><br><span class="line">permitted by DNS standards.)</span><br></pre></td></tr></table></figure><p>括号里的内容说，不要删除和改动先前的记录，你可能被要求向同一个名字（二级域名）添加多条TXT 记录，这个是 DNS 标准所允许的。</p><p>去域名服务商的控制台添加解析记录。改完之后，新建一个连接，用<code>dig</code> 命令来测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig -t txt _acme-challenge.beanbang.cn</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; -t txt _acme-challenge.beanbang.cn</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 38548</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;_acme-challenge.beanbang.cn.   IN      TXT</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">_acme-challenge.beanbang.cn. 592 IN     TXT     &quot;pxQrBuCbDVTP9FIGR55BGZGjVqPXbSN2nNwN3jTUUyI&quot;</span><br><span class="line">_acme-challenge.beanbang.cn. 592 IN     TXT     &quot;shrER0qocOoMedzQGum94cb_wHihcbzIGvJWB2t7vOY&quot;</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 10.236.158.106#53(10.236.158.106)</span><br><span class="line">;; WHEN: Mon Apr 06 23:11:01 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 168</span><br></pre></td></tr></table></figure><p>改完解析记录没有立刻生效的话，可以手动刷新一下主机的 DNS缓存再查。不同的 DNS 缓存服务刷新的命令不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Systemd Resolved</span></span><br><span class="line">sudo systemd-resolve --flush-caches</span><br><span class="line"><span class="comment"># Dnsmasq</span></span><br><span class="line">sudo systemctl restart dnsmasq.service</span><br><span class="line"><span class="comment"># Nscd</span></span><br><span class="line">sudo systemctl restart nscd.service</span><br></pre></td></tr></table></figure><p>如果你发现解析记录已经成功改变了，就可以按下回车。</p><p>成功之后会有下面的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Waiting for verification...</span><br><span class="line">Resetting dropped connection: acme-v02.api.letsencrypt.org</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/beanbang.cn/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/beanbang.cn/privkey.pem</span><br><span class="line">   Your cert will expire on 2020-04-06. To obtain a new or tweaked</span><br><span class="line">   version of this certificate in the future, simply run certbot</span><br><span class="line">   again. To non-interactively renew *all* of your certificates, run</span><br><span class="line">   &quot;certbot renew&quot;</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate</span><br><span class="line">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure><p>这时候应该能看到 <code>/etc/letsencrypt/live/[域名]</code>下的证书文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /etc/letsencrypt/live/beanbang.cn/</span></span><br><span class="line">cert.pem  chain.pem  fullchain.pem  privkey.pem  README</span><br></pre></td></tr></table></figure><h2 id="四个证书文件">四个证书文件</h2><p>查了一下文档<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>，这四个证书文件分别的不同用途，大概是这样：</p><ul><li><p><code>privkey.pem</code></p><p>证书的私钥，必须时刻保护好。不能公开给任何人。</p><p>配置项：Apache 的 <ahref="https://httpd.apache.org/docs/2.4/mod/mod_ssl.html#sslcertificatekeyfile"><code>SSLCertificateKeyFile</code></a>，Nginx的 <ahref="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key"><code>ssl_certificate_key</code></a>。</p></li><li><p><code>fullchain.pem</code></p><p>完整的证书密钥链（certificate chain），包括服务端证书（server/leafcertificate）和中间证书（intermediatecertificate）。在文件最开头第一个是服务端证书，接下来的是中间证书。</p><p>配置项： Apache &gt;= 2.4.8 的 <ahref="https://httpd.apache.org/docs/2.4/mod/mod_ssl.html#sslcertificatefile"><code>SSLCertificateFile</code></a>，Nginx 的 <ahref="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate"><code>ssl_certificate</code></a>。</p></li><li><p><code>cert.pem</code> 和 <code>chain.pem</code> （较少用）</p><p><code>cert.pem</code> 包含了服务器端证书，<code>chain.pem</code>包含了中间证书。假如你要使用它们，必须两个文件一起使用，不然浏览器会提示“链接不受信任”。</p><p>配置项：Apache &lt; 2.4.8 的 <ahref="https://httpd.apache.org/docs/2.4/mod/mod_ssl.html#sslcertificatefile"><code>SSLCertificateFile</code></a>和 <ahref="https://httpd.apache.org/docs/2.4/mod/mod_ssl.html#sslcertificatechainfile"><code>SSLCertificateChainFile</code></a>。启用了OSCP 的 Nginx &gt;= 1.3.7，需要将 <ahref="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_trusted_certificate"><code>ssl_trusted_certificate</code></a>设置为 <code>chain.pem</code>。</p></li></ul><h2 id="配置网页服务器">配置网页服务器</h2><h3 id="apache">Apache</h3><p>找到 Apache 的配置文件<code>httpd-ssl.conf</code>，并且修改相应的内容，把证书添加上去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/lampp</span><br><span class="line">vim etc/extra/httpd-ssl.conf</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> <span class="attr">0.0.0.0:443</span>&gt;</span></span><br><span class="line">    DocumentRoot &quot;/opt/lampp/htdocs/hexo/&quot;</span><br><span class="line">    ServerName blog.beanbang.cn</span><br><span class="line">    SSLEngine on</span><br><span class="line">    SSLCertificateFile /etc/letsencrypt/live/beanbang.cn/fullchain.pem</span><br><span class="line">    SSLCertificateKeyFile /etc/letsencrypt/live/beanbang.cn/privkey.pem</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="nginx">Nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.beanbang.cn.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  blog.beanbang.cn;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /etc/letsencrypt/live/beanbang.cn/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /etc/letsencrypt/live/beanbang.cn/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /home/ubuntu/www/hexo;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新证书">更新证书</h2><p>通配符证书似乎不支持用 <code>certbot renew</code>来更新，重新执行一下上面申请证书的命令来更新证书。证书时长是三个月，在到期的前10 天 Let's Encrypt 会发邮件提醒你的。</p><hr /><blockquote><p>参见：</p><ul><li><a href="https://www.jianshu.com/p/c5c9d071e395">Let's Encrypt终于支持通配符证书了 - 简书</a></li><li><a href="https://www.hi-linux.com/posts/6968.html">Let's Encrypt免费通配符 SSL 证书申请教程 - 运维之美</a></li><li><a href="https://www.7forz.com/3099/">申请 Let's Encrypt 通配符HTTPS 证书，并配置 Apache27f - 柒风博客 | 7f - 柒风博客</a></li><li><ahref="https://www.freebuf.com/column/207777.html">根证书和中间证书的区别- FreeBuf专栏·ssl China</a></li></ul></blockquote><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://certbot.eff.org/docs/using.html#where-are-my-certificates">UserGuide — Certbot 1.0.0.dev0 documentation</a><a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">&lt;p&gt;不用为二级域名申请证书了，但是有效期只有 3 个月。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="安全" scheme="https://blog.beanbang.cn/tags/security/"/>
    
    <category term="Hexo" scheme="https://blog.beanbang.cn/tags/hexo/"/>
    
    <category term="Apache" scheme="https://blog.beanbang.cn/tags/apache/"/>
    
    <category term="HTTPS" scheme="https://blog.beanbang.cn/tags/https/"/>
    
    <category term="SSL" scheme="https://blog.beanbang.cn/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>XML 语法笔记</title>
    <link href="https://blog.beanbang.cn/2020/02/19/xml-syntax-note/"/>
    <id>https://blog.beanbang.cn/2020/02/19/xml-syntax-note/</id>
    <published>2020-02-19T13:56:43.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>XML 光速入门！教程来自 <ahref="https://www.w3school.com.cn/xml/index.asp">W3school</a>。</p><span id="more"></span><p>什么是 XML？</p><ul><li>可扩展标记语言（<strong>EX</strong>tensible <strong>M</strong>arkup<strong>L</strong>anguage）</li><li>用于数据传输</li><li>自行定义标签</li><li>方便程序读取</li><li>组成成分：元素、属性和文本</li><li><a href="https://tools.ietf.org/html/rfc4825">RFC 4825</a></li></ul><h2 id="tldr">TL;DR</h2><p>下面这张图是网站“Linux中国”的 <ahref="https://linux.cn/rss.xml">RSS</a>片段，很有代表性，我把各个字段的含义都标出来了，基本上包括了 XML的所有语法。</p><figure><img src="https://www.z4a.net/images/2020/02/20/xml-syntax.png"alt="一张图看懂 XML！" /><figcaption aria-hidden="true">一张图看懂 XML！</figcaption></figure><h2 id="元素">元素</h2><p>元素（Element）是指从开始标签到结束标签的部分，包括标签本身和标签包括的内容。</p><p>一个元素里面可以有：</p><ul><li>属性</li><li>子元素</li><li>文本</li></ul><p>子元素还能继续包含其他元素，所以是一个树形结构。</p><p><strong>注意：</strong>XML 没有预定义的标签，这和 HTML 不同，HTML中的 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>标签都是预定义的。XML 所有的标签和属性都是创作者自定义的。</p><h3 id="例子">例子</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="https://www.z4a.net/images/2020/02/20/ct_nodetree1.gif"alt="XML 的树形结构 | W3school" /><figcaption aria-hidden="true">XML 的树形结构 | W3school</figcaption></figure><h3 id="语法规则">语法规则</h3><ol type="1"><li><p>所有的元素必须关闭标签</p></li><li><p>对大小写敏感</p></li><li><p>标签必须正确的嵌套</p></li><li><p><strong>文档必须有根元素</strong></p></li><li><p>特殊意义的字符使用实体引用（Entity References）</p><p>实体引用以 <code>&amp;</code> 开头，以 <code>;</code> 结尾，比如<code>&lt;</code> 字符用 <code>&amp;lt;</code> 替换。</p></li><li><p>注释：<code>&lt;!-- 注释内容 --&gt;</code></p></li><li><p>XML 中空格会被保留，而 HTML 会把多个空格合并成一个</p></li></ol><h2 id="属性">属性</h2><p>属性（Attribute）提供关于元素的额外（附加）信息。</p><ul><li>附加的存在</li><li>属性值双引号</li><li>难以维护</li></ul><p>属性通常提供不属于数据组成部分的信息，但这些信息对于处理这个元素的软件来说很重要。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span> <span class="attr">type</span>=<span class="string">&quot;gif&quot;</span>&gt;</span>computer.gif<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><p>包含双引号的属性值用单引号包围：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gangster</span> <span class="attr">name</span>=<span class="string">&#x27;George &quot;Shotgun&quot; Ziegler&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者可以使用实体引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gangster</span> <span class="attr">name</span>=<span class="string">&quot;George <span class="symbol">&amp;quot;</span>Shotgun<span class="symbol">&amp;quot;</span> Ziegler&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="元素还是属性">元素还是属性？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这两个例子传递的信息都是相同的，只是 sex一个是作为属性存在，一个是作为字段存在。什么时候用属性，什么时候用字段是没有规定的。教程里面建议，如果信息看起来很像数据，就使用子元素。</p><blockquote><p>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</p></blockquote><h2 id="命名空间">命名空间</h2><p>命名空间可以避免元素名冲突。</p><p>使用前缀可以避命名冲突。前缀是在标签名的前面加上前缀名称，用冒号隔开：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h:table</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而命名空间对标签进行限定，声明某个前缀属于一个特定的命名空间，采用的方法是添加一个xmlns 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:namespace-prefix=&quot;namespaceURI&quot;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h:table</span> <span class="attr">xmlns:h</span>=<span class="string">&quot;http://www.w3.org/TR/html4/&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>命名空间地址的作用是唯一性，不会被解析，通常是对应的开发者的网站。</p><blockquote><p>用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。</p></blockquote><p>如果省略了前缀名字，则表示所有子元素都属于这个命名空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns=&quot;namespaceURI&quot;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/TR/html4/&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="cdata">CDATA</h2><p>XML 解析器不会解析 CDATA 部分内的文本，常用来保存大段原始数据。</p><p>CDATA 部分以 <code>&lt;![CDATA[</code> 开始，以 <code>]]&gt;</code>结束：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[不会被解析的内容]]&gt;</span><br></pre></td></tr></table></figure><p>CDATA 部分不能包含字符串 <code>]]&gt;</code>。也不允许嵌套的 CDATA部分。</p><p>标记 CDATA 部分结尾的 <code>]]&gt;</code> 不能包含空格或折行。</p><h2 id="xml-相关技术">XML 相关技术</h2><table><colgroup><col style="width: 22%" /><col style="width: 77%" /></colgroup><thead><tr class="header"><th>名称</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td>XML HttpRequest</td><td style="text-align: left;">用于在网页服务器之间传递数据，比如AJAX</td></tr><tr class="even"><td>XML Parser</td><td style="text-align: left;">解析器，用来将 XML 文本解析成 DOM对象</td></tr><tr class="odd"><td>XML DOM</td><td style="text-align: left;">定义了操作 XML 文档的规范，把 XML展示为树形结构</td></tr><tr class="even"><td>XML XPath</td><td style="text-align: left;">XPath 表达式使用类似文件路径的语句来选取XML 中的节点</td></tr><tr class="odd"><td>XML CSS</td><td style="text-align: left;">用 CSS 样式表来格式化 XML 文档</td></tr><tr class="even"><td>XML XSLT</td><td style="text-align: left;">同样是用来格式化 XML 的，比 CSS复杂，功能更多</td></tr><tr class="odd"><td>XML XQuery</td><td style="text-align: left;">XML 的查询语言，如同 SQL 之于数据库</td></tr><tr class="even"><td>XML XLink</td><td style="text-align: left;">XML 里的超链接</td></tr><tr class="odd"><td>XML DTD</td><td style="text-align: left;">规范化，用来定义 XML文档元素和属性的结构</td></tr><tr class="even"><td>XML Schema</td><td style="text-align: left;">描述 XML 文档结构，自己也是 XML语法，功能和 DTD 一样</td></tr></tbody></table><blockquote><p>参考资料：</p><ul><li><a href="https://www.w3school.com.cn/xml/index.asp">XML 教程 |W3school</a></li><li><a href="https://www.w3schools.com/XML/">XML Tutorial |W3Schools</a></li><li><a href="https://linux.cn/article-10515-1.html">技术|XML 与 JSON优劣对比 | Linux中国</a></li><li><a href="https://www.zhihu.com/question/25636060">为什么都反对 XML而支持使用 JSON？ - 知乎</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;XML 光速入门！教程来自 &lt;a
href=&quot;https://www.w3school.com.cn/xml/index.asp&quot;&gt;W3school&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA 生成类和方法注释</title>
    <link href="https://blog.beanbang.cn/2020/02/03/idea-documenting-code/"/>
    <id>https://blog.beanbang.cn/2020/02/03/idea-documenting-code/</id>
    <published>2020-02-03T05:28:07.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA 可以自动生成 Javadoc 格式的注释。</p><span id="more"></span><h2 id="快速补全注释">快速补全注释</h2><p>IntelliJ IDEA提供了自动补全文档格式注释的方法。只要在声明语句的前面打上<code>/**</code> 然后按下回车，IDE就会自动给你补全注释。对于方法的注释，产生的注释片段会包含所需要的标签（每个参数的<code>@param</code>标签、<code>@return</code>、<code>@throws</code>等等）。</p><figure><imgsrc="https://www.z4a.net/images/2020/02/06/IDEA-comment-completion.gif"alt="IDEA 的文档注释补全" /><figcaption aria-hidden="true">IDEA 的文档注释补全</figcaption></figure><blockquote><p>文档格式的注释也支持 JavaScript、Python、Ruby、和 PHP。</p></blockquote><h2 id="使用-fix-doc-comment-动作">使用 Fix doc comment 动作</h2><ol type="1"><li><p>把光标放在一段类，方法，函数或者成员变量中，然后按下<kbd>Ctrl+Shift+A</kbd>。</p></li><li><p>打上 <code>fix doc comment</code> 然后按下回车。</p></li></ol><p>IDEA 就会自动给注释增加上缺失部分的标签。</p><figure><img src="https://www.z4a.net/images/2020/02/06/fix-doc-comment.gif"alt="fix doc comment 动作 | IDEA 帮助文档" /><figcaption aria-hidden="true">fix doc comment 动作 | IDEA帮助文档</figcaption></figure><p>如果一个方法的特征改变了，IDEA会高亮出不匹配部分的标签，然后提出快速修改的建议。</p><h2 id="标签的自动补全">标签的自动补全</h2><p>对于文档注释的标签，IDEA 也提供了代码自动补全。在 <code>@</code>标记的后面按下 <kbd>Ctrl+Space</kbd>，然后就能够从弹出建议的列表里面选择需要的标签了。如果标签包含多个值（比如<code>@param</code>），可以在建议的列表里面继续选择。</p><figure><img src="https://www.z4a.net/images/2020/02/06/tags.gif"alt="标签的补全 | IDEA 帮助文档" /><figcaption aria-hidden="true">标签的补全 | IDEA 帮助文档</figcaption></figure><p>但是 <kbd>Ctrl+Space</kbd>在微软拼音输入法里面是切换中英文的快捷方式，造成冲突而且不能改变……你可以添加一个英语语言，然后按<kbd>Win+Space</kbd>切换到英语键盘来编码。</p><h2 id="有什么好处">有什么好处</h2><p>你一定查过 <ahref="https://docs.oracle.com/en/java/javase/13/docs/api/index.html">Java的 API 文档</a>。这份文档是怎么制作的呢？没错，用的就是 Javadoc格式的注释。查看 JDK的源码，你就能发现这种格式的注释。只要我们按照这种规范来编写注释，就能使用javadoc 工具从代码生成 HTML 文档。</p><p>（文档和代码的耦合性这么高，难道这就是 Java一直没有中文文档的原因……）</p><p>还有一个好处就是，IDEA也会识别这种注释。将光标移动到类名或方法名上，按下<kbd>Ctrl+Q</kbd>，就会弹出气泡提示：</p><figure><img src="https://www.z4a.net/images/2020/02/14/show-quick-doc.png"alt="IDEA 显示快速文档查看气泡" /><figcaption aria-hidden="true">IDEA 显示快速文档查看气泡</figcaption></figure><h2 id="自动气泡提示">自动气泡提示</h2><p>如果要让鼠标移动到类名上自动弹出提示，可以这么做：</p><p>File -&gt; Settings.. -&gt; Editor -&gt; General，找到项目 <em>Showquick documentation on mouse move</em>，勾选上就可以了。</p><figure><imgsrc="https://www.z4a.net/images/2020/02/14/idea-setting-quick-doc.png"alt="设置自动显示气泡提示" /><figcaption aria-hidden="true">设置自动显示气泡提示</figcaption></figure><blockquote><p>参考资料：</p><ul><li><ahref="https://www.jetbrains.com/help/idea/working-with-code-documentation.html">Documentingcode - Help | IntelliJ IDEA</a></li><li><ahref="https://www.jetbrains.com/help/idea/viewing-reference-information.html#inline-quick-documentation">Codereference information - Help | IntelliJ IDEA</a></li><li><a href="https://zh.wikipedia.org/wiki/Javadoc">Javadoc -维基百科，自由的百科全书</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;IDEA 可以自动生成 Javadoc 格式的注释。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Java" scheme="https://blog.beanbang.cn/tags/java/"/>
    
    <category term="IDEA" scheme="https://blog.beanbang.cn/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 72：编辑距离 - 动态规划的解题思路</title>
    <link href="https://blog.beanbang.cn/2020/01/08/leetcode-72-edit-distance/"/>
    <id>https://blog.beanbang.cn/2020/01/08/leetcode-72-edit-distance/</id>
    <published>2020-01-08T02:59:14.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>记录题解，也借这个过程捋一捋动态规划的思路和方法。</p><p>原题目按此：<ahref="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离 -力扣（LeetCode）</a>。</p><span id="more"></span><h2 id="题目描述">题目描述</h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol type="1"><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p>比如 <code>horse</code> 转换到 <code>ros</code> 所需要的最小操作数是<code>3</code>，或者说 <code>horse</code> 到 <code>ros</code> 的距离是<code>3</code>.</p><h2 id="开始">开始</h2><p>能够用动态规划求解的问题通常具有下面的几个特点：</p><ol type="1"><li>让你求某个问题的一个最优解</li><li>这个问题能够拆分成更小的子问题（递归求解/分治法）</li><li>会重复求解相同的子问题</li></ol><p>满足这些条件，这个问题就是一个动态规划问题了。求解问题也是按照这些步骤来进行。</p><p>我们根据《算法导论》上面提供的步骤来。</p><h2 id="刻画一个最优解的结构特征">1. 刻画一个最优解的结构特征</h2><blockquote><p>“如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有<strong>最优子结构性质</strong>。”<ahref="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a></p></blockquote><p>也就是说这一步我们需要正确的划分子问题，让子问题有最优解的时候，原问题也有最优解。想办法找到和原问题形式一样，但是规模比较小的问题。</p><p>所以我们可以考虑，两个字符串的距离，可以由另外两个字符串的距离的基础上，插入/删除/替换了一个字符来得到。</p><p>设置两个指针 i 和 j，分别放在原字符 word1 和替换字符 word2的最后，指针从右往左移，操作 word1[i]，让它和 word2[j]相同。指针经过的地方代表这一部分的字符串已经完成了转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      horse</span><br><span class="line">i:        ↑</span><br><span class="line">   </span><br><span class="line">        ros</span><br><span class="line">j:        ↑</span><br></pre></td></tr></table></figure><p>那么，对每一个字符，这边就以 horse 的 e作为例子，我们能有这么几种操作：</p><p>1 在 e 的右边插入字符 s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">horses</span><br><span class="line">    ↑</span><br><span class="line"></span><br><span class="line">   ros</span><br><span class="line">    ↑</span><br></pre></td></tr></table></figure><p>假如我们知道 <code>horse -&gt; ro</code> 的距离为n，那么总编辑距离就是 n+1。</p><p>2 删除字符 e。接下来需要计算 <code>hors -&gt; ros</code> 的距离。距离+1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hors</span><br><span class="line">   ↑</span><br><span class="line"></span><br><span class="line"> ros</span><br><span class="line">   ↑</span><br></pre></td></tr></table></figure><p>3 把 e 替换成 s。接下来需要计算 <code>hors -&gt; ro</code>的距离。注意，这里如果两个字母相同，就不用转换了，这时候相当于代价为0，直接等价于子问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">horss</span><br><span class="line">   ↑</span><br><span class="line"></span><br><span class="line">  ros</span><br><span class="line">   ↑</span><br></pre></td></tr></table></figure><p>对于这一个字符的修改，相当于是做出了一种选择：我们不知道对这个字符 e怎么处理最终编辑的距离会最短，所以假设每一种可能性都是最优解并且去尝试。通过上面的例子我们发现，子问题中需要求的字符串长度已经缩短了，说明这种方法是可行的。</p><h2 id="递归地定义最优解的值">2. 递归地定义最优解的值</h2><p>设 m[i, j] 表示 word1[0..i] 到 word2[0..j]的距离，几个子问题就可以表示成这样：</p><ul><li><p>当 word1[i] == word2[j] 时，m[i, j] = m[i-1, j-1]；</p></li><li><p>当 word1[i] != word2[j] 时，m[i, j] 可以是：</p><ul><li>m[i, j-1] + 1</li><li>m[i-1, j] + 1</li><li>m[i-1, j-1] +1</li></ul><p>在它们中选距离最短的一个。</p></li></ul><p>因此，我们得到递归公式<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>：</p><p><span class="math display">\[m[i, j]=\left\{\begin{array}{lr}m[i-1, j-1] &amp; w1[i] = w2[j]\\min(m[i, j-1] + 1,\ m[i-1, j] + 1,\ m[i-1, j-1] +1) &amp; w1[i] \neqw2[j]\end{array}\right.\]</span></p><p>因为是递归求解，需要考虑一下递归的终止条件：当 i 或 j 等于 -1时，是空值和字符串之间的转换，显然从空到长度为 n 的字符串的距离就是n。即：</p><ul><li>m[-1, j] = j + 1</li><li>m[i, -1] = i + 1</li></ul><p>再完善一下公式：</p><p><span class="math display">\[m[i, j]=\left\{\begin{array}{lr}j + 1 &amp; i=-1\\i + 1 &amp; j=-1\\m[i-1, j-1] &amp; w1[i] = w2[j]\\min(m[i, j-1] + 1,\ m[i-1, j] + 1,\ m[i-1, j-1] +1) &amp; w1[i] \neqw2[j]\end{array}\right.\]</span></p><p>写出递归式之后，我们已经把一个应用问题转化成了数学问题。接下来就是编程时间，把它转化成代码了😉。</p><h2 id="计算最优解的值">3. 计算最优解的值</h2><h3 id="带备忘的自顶向下">带备忘的自顶向下</h3><p>自顶向下法比较贴近我们的思考方式。它比递归更进一步，会保存每一步的计算结果。这样在需要一个子问题的解之前会先检查是不是已经计算过了，如果是的话就直接使用保存过的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dist;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="title class_">int</span>[l1][l2];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;l1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;l2; j++) &#123;</span><br><span class="line">                dist[i][j] = -<span class="number">1</span>;    <span class="comment">//用 -1 来代表没有计算过的部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> calcDistance(word1, word2, l1-<span class="number">1</span>, l2-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcDistance</span><span class="params">(String w1, String w2, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==-<span class="number">1</span>) <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j==-<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][j]!=-<span class="number">1</span>) <span class="keyword">return</span> dist[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">if</span> (w1.charAt(i)==w2.charAt(j)) &#123;</span><br><span class="line">            res = calcDistance(w1, w2, i-<span class="number">1</span>, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> calcDistance(w1, w2, i, j-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> calcDistance(w1, w2, i-<span class="number">1</span>, j)+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">repl</span> <span class="operator">=</span> calcDistance(w1, w2, i-<span class="number">1</span>, j-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            res = Math.min(Math.min(add, rem), repl);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dist[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用二维数组 <code>dist[][]</code> 来保存计算过的距离，用值<code>-1</code> 表示未计算过的距离。</p><h3 id="自底向上">自底向上</h3><p>自底向上的方法采用的是这么一种思路：先求解规模小的问题，再求解规模大的问题。在求解一个问题的时候，它所依赖的子问题都已经被计算过了。这样的好处在于可以不用使用递归函数调用，也不需要检查子问题是否计算过。</p><img src="/2020/01/08/leetcode-72-edit-distance/dp-table.svg" class="" title="编辑距离表格" alt="编辑距离表格"><p>这张表是 <code>horse -&gt; ros</code>每个长度编辑距离的表格，和上面自顶向下代码中的 <code>dist</code>数组存储的数据差不多，多了一行一列的边界值，也就是终止条件的情况。应该能够很直观地看到，表格中的每一个值（m[i,j]），所依赖三个子问题都在它的左边、上面和左上角。只要按照一定顺序计算，就能生成整张表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=l1; i++)</span><br><span class="line">            dist[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=l2; j++) &#123;</span><br><span class="line">            dist[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dist[i][j] = dist[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> dist[i][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> dist[i-<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">repl</span> <span class="operator">=</span> dist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    dist[i][j] = Math.min(repl, Math.min(rem, add));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dist[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用计算出的信息构造一个最优解">4.利用计算出的信息构造一个最优解</h2><p>让我们更进一步！</p><p>到上面为止，对于解答问题——得到单词间的最小距离，已经完成了。但是假如我们想要知道具体的每一步应该怎么编辑字符，该怎么做呢？我们可以对代码稍加修改，使每一个问题不仅保存最优解的值，还把相应的操作保存下来。</p><p>另外定义一个二维数组 <code>act[][]</code> 来储存操作，用值 0~3来表示跳过、插入、删除和替换的操作，在找到最短距离的同时顺便记录下对应的操作，就能得到一张操作表。</p><img src="/2020/01/08/leetcode-72-edit-distance/dp-operation.svg" class="" alt="编辑操作表格"><p>假如 <code>act[i][j]</code> 当前的值是 2，代表删除，那么就删除word1[i] 的字符，然后往上移，寻找<code>act[i-1][j]</code>，以此类推。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOperations</span><span class="params">(<span class="type">int</span>[][] act,<span class="type">int</span> i,<span class="type">int</span> j, String w1, String w2)</span> &#123;</span><br><span class="line">    System.out.println(w1 + <span class="string">&quot; -&gt; &quot;</span> + w2 + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i!=<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>) &#123;</span><br><span class="line">        String tmp;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (act[i][j]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//s = &quot;(跳过)\n&quot;;</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            tmp = w1.substring(<span class="number">0</span>, i) + w2.charAt(j-<span class="number">1</span>) + w1.substring(i+<span class="number">1</span>);</span><br><span class="line">            s = String.format(<span class="string">&quot;%s -&gt; %s (插入 &#x27;%c&#x27;)\n&quot;</span>, w1, tmp, w2.charAt(j-<span class="number">1</span>));</span><br><span class="line">            w1 = tmp;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            tmp = w1.substring(<span class="number">0</span>, i-<span class="number">1</span>) + w1.substring(i);</span><br><span class="line">            s = String.format(<span class="string">&quot;%s -&gt; %s (删除 &#x27;%c&#x27;)\n&quot;</span>, w1, tmp, w1.charAt(i-<span class="number">1</span>));</span><br><span class="line">            w1 = tmp;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            tmp = w1.substring(<span class="number">0</span>, i-<span class="number">1</span>) + w2.charAt(j-<span class="number">1</span>) + w1.substring(i);</span><br><span class="line">            s = String.format(<span class="string">&quot;%s -&gt; %s (将 &#x27;%c&#x27; 替换为 &#x27;%c&#x27;)\n&quot;</span>,</span><br><span class="line">                    w1, tmp, w1.charAt(i-<span class="number">1</span>), w2.charAt(j-<span class="number">1</span>));</span><br><span class="line">            w1 = tmp;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">horse -&gt; ros:</span><br><span class="line">horse -&gt; hors (删除 &#x27;e&#x27;)</span><br><span class="line">hors -&gt; hos (删除 &#x27;r&#x27;)</span><br><span class="line">hos -&gt; ros (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line"></span><br><span class="line">intention -&gt; execution:</span><br><span class="line">intention -&gt; intenuion (插入 &#x27;u&#x27;)</span><br><span class="line">intenuion -&gt; intecuion (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">intecuion -&gt; inecuion (删除 &#x27;t&#x27;)</span><br><span class="line">inecuion -&gt; ixecuion (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">ixecuion -&gt; execuion (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line"></span><br><span class="line">consistent -&gt; constraint:</span><br><span class="line">consistent -&gt; consistint (将 &#x27;e&#x27; 替换为 &#x27;i&#x27;)</span><br><span class="line">consistint -&gt; consisaint (将 &#x27;t&#x27; 替换为 &#x27;a&#x27;)</span><br><span class="line">consisaint -&gt; consiraint (将 &#x27;s&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">consiraint -&gt; constraint (将 &#x27;i&#x27; 替换为 &#x27;t&#x27;)</span><br></pre></td></tr></table></figure><p>完整代码：<ahref="https://gist.github.com/Lazyb0x/9333fbea653627b4348743722e82ddf4">这里</a>。</p><p>希望能对你有所帮助。</p><hr /><blockquote><p>参见：</p><ul><li><ahref="https://book.douban.com/subject/20432061/">《算法导论》</a></li><li><ahref="https://zhuanlan.zhihu.com/p/80682302">详解一道经典面试题：编辑距离- 知乎</a></li><li><ahref="https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/">自底向上和自顶向下 - 编辑距离 - 力扣（LeetCode）</a></li></ul></blockquote><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>《算法导论（原书第3版）》，（美）科尔曼（Cormen, T.H.）等著；殷建平等译，机械工业出版社，2013.1，15.3章动态规划原理，P216。<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><liid="fn2"><p>递归公式，也叫状态转移方程。注意不是“递推”，递归是自顶向下的，而递推是自底向上的。<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录题解，也借这个过程捋一捋动态规划的思路和方法。&lt;/p&gt;
&lt;p&gt;原题目按此：&lt;a
href=&quot;https://leetcode-cn.com/problems/edit-distance/&quot;&gt;72. 编辑距离 -
力扣（LeetCode）&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="算法" scheme="https://blog.beanbang.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安装配置笔记</title>
    <link href="https://blog.beanbang.cn/2019/12/28/hexo-configuration/"/>
    <id>https://blog.beanbang.cn/2019/12/28/hexo-configuration/</id>
    <published>2019-12-28T09:01:06.000Z</published>
    <updated>2022-09-13T12:30:27.994Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Hexo 的安装过程（踩过的坑）。</p><p>是的，我从 WordPress 转移到了 Hexo……</p><span id="more"></span><p>相比于功能庞大的 WordPress，小巧简单的静态网页生成器有它的特点：</p><ul><li>不需要 SQL 数据库 <del>（再也不用备份数据库了）</del></li><li>没有后台管理，直接编辑文章和配置文件<del>（再也不怕忘记管理员密码了）</del></li><li>生成的是静态网页，不仅可以部署在 VPS 上，还可以托管在 GitHub Pages等平台</li><li>本质是 Markdown 解析器，自然地对 Markdown 支持相当好</li></ul><p>如果你像我一样，习惯用 Markdown 来记笔记、写日志，那么使用Hexo、Hugo、Jekyll 这类生成器是最好不过了。它们直接使用 md文件来渲染网页，把一篇写好的笔记转换成可以公开的博客不需要任何的格式转换操作。这种所见即所得的写作方式，相信你一定会喜欢上的~</p><h2 id="安装-hexo">安装 Hexo</h2><p>文档：https://hexo.io/zh-cn/docs/</p><p>GitHub: https://github.com/hexojs/hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="本地图片显问题">本地图片显问题</h3><p>在 <code>_config.yml</code> 文件里面把 <code>post_asset_folder</code>设置为 <code>true</code>。</p><p>安装 hexo-asset-image 插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>文章中插入图片：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% asset_img "span>" '"" "<span class="string">图片</span>"' %}</span><br></pre></td></tr></table></figure><p>这样在 Markdown编辑器里面能看到同名文件夹的图片，生成的静态网页也能显示图片。</p><h3 id="front-matter">Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 安装配置笔记</span><br><span class="line">date: 2019-12-28 17:01:06</span><br><span class="line">categories:</span><br><span class="line">  - 日志</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - 博客</span><br><span class="line">permalink: hexo-configuration</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在文章最开始的几行字。用来标识标题和日期。其中一个很有用的就是<code>permalink</code>。静态网页会根据它的值来设置文章的URL。这样一来，md 文件的名字就可以随便取了。</p><p>20220913 更新：新版的 <code>permalink</code> 含义似乎变了，会替换整个URL，包括日期前缀。需要自定义变量来实现，可以看下<ahref="https://hexo.io/zh-cn/docs/permalinks">文档</a>。</p><h3 id="分类和标签">分类和标签</h3><p>在文章的 front-matter中指定了标签和分类，那么在生成网页后，就有了对应的页面。</p><p>比如 <code>categories: 日志</code>，就会生成<code>/categories/日志</code>。</p><p>如果不想在 URL里面显示中文，可以自定义标签和分类的路径，在配置文件里面这么写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">日志:</span> <span class="string">log</span></span><br><span class="line">  <span class="string">软件:</span> <span class="string">software</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line">  <span class="string">反向代理:</span> <span class="string">reverse-proxy</span></span><br><span class="line">  <span class="string">安全:</span> <span class="string">security</span></span><br><span class="line">  <span class="string">无线:</span> <span class="string">wireless</span></span><br></pre></td></tr></table></figure><h3 id="归档和标签的分页">归档和标签的分页</h3><p>归档页面应该让人一眼看到所有文章，但是 Hexo默认会将它按数量分成页面显示，看起来很不直观。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="comment"># 设置首页分页之前默认就有，这里就不额外加了</span></span><br><span class="line"><span class="comment"># index_generator:</span></span><br><span class="line"><span class="comment">#   per_page: 5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">archive_generator:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">0</span>  <span class="comment">#值为0表示不分页，按需填写</span></span><br><span class="line">  <span class="attr">yearly:</span> <span class="literal">true</span>  <span class="comment">#是否按年生成归档</span></span><br><span class="line">  <span class="attr">monthly:</span> <span class="literal">false</span>  <span class="comment">#为了加快生成速度，按月归档就不要了</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tag_generator:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">0</span>  <span class="comment">#值为0表示不分页，按需填写</span></span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://sobaigu.com/hexo-archives-show-all-in-one-page.html">Hexo博客归档不分页显示设置方法| 搜百谷</a></p></blockquote><h3 id="站点地图">站点地图</h3><p>使用站点地图来方便被收索引擎收录。</p><p>GitHub:https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure><h3 id="rss">RSS</h3><p>添加 RSS 订阅。</p><p>GitHub: https://github.com/hexojs/hexo-generator-feed</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>我的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="comment"># hexo-generator-feed</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">atom</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rss2</span></span><br><span class="line">  <span class="attr">path:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">feed.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.ico</span></span><br></pre></td></tr></table></figure><h3 id="不渲染特定文件">不渲染特定文件</h3><p>hexo 会把所有 md 和 html文件渲染成主题的样式，但是这又是不是我们想要的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;**/*.html&quot;</span></span><br></pre></td></tr></table></figure><p><code>**/*.html</code> 可以使它跳过渲染目录下的所有 html 文件。</p><h2 id="next-主题">NexT 主题</h2><p>文档：https://theme-next.org/docs/</p><p>GitHub: https://github.com/theme-next/hexo-theme-next</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="pjax">PJAX</h3><p>Pjax 即 HTML5 的 pushState +Ajax。这个技术通过异步加载和更改浏览器地址栏实现了无刷新加载网页。由于只加载部分页面，减少了请求的次数和内容，打开网页将会很快。</p><p>安装插件 theme-next-pjax：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure><p>然后开启 NexT 的 Pjax：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是启用 pjax 以后添加自定义的 js 控件将会变得比较困难。</p><h3 id="关闭动画">关闭动画</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>NexT默认是开启动画的，就是打开网页时的淡入效果。结果就是让读者晚一秒种看到正文内容……有什么用呢？关了关了。</p><h3 id="菜单启用分类和标签">菜单启用分类和标签</h3><p>新建一个页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>然后编辑这个文件的 Front-matter：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-12-30 16:54:16</span><br><span class="line">type: categories</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>配置文件里面去掉 <code>categories</code> 项的注释：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br></pre></td></tr></table></figure><p>启用标签菜单同理。</p><h3 id="评论系统">评论系统</h3><p>主题提供了很多可选的评论系统。我选了 <ahref="https://valine.js.org">Valine</a>，一个基于服务商 Leancode的评论系统。</p><p>使用之前要去 <a href="https://leancloud.cn/">Leancloud</a>注册和创建应用，然后再设置 -&gt; 应用 Keys 里面，获得应用的<code>AppID</code> 和 <code>AppKey</code>，写到 NexT的配置文件里面去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">53p6sFAYCBY1FfEX9nOa3byP-gzGzoHsz</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">V6tCmUsramFioGA0GbBETOLR</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">（っ╹◡╹）ﾉ❀</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure><p>比较重要的就是 <code>comment_count</code> 参数，设置为<code>false</code> 来让评论数不在首页显示（postmeta），只在文章页面显示。</p><h3 id="latex">LaTeX</h3><p>写公式必备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pandoc</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>启用 pandoc 之后图片会有描述，和 fancybox插件显示重复，改一下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* source/_data/styles.styl */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pandoc */</span></span><br><span class="line"><span class="selector-tag">figure</span> <span class="selector-tag">figcaption</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fancybox */</span></span><br><span class="line"><span class="selector-class">.image-caption</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># style 这一行取消注释</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># 设置为 false 需要在要渲染的文章的 Front-matter 里面加上 `mathjax: true`</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>因为 pandoc渲染器的语法要求比较严格，所以在安装完之后记得要检查一下以前写过的文章，可能会有所变化。</p><h3 id="搜索">搜索</h3><p>启用 Hexo 的本地搜索功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>静态博客怎么搜索呢？安装这个插件后，生成了一个<code>search.xml</code>，里面包含了博客里面的全部文本。搜索的时候会加载这个文件进行查找。</p><blockquote><p>参见：</p><ul><li><ahref="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">hexo中完美插入本地图片| ETRD博客</a></li><li><ahref="https://linlif.github.io/2017/05/27/Hexo使用攻略-添加分类及标签/">Hexo使用攻略-添加分类及标签| linlif-blog</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML语言教程 - 阮一峰的网络日志</a></li><li><ahref="https://ijiaober.github.io/2014/08/05/hexo/hexo-04/">Hexo使用攻略：（四）Hexo的分类和标签设置| { GoonX }</a></li><li><ahref="https://bluelzy.com/articles/use_valine_for_your_blog.html">为你的Hexo加上评论系统-Valine| BlueLzy's Blog</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录 Hexo 的安装过程（踩过的坑）。&lt;/p&gt;
&lt;p&gt;是的，我从 WordPress 转移到了 Hexo……&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Hexo" scheme="https://blog.beanbang.cn/tags/hexo/"/>
    
    <category term="博客" scheme="https://blog.beanbang.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>利用 mDNS 协议来定位局域网主机</title>
    <link href="https://blog.beanbang.cn/2019/08/07/locate-hosts-using-mdns/"/>
    <id>https://blog.beanbang.cn/2019/08/07/locate-hosts-using-mdns/</id>
    <published>2019-08-07T09:36:53.000Z</published>
    <updated>2023-06-15T11:27:43.050Z</updated>
    
    <content type="html"><![CDATA[<p>再也不用费劲去找树莓派的 IP地址了！你的操作系统自带了“网络发现”功能。</p><span id="more"></span><p>在一个平常的局域网（开启了 DHCP）下面，获得一台主机的 IP地址常常有这么几种方法：</p><ol type="1"><li>用 <code>arp -a</code> 命令查询 arp 缓存；</li><li>在目标主机上查找本机的 IP 地址，使用例如 <code>ipconfig</code>命令；</li><li>浏览器登录路由器的后台，从连接的主机列表中查找；</li><li>给目标主机设置静态IP。</li></ol><p>不久之前，我一直用上面的方法来连接我的树莓派。树莓派没接显示器，没办法在主机上操作，每次要么使用手机热点（设备管理里面能显示IP），要么直接改配置分配静态IP。这些方法都有局限性，网络环境一变化，又得配置半天。</p><p>现在，一个新的方法出现了！（其实一直就有）只要知道你的设备的主机名，你就可以得到你的设备的IP 地址。例如，我的树莓派是 Raspbian 系统，它的默认主机名是<code>raspberrypi</code>，就可以通过域名 <code>raspberrypi.local</code>来连接，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@raspberrypi.local</span><br></pre></td></tr></table></figure><p>这就是 mDNS （Multicast DNS）协议给我们提供的便利。</p><h2 id="偶然的发现">偶然的发现</h2><p>在研究 IGMP 协议的时候，我用 Wireshark 对无线网卡抓取 IGMP数据包，想看看有没有什么服务是在使用组播（Multicast）地址的。</p><figure><img src="https://www.z4a.net/images/2019/08/07/wireshark-mdns.png"alt="Wireshark软件截图" /><figcaption aria-hidden="true">Wireshark软件截图</figcaption></figure><p>之后我看到了局域网内的电脑基本上都会加入这几个组播地址：<code>224.0.0.251</code>，<code>224.0.0.252</code>，<code>239.255.255.250</code>。</p><p>经过查找，这三个组播地址分别是协议 mDNS，LLMNR 和 SSDP协议的。mDNS实现了类似 DNS的功能，使得主机在局域网内能够加入和通信；LLMNR 的功能和 mDNS 类似；SSDP是 UPnP 协议的一部分，也是用来实现设备和服务的发现的。</p><p>在一段 mDNS 报文中，我看到了这样的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Multicast Domain Name System (response)</span><br><span class="line">    [Request In: 172]</span><br><span class="line">    [Time: 0.205589000 seconds]</span><br><span class="line">    Transaction ID: 0x0000</span><br><span class="line">    Flags: 0x8400 Standard query response, No error</span><br><span class="line">    Questions: 0</span><br><span class="line">    Answer RRs: 4</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Answers</span><br><span class="line">        9.c.4.3.e.b.a.3.5.6.5.3.2.8.e.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa: type PTR, class IN, cache flush, raspberrypi.local</span><br><span class="line">        raspberrypi.local: type A, class IN, cache flush, addr 192.168.10.108</span><br><span class="line">        108.10.168.192.in-addr.arpa: type PTR, class IN, cache flush, raspberrypi.local</span><br><span class="line">        raspberrypi.local: type AAAA, class IN, cache flush, addr fe80::e82:3565:3abe:34c9</span><br></pre></td></tr></table></figure><p>来源是 <code>192.168.10.108</code>，目的是 <code>224.0.0.251</code>。返回的记录中有我的树莓派的 IPv4 和 IPv6 地址，以及一个相同的字段<code>raspberrypi.local</code>。</p><p>难道说 <code>raspberrypi.local</code> 就是我树莓派的域名？我立马 ping了一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PS C:\WINDOWS\system32&gt; ping raspberrypi.local</span><br><span class="line"></span><br><span class="line">正在 Ping raspberrypi.local [fe80::e82:3565:3abe:34c9%13] 具有 32 字节的数据:</span><br><span class="line">来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=5ms</span><br><span class="line">来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=2ms</span><br><span class="line">来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=4ms</span><br><span class="line">来自 fe80::e82:3565:3abe:34c9%13 的回复: 时间=5ms</span><br><span class="line"></span><br><span class="line">fe80::e82:3565:3abe:34c9%13 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 2ms，最长 = 5ms，平均 = 4ms</span><br><span class="line">PS C:\WINDOWS\system32&gt; ping raspberrypi.local -4</span><br><span class="line"></span><br><span class="line">正在 Ping raspberrypi [192.168.10.109] 具有 32 字节的数据:</span><br><span class="line">来自 192.168.10.109 的回复: 字节=32 时间=2ms TTL=64</span><br><span class="line">来自 192.168.10.109 的回复: 字节=32 时间=1ms TTL=64</span><br><span class="line">来自 192.168.10.109 的回复: 字节=32 时间=2ms TTL=64</span><br><span class="line">来自 192.168.10.109 的回复: 字节=32 时间=3ms TTL=64</span><br><span class="line"></span><br><span class="line">192.168.10.109 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 1ms，最长 = 3ms，平均 = 2ms</span><br></pre></td></tr></table></figure><p>确实可以。我流下了激动的泪水：这么好的东西怎么没早发现呢！</p><h2 id="mdns-查询过程">mDNS 查询过程</h2><p>通过分析抓包数据，mDNS 协议在局域网内的 IP地址查询过程大致是这样的：</p><p>A：发起查询的主机</p><p>B：被查询的主机</p><ol type="1"><li>A，B 在加入网络时都会发 IGMP 报文加入组<code>224.0.0.251</code>；</li><li>A 向组 <code>224.0.0.251</code> 发送 mDNS 组播报文查询 B的主机名，所有在组内的主机都会收到这个查询请求；</li><li>B 向组 <code>224.0.0.251</code> 发送回应 mDNS报文，内容包括自己的主机名和 IP 地址；</li><li>A 得到 B 的 IP 地址。</li></ol><p>其中，mDNS 报文是包装在 UDP 组播报文中的，使用 <code>5353</code>端口。</p><h2 id="主机名的查询和修改">主机名的查询和修改</h2><p>Windows 系统的主机名在环境变量 <code>COMPUTERNAME</code>查看，可以在系统设置中修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %COMPUTERNAME%</span><br></pre></td></tr></table></figure><figure><img src="https://www.z4a.net/images/2019/08/07/computername.png"alt="Windows更改主机名" /><figcaption aria-hidden="true">Windows更改主机名</figcaption></figure><p>Linux 系统主机名存在 <code>/etc/hostname</code> 中。使用<code>hostnamectl</code> 可以查询和修改。<code>/etc/hosts</code>里也有主机名的记录，也要一并修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询主机名</span></span><br><span class="line">hostname</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时更改，重启失效</span></span><br><span class="line">sudo hostname &lt;newhostname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hostnamectl只更改/etc/hostname，记得改/etc/hosts</span></span><br><span class="line">sudo hostnamectl set-hostname &lt;newhostname&gt;</span><br></pre></td></tr></table></figure><h2 id="我的系统支持吗">我的系统支持吗</h2><p>Windows 10 以后，系统就能够支持 mDNS 协议了。Windows 10以下的系统怎么办？你可以：</p><ol type="1"><li><p>给 Windows 安装苹果公司的 <ahref="https://support.apple.com/kb/DL999">Bonjour</a>，只有 5 Mb大小，推荐。</p></li><li><p>使用 NetBIOS 协议，这是微软的网络发现服务。Linux 系统上安装<code>samba</code>，它的 <code>nmbd</code> 服务使得能被 Windows主机发现。使用方法：</p><ul><li>Windows上：主机名即为域名。主机名是 raspberrypi，直接<code>ping raspberrypi</code>。</li><li>Linux上：默认不解析 NetBIOS 主机名，使用<code>nmblookup 主机名</code> 来得到 Windows 主机 IP。如果要实现解析NetBIOS 主机名，需要修改配置文件，没折腾了，看这篇文章 -&gt; <ahref="https://shazi.info/%E5%9C%A8-linux-%E8%A7%A3%E6%9E%90-netbios-%E5%90%8D%E7%A8%B1/">在Linux 解析 Netbios 名稱</a>。</li></ul></li></ol><p>Linux 一般是安装了 <code>avahi-daemon</code> 服务。使用指令<code>systemctl status avahi-daemon.service</code>来查看服务运行状态。</p><figure><img src="https://www.z4a.net/images/2019/08/07/avahi-daemon.png"alt="avahi-daemon" /><figcaption aria-hidden="true">avahi-daemon</figcaption></figure><p>安卓系统似乎不支持，我的华为手机没有。</p><p>还可以查询 UDP 5353 端口。</p><p>Windows：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 5353</span><br></pre></td></tr></table></figure><p>Linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -nap | grep 5353</span><br></pre></td></tr></table></figure><p>其实最简单的就是 ping 一下 主机名.local 看看有没有就知道了。</p><blockquote><p>参见：</p><ul><li><ahref="https://blog.csdn.net/u013991521/article/details/80522269">3种方法更改Linux系统的主机名(hostname)- ZhangYaohui专栏 - CSDN博客</a></li><li><a href="https://linux.cn/article-10043-1.html">技术|使用 mDNS在局域网中轻松发现系统</a></li><li><a href="https://www.eiman.tv/blog/posts/lannames/">LLMNR, MulticastDNS and names on your LAN</a></li><li><a href="https://en.wikipedia.org/wiki/Multicast_DNS">Multicast DNS- Wikipedia</a></li><li><ahref="https://stackoverflow.com/questions/23624525/standard-mdns-service-on-windows">StandardmDNS service on Windows - Stack Overflow</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;再也不用费劲去找树莓派的 IP
地址了！你的操作系统自带了“网络发现”功能。&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="Windows" scheme="https://blog.beanbang.cn/tags/windows/"/>
    
    <category term="Linux" scheme="https://blog.beanbang.cn/tags/linux/"/>
    
    <category term="系统" scheme="https://blog.beanbang.cn/tags/os/"/>
    
    <category term="树莓派" scheme="https://blog.beanbang.cn/tags/raspberry-pi/"/>
    
    <category term="网络" scheme="https://blog.beanbang.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾日记 二：网络相关配置</title>
    <link href="https://blog.beanbang.cn/2019/05/17/raspberry-diary-02-network-configure/"/>
    <id>https://blog.beanbang.cn/2019/05/17/raspberry-diary-02-network-configure/</id>
    <published>2019-05-17T13:00:03.000Z</published>
    <updated>2022-09-10T10:15:27.884Z</updated>
    
    <content type="html"><![CDATA[<p>主要是解决两个问题：</p><ol type="1"><li>同时连接两个网络时由于默认网卡不对导致不能上网；</li><li>开机的时候等n久都连不上 WiFi，但是一插上网线，WiFi 就通了。</li></ol><span id="more"></span><h2 id="wifi-相关">WiFi 相关</h2><h3 id="查看和连接">查看和连接</h3><p>查找附近的无线网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo iwlist wlan0 scan</span><br><span class="line">sudo iwlist wlan0 scan | grep &quot;ESSID&quot;</span><br></pre></td></tr></table></figure><p>查看当前的 WiFi 网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iwgetid</span><br><span class="line">iwconfig</span><br></pre></td></tr></table></figure><p>编辑连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;abc&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=17</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 reconfigure</span><br></pre></td></tr></table></figure><h3 id="开关-wifi">开关 WiFi</h3><p>临时开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig wlan0 down</span><br><span class="line">sudo ifconfig wlan0 up</span><br></pre></td></tr></table></figure><p>永久关闭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;dtoverlay=pi3-disable-wifi&quot; | sudo tee -a /boot/config.txt</span><br></pre></td></tr></table></figure><p>其他开关（蓝牙）：</p><blockquote><p><ahref="https://blog.sleeplessbeastie.eu/2018/12/31/how-to-disable-onboard-wifi-and-bluetooth-on-raspberry-pi-3/">Howto disable onboard WiFi and Bluetooth on Raspberry Pi 3</a></p></blockquote><h2 id="静态-ip">静态 IP</h2><p>第一次连接树莓派的时候为了确定 ip 可能会将 ip=xxxx 的信息写在<code>/boot/cmdline.txt</code> 里面，不过后期要用静态 IP的时候不建议这么写，否则树莓派在启动的时候为了连接有线网络会等待很长时间。如果仍要设置静态IP ，这么配置比较好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/dhcpcd.conf</span><br></pre></td></tr></table></figure><p>在最后添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface eth0                                  #网络名</span><br><span class="line">static ip_address=172.31.31.35/26               #ipv4地址 / 网络前缀</span><br><span class="line">#static ip6_address=fd51:42f8:caae:d92e::ff/64  #ipv6</span><br><span class="line">static routers=172.31.0.1                       #网关</span><br><span class="line">tatic domain_name_servers=202.99.166.4 8.8.8.8  #DNS域名解析服务器</span><br></pre></td></tr></table></figure><p>它的网络配置和其他的有些不同，dhcpcd 用的不是子网掩码，而是 CIDR的斜线记法，两者之间需要稍微换算一下。比如 ip 地址192.168.191.1，子网掩码 255.255.255.0，就可以记为<code>192.168.191.1/24</code>。</p><p>为什么不去编辑<code>/etc/network/interfaces</code>呢？在我这个版本（2018-04-18-raspbian-stretch）中<code>interfaces</code> 里面说静态 IP 得去 <code>dhcpcd.conf</code>里面配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line"></span><br><span class="line"># Please note that this file is written to be used with dhcpcd</span><br><span class="line"># For static IP, consult /etc/dhcpcd.conf and &#x27;man dhcpcd.conf&#x27;</span><br><span class="line"></span><br><span class="line"># Include files from /etc/network/interfaces.d:</span><br><span class="line">source-directory /etc/network/interfaces.d</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://raspberrypi.stackexchange.com/questions/32516/multiple-ip-addresses-being-assigned">raspbian- Multiple IP addresses being assigned - Raspberry Pi StackExchange</a></p></blockquote><h2 id="路由选择网卡上网">路由选择网卡上网</h2><p>我的网线走的是联通的个人网，需要设置 Netkeeper才能上网。所以为了给树莓派联网，我只能用手机或电脑开热点。但是在同时连接网线和WiFi的时候，树莓派上不了网，只有拔掉网线之后，树莓派才能打开网页。</p><p>不仅仅是树莓派，我装在电脑上的 Ubuntu也是这样，每次上网总得拔掉网线，再连wifi，很麻烦。</p><p>上过组网课后今天再次想到这个问题，这应该和路由协议有关。查看路由表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         172.31.0.1      0.0.0.0         UG    202    0        0 eth0</span><br><span class="line">default         192.168.191.1   0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">172.31.0.1      0.0.0.0         255.255.255.255 UH    202    0        0 eth0</span><br><span class="line">172.31.31.0     0.0.0.0         255.255.255.192 U     202    0        0 eth0</span><br><span class="line">192.168.191.0   0.0.0.0         255.255.255.0   U     303    0        0 wlan0</span><br></pre></td></tr></table></figure><p>发现默认路由 <code>default</code>（有时候显示为<code>0.0.0.0</code>）转发的网关有两个，一个是<code>eth0</code> （网线）的 <code>172.31.0.1</code> ，一个是<code>wlan0</code> （WiFi）的 <code>192.168.191.1</code> 。由于 eth0排在 wlan0的前面，发给因特网的请求会转发给网关，然后联通把数据包吞了。看下面的ping 测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ping -c 4 baidu.com</span><br><span class="line">PING baidu.com (123.125.114.144) 56(84) bytes of data.</span><br><span class="line">From 172.31.31.35 icmp_seq=1 Destination Host Unreachable</span><br><span class="line">From 172.31.31.35 icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 172.31.31.35 icmp_seq=3 Destination Host Unreachable</span><br><span class="line">From 172.31.31.35 icmp_seq=4 Destination Host Unreachable</span><br><span class="line"></span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 23107ms</span><br><span class="line">pipe 4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然 <code>172.31.0.1</code> 的路由转发记录无效，不妨把它删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo route del default gw 172.31.0.1 eth0</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.191.1   0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">172.31.0.1      0.0.0.0         255.255.255.255 UH    202    0        0 eth0</span><br><span class="line">172.31.31.0     0.0.0.0         255.255.255.192 U     202    0        0 eth0</span><br><span class="line">192.168.191.0   0.0.0.0         255.255.255.0   U     303    0        0 wlan0</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ ping -c 4 baidu.com</span><br><span class="line">PING baidu.com (220.181.57.216) 56(84) bytes of data.</span><br><span class="line">64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=1 ttl=53 time=13.7 ms</span><br><span class="line">64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=2 ttl=53 time=15.0 ms</span><br><span class="line">64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=3 ttl=53 time=17.6 ms</span><br><span class="line">64 bytes from 220.181.57.216 (220.181.57.216): icmp_seq=4 ttl=53 time=16.7 ms</span><br><span class="line"></span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3004ms</span><br><span class="line">rtt min/avg/max/mdev = 13.730/15.800/17.656/1.515 ms</span><br></pre></td></tr></table></figure><p>移除完这条记录，地址就能够正常解析了，百度也 ping得通了。所以原因在于<strong>存在多个默认网关，并且那个首选的网关是不可到达的</strong>。重启系统或网络后路由表就会恢复，可以把它当作一个临时的做法。如果要永久生效的话也有办法的，我就没折腾了，文末的参考连接里面有。</p><p>回头一看，上一篇树莓派日记已经是快一年前的事情了……惭愧，或许叫吃灰日记比较好（</p><blockquote><p>参考资料：</p><ul><li><ahref="http://cn.linux.vbird.org/linux_server/0230router.php#routing_double">鸟哥的Linux 私房菜 -- 架设 Router</a></li><li><ahref="https://blog.csdn.net/u011857683/article/details/83795435">linuxroute命令的使用详解 - 一个人的旅行的博客 - CSDN博客</a></li><li><ahref="https://blog.csdn.net/autoliuweijie/article/details/80263110">双网卡服务器选择默认路由- Avalon - CSDN博客</a></li><li><ahref="https://www.cnblogs.com/haochuang/p/7071075.html">【树莓派】双网卡添加多路由静态路由持久化的问题处理- 念槐聚 - 博客园</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要是解决两个问题：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;同时连接两个网络时由于默认网卡不对导致不能上网；&lt;/li&gt;
&lt;li&gt;开机的时候等n久都连不上 WiFi，但是一插上网线，WiFi 就通了。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="Linux" scheme="https://blog.beanbang.cn/tags/linux/"/>
    
    <category term="树莓派" scheme="https://blog.beanbang.cn/tags/raspberry-pi/"/>
    
    <category term="网络" scheme="https://blog.beanbang.cn/tags/network/"/>
    
    <category term="无线" scheme="https://blog.beanbang.cn/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 11：盛最多水的容器 双指针法的证明</title>
    <link href="https://blog.beanbang.cn/2019/05/05/leetcode-11-two-pointer-approach/"/>
    <id>https://blog.beanbang.cn/2019/05/05/leetcode-11-two-pointer-approach/</id>
    <published>2019-05-05T13:42:24.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>翻译一篇双指针法的证明，来自 Leetcode 主站 kongweihan 的<ahref="https://leetcode.com/problems/container-with-most-water/discuss/6099/yet-another-way-to-see-what-happens-in-the-on-algorithm">评论</a>。</p><p>原问题按此：<ahref="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器- 力扣（LeetCode）</a>。</p><span id="more"></span><figure><img src="https://www.z4a.net/images/2019/05/05/question_11.jpg"alt="leetcode_question_11" /><figcaption aria-hidden="true">leetcode_question_11</figcaption></figure><hr /><p>这是用矩阵来表示的另一种方法：</p><p>画一个矩阵，它的行表示第一条线段，列表示第二条线段。用<code>n=6</code> 的情况做个例子。</p><p>在下图中，<code>x</code>表示我们不需要计算的面积，因为：（1）对角线上的值，代表两条线重叠了；（2）矩阵左下角三角形区域和右上角是对称的。</p><p>我们从 <code>(1,6)</code> 开始来计算面积，用 <code>o</code>来表示。现在，如果左边的线段比右边的短，那么在第一行的除<code>(1,6)</code>外的所有元素的面积都小于（等于）它。所以对于这些情况我们就不需要计算它们的值了（用<code>---</code> 划掉 ）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  1 2 3 4 5 6</span><br><span class="line">1 x ------- o</span><br><span class="line">2 x x</span><br><span class="line">3 x x x </span><br><span class="line">4 x x x x</span><br><span class="line">5 x x x x x</span><br><span class="line">6 x x x x x x</span><br></pre></td></tr></table></figure><p>然后我们移动左边的线段，计算<code>(2,6)</code>。现在，如果右边的线段短一些，所有低于<code>(2,6)</code> 的情况都可以排除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  1 2 3 4 5 6</span><br><span class="line">1 x ------- o</span><br><span class="line">2 x x       o</span><br><span class="line">3 x x x     |</span><br><span class="line">4 x x x x   |</span><br><span class="line">5 x x x x x |</span><br><span class="line">6 x x x x x x</span><br></pre></td></tr></table></figure><p>无论这条 <code>o</code>的路径是怎样的，我们最终只要找到这条路径上最大的数值就可以了，而这需要<code>n-1</code> 步计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  1 2 3 4 5 6</span><br><span class="line">1 x ------- o</span><br><span class="line">2 x x - o o o</span><br><span class="line">3 x x x o | |</span><br><span class="line">4 x x x x | |</span><br><span class="line">5 x x x x x |</span><br><span class="line">6 x x x x x x</span><br></pre></td></tr></table></figure><p>希望对你有所帮助。用这种方式来看我觉得舒服多了。</p><hr /><p>下面是我参考题解写的。真的很难想到，这题能用复杂度为 O(n)的方法解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q010.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        max = Math.max(max, Math.min(height[l], height[r])*(r-l));</span><br><span class="line">        <span class="keyword">if</span> (height[l]&lt;height[r]) l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Q010</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Solution10</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution10</span>();</span><br><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.maxArea(a);</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;翻译一篇双指针法的证明，来自 Leetcode 主站 kongweihan 的&lt;a
href=&quot;https://leetcode.com/problems/container-with-most-water/discuss/6099/yet-another-way-to-see-what-happens-in-the-on-algorithm&quot;&gt;评论&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原问题按此：&lt;a
href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;盛最多水的容器
- 力扣（LeetCode）&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="算法" scheme="https://blog.beanbang.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>1809坑：多余显示器，桌面变卡</title>
    <link href="https://blog.beanbang.cn/2019/02/25/1809-hyper-v-bug/"/>
    <id>https://blog.beanbang.cn/2019/02/25/1809-hyper-v-bug/</id>
    <published>2019-02-25T05:05:12.000Z</published>
    <updated>2022-09-10T10:15:27.884Z</updated>
    
    <content type="html"><![CDATA[<p>谨慎启用 Hyper-v ！，小心自动更新！</p><span id="more"></span><p>在安装完 Windows 10 的 1809版本之后，我的电脑两次出现了这样的情况：桌面变得非常卡，大概只有20帧的样子，在显示设置中出现了多个没有用的显示器，而我的笔记本并没有接上任何外接屏幕。</p><figure><img src="https://www.z4a.net/images/2019/02/25/005.hyper-v..png"alt="开启Hyper-v后出现多个多余显示器 | 微软社区" /><figcaption aria-hidden="true">开启Hyper-v后出现多个多余显示器 |微软社区</figcaption></figure><p>在百度之后确认了，多个显示器是因为我启用了 Hyper-v功能而多出来的，这可能是 win 10 的一个 Bug。而整个桌面的窗口变卡的原因有些不确定，因为在启用 Hyper-v之后还经历了一次 windows 更新。</p><p>我尝试过在设备管理器中禁用多余的显示器，使用系统保护回到上一个还原点都没有效果，百度谷歌到的情况相同的问题也都没有解决。真是万不得已，最终只好备份所有文件重置了。也不知道是什么原因导致的这个问题，可能和特定型号的硬件有关吧。难受！</p><p>所以，试用新版本的系统的时候一定要谨慎了，特别是在生产力机器上，一些奇怪的问题可能导致难以挽回的后果。</p><h2 id="一些马后炮措施">一些马后炮措施</h2><p>启用系统还原。在 控制面板-&gt; 高级系统设置(系统属性) -&gt; 系统保护中启用系统还原，每当进行重大操作的时候先建立一个还原点，在系统更新的时候也会自动创建还原点。出现问题的时候可以回退回去，需要的时间大约是20分钟。</p><p>关闭自动更新驱动。在 系统属性 -&gt; 硬件 -&gt; 设备安装设置中，“是否要自动下载适合你设备的制造商应用和自定义图标”选项，选择“否”来避免系统自动搜索、安装、更新驱动。最新版本的驱动程序不一定是最好的，特别是显卡驱动。</p><p>重置。最后的最后，如果一切都无法挽回了，Windows 10 有重置的功能，在设置 -&gt; 更新和安全 -&gt; 恢复中可以重置系统。这个选项会重置整台电脑，恢复出厂设置，相当于自己重装系统，但是保留了驱动程序，省得再安装一次，相比手动重装节省时间。恢复一次可能需要半个小时。</p><hr /><p>5月5日后记：现在升级到了 1903，打开沙盒模式或启用 Hyper-v的时候仍然会有多个屏幕，不过关闭功能之后重启两次就可以恢复了。</p><blockquote><p>参见：</p><ul><li><ahref="https://answers.microsoft.com/zh-hans/windows/forum/all/win10%E5%BC%80%E5%90%AFhyper/da75ba12-9a5a-43b3-b0dd-14ee98da23c6">win10开启Hyper-v后，多出四个非即插即用型监视器- Microsoft Community</a></li><li><a href="http://www.w10zj.com/Win10xy/Win10New_7359.html">win101709故障：开启 Hyper-v 后会出现多余的监视器 -W10之家</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;谨慎启用 Hyper-v ！，小心自动更新！&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="Windows" scheme="https://blog.beanbang.cn/tags/windows/"/>
    
    <category term="系统" scheme="https://blog.beanbang.cn/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>KMS 服务器 vlmcsd 的安装和激活</title>
    <link href="https://blog.beanbang.cn/2019/01/31/kms-server-vlmcsd/"/>
    <id>https://blog.beanbang.cn/2019/01/31/kms-server-vlmcsd/</id>
    <published>2019-01-31T09:27:52.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>微软防盗，批量授权。假传圣旨，在线激活~</p><span id="more"></span><p>KMS (Key Management Service) 是微软针对 Windows系统和软件的一种激活机制。通过在网络中设置 KMS服务器给局域网中的系统批量激活。用这种方式激活的机子有激活周期，一般是6个月。这样既使系统激活的步骤简化，也使激活范围限制在一定的范围之内。</p><p>后来微软的官方 KMS 服务器被反向破解了，于是有大神 Hotbird64制作了开源的仿真 KMS 服务器 vlmcsd （原帖<ahref="https://forums.mydigitallife.net/threads/emulated-kms-servers-on-non-windows-platforms.50234/">MyDigitalLife</a>），成为了一种盗版Windows的一种激活方式。模拟官方服务器，假传圣旨，激活一次，管用180天。</p><p>所以，即日起，小站开始提供 Windows 和 Office的<del>正版</del>激活服务啦！只要你的系统满足以下条件就可以使用该方法激活：</p><ol type="1"><li>使用的是批量授权的系统，即 VL 版本（Volume License）；</li><li>使用对应版本的 KMS 客户端安装密钥，即GVLK（Generic Volume LicensingKey）。</li></ol><p>一般来说，我们从 <ahref="https://msdn.itellyou.cn/">MSDN,我告诉你</a> 网站下载选择带 VL 、VOL 或 business edition字样的系统镜像，都会是可以使用KMS激活的版本，安装完后会自带GVLK密钥。</p><h2 id="激活">激活</h2><h3 id="windows">Windows</h3><p>使用管理员执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slmgr.vbs /skms kms.beanbang.cn     # 设置kms服务器</span><br><span class="line">slmgr.vbs /ato                      # 激活</span><br><span class="line">slmgr.vbs /xpr                      # 查看激活时效</span><br></pre></td></tr></table></figure><p>如果之前有过修改密钥的操作，可以将密钥修改回对应版本 GVLK。Win10专业版的密钥是<code>W269N-WFGWX-YVC9B-4J6C9-T83GX</code>，其他密钥可以去微软的<ahref="https://docs.microsoft.com/zh-cn/windows-server/get-started/kmsclientkeys">激活指南</a>里查找。如果不知道系统版本，可以运行<code>wmic os get caption</code>查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slmgr.vbs /upk                                      # 清除密钥</span><br><span class="line">slmgr.vbs /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX        # Win10专业版</span><br></pre></td></tr></table></figure><p>然后再添加上面的KMS服务器激活。</p><figure><img src="https://www.z4a.net/images/2019/01/31/win10.png"alt="win10激活成功" /><figcaption aria-hidden="true">win10激活成功</figcaption></figure><h3 id="office">Office</h3><p>管理员运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /d D:\Program Files\Microsoft Office\Office16    # office安装位置</span><br><span class="line">cscript ospp.vbs /sethst:kms.beanbang.cn            # 设置kms服务器</span><br><span class="line">cscript ospp.vbs /act                               # 立即激活</span><br></pre></td></tr></table></figure><p>如果需要 GVLK 同样可以在微软的 <ahref="https://docs.microsoft.com/zh-cn/DeployOffice/vlactivation/gvlks">文档</a>中找到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99  #2016专业增强版</span><br></pre></td></tr></table></figure><figure><img src="https://www.z4a.net/images/2019/01/31/office2016.png"alt="office2016激活成功" /><figcaption aria-hidden="true">office2016激活成功</figcaption></figure><p>如果在激活过程中出现问题，可以移步下载这个方便的图形化软件 <ahref="https://otp.landian.vip/zh-cn/">Office Tool Plus</a> 来操作：</p><figure><img src="https://www.z4a.net/images/2019/02/25/OTPoffice.png"alt="OTP图形化激活office" /><figcaption aria-hidden="true">OTP图形化激活office</figcaption></figure><h2 id="安装">安装</h2><p>vlmcsd 的服务端可以运行在 VPS上，也可以运行在相同局域网下的电脑上，树莓派上，甚至是手机上，只要 IP地址是可以到达的就可以。但是不能安装在被激活的电脑上，因为激活系统是会自己检测到的。</p><h3 id="docker">Docker</h3><p>2021年7月17日更新：来用 Docker 吧，省时省力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Lazyb0x/vlmcsd-docker.git vlmcsd</span><br><span class="line">cd vlmcsd</span><br><span class="line"></span><br><span class="line">git clone --branch master --single-branch https://github.com/Wind4/vlmcsd.git</span><br><span class="line"></span><br><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="服务器">服务器</h3><p>下载地址：<a href="http://rgho.st/69FdSgBdB">源码+可执行文件</a>密码2018 | <a href="https://github.com/Wind4/vlmcsd/releases">GithubReleases</a></p><p>在<code>binaries</code>目录中可以看到已经为各个操作系统和处理器编译好的可执行文件，进入到你的系统的对应CPU 架构目录中，一般都是<code>intel</code>，Linux系统不确定可以用<code>cat /proc/cpuinfo</code>命令查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/Wind4/vlmcsd/releases/download/svn1112/binaries.tar.gz</span><br><span class="line">tar -zxvf binaries.tar.gz</span><br><span class="line">cd binaries/Linux/intel/static/</span><br></pre></td></tr></table></figure><p>进入<code>static</code>目录下文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/vlmcsd/binaries/Linux/intel/static$ ls</span><br><span class="line">vlmcsdmulti-x64-musl-static          vlmcsd-x86-musl-static</span><br><span class="line">vlmcsdmulti-x86-musl-static          vlmcsd-x86-musl-static-threads</span><br><span class="line">vlmcsdmulti-x86-musl-static-threads  vlmcs-x64-musl-static</span><br><span class="line">vlmcsd-x64-musl-static               vlmcs-x86-musl-static</span><br></pre></td></tr></table></figure><p>vlmcsd 开头的就是服务端文件，vlmcs 用来检测运行的 KMS服务，vlmcsdmulti 有前面两个的功能。</p><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vlmcsd-x64-musl-static -l log.txt</span><br></pre></td></tr></table></figure><p>运行后会在 1688 端口上开启服务，所以记得需要在防火墙，VPS等设置上允许 1688 端口的 TCP 数据包通过。</p><p>结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -A|grep vlmcsd        # 得到进程号，比如11611</span><br><span class="line">kill 11611</span><br></pre></td></tr></table></figure><h3 id="虚拟机">虚拟机</h3><p>在Hotbitd64提供的压缩包内还有一个<code>floppy</code>文件夹内有一个不到2Mb大小的vfd 软盘映像文件，里面是一个微型激活系统，可以在各种虚拟机上，比如Vitrualbox ，Windows 自带的 Hyper-v上运行来激活系统，非常方便（这人也太厉害了8）。只有一个需要注意的问题，就是虚拟机的联网方式。</p><figure><img src="https://www.z4a.net/images/2019/01/31/virtualbox.png"alt="桥接网络和host-only模式都可以" /><figcaptionaria-hidden="true">桥接网络和host-only模式都可以</figcaption></figure><p>系统在激活的时候会检测服务器的 IP 地址，如果发现 ip 地址是本机ip，就会报错，激活失败。所以应该选择诸如<code>桥接网卡</code>等能够分配独立ip 且可以访问得到的联网方式。</p><figure><imgsrc="https://www.z4a.net/images/2019/01/31/3e53b15cc671043d70c08d2778acd5db.png"alt="虚拟机界面" /><figcaption aria-hidden="true">虚拟机界面</figcaption></figure><p>启动虚拟机后服务器就开始工作了，只要按照前面的操作，填写虚拟机上显示的的IPv4 地址就可以激活了。</p><p>最后，给这个二级域名做了一个简单的网页~ <ahref="http://kms.beanbang.cn/">kms.beanbang.cn</a></p><blockquote><p>参考资料</p><ul><li><ahref="https://forums.mydigitallife.net/threads/emulated-kms-servers-on-non-windows-platforms.50234/">EmulatedKMS Servers on non-Windows platforms | My Digital Life Forums</a></li><li><ahref="https://03k.org/kms.html">本站上线KMS服务~一句命令激活windows/office| 零散坑</a>（详细的激活教程）</li><li><ahref="http://www.hejinjun.cn/faqs/92.html">自建KMS激活服务器的两种方法电脑问题 | 花火时光</a></li><li><ahref="http://blog.sina.com.cn/s/blog_a0c06a350102wxyy.html#commonComment">Windows版本和授权激活方式介绍(KMS MAK)_godspeed_新浪博客</a></li><li><ahref="https://github.com/YerongAI/Office-Tool/wiki/%5B简体-zh_cn%5D-使用手册#office-激活方法以及步骤">OfficeToolPlus说明文档 · GitHub</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;微软防盗，批量授权。假传圣旨，在线激活~&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="Windows" scheme="https://blog.beanbang.cn/tags/windows/"/>
    
    <category term="系统" scheme="https://blog.beanbang.cn/tags/os/"/>
    
    <category term="KMS" scheme="https://blog.beanbang.cn/tags/kms/"/>
    
    <category term="树莓派" scheme="https://blog.beanbang.cn/tags/raspberry-pi/"/>
    
    <category term="网络" scheme="https://blog.beanbang.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>MultiMC的离线模式启动</title>
    <link href="https://blog.beanbang.cn/2018/12/11/launch-mc-offline-with-multimc/"/>
    <id>https://blog.beanbang.cn/2018/12/11/launch-mc-offline-with-multimc/</id>
    <published>2018-12-11T15:15:51.000Z</published>
    <updated>2022-09-10T10:15:27.883Z</updated>
    
    <content type="html"><![CDATA[<p>新发现了一个功能强大的启动器：MultiMC。这是一个第三方开源的 Minecraft启动器，由于是用 Qt 编写的，启动器可以在多个平台上运行。</p><span id="more"></span><figure><imgsrc="https://www.z4a.net/images/2018/12/11/004.MultiMC7da8568036b14860.png"alt="MultiMC主界面" /><figcaption aria-hidden="true">MultiMC主界面</figcaption></figure><p>MultiMC 有丰富的启动选项，能够方便地安装 Forge mod，Optifine等插件。它的 UI 和官方启动器，HMCl都有点不同。文件结构也和原版游戏不一样（不过大体的结构还是相似的），这样更容易在启动器中管理mod，截图等资源。第一次运行时 MultiMC会下载对应版本的游戏，不想等的话可以去已有的游戏的<code>.minecraft</code>文件夹下把<code>assets</code>和<code>libraries</code>文件夹拷贝到MultiMC 的目录下来。</p><figure><img src="https://www.z4a.net/images/2018/12/11/004.MultiMC.png"alt="MultiMC无账号提示" /><figcaption aria-hidden="true">MultiMC无账号提示</figcaption></figure><p>不过呢，不像其他的第三方启动器，MultiMC必须要登录游戏账号后才能启用离线模式，这么做的目的应该是为了支持正版。其实无正版账号体验这个启动器也是可以的:P。</p><figure><img src="https://www.z4a.net/images/2020/02/07/004.multimc-account.png"alt="MultiMC的账号配置文件内容" /><figcaption aria-hidden="true">MultiMC的账号配置文件内容</figcaption></figure><p>登录一次后，我的<code>accounts.json</code>文件多了一些参数。只要稍加改动，确保包含这些参数项就可以了，比如这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;accounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;accessToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;activeProfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;clientToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;legacy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一个离线账号&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;formatVersion&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>打开启动器就能用这个空的账号启动离线模式游戏了。</p><blockquote><p>另见：</p><ul><li><a href="https://sspai.com/post/47690">强大的 Minecraft启动器：MultiMC - 少数派</a></li><li><a href="https://github.com/MultiMC/MultiMC5/">Github:MultiMC/MultiMC5</a></li><li><a href="https://multimc.org/">MultiMC（官网）</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;新发现了一个功能强大的启动器：MultiMC。这是一个第三方开源的 Minecraft
启动器，由于是用 Qt 编写的，启动器可以在多个平台上运行。&lt;/p&gt;</summary>
    
    
    
    <category term="MC" scheme="https://blog.beanbang.cn/categories/mc/"/>
    
    
    <category term="Minecraft" scheme="https://blog.beanbang.cn/tags/minecraft/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透和反向代理软件</title>
    <link href="https://blog.beanbang.cn/2018/10/21/nat-penetration-and-reverse-proxy/"/>
    <id>https://blog.beanbang.cn/2018/10/21/nat-penetration-and-reverse-proxy/</id>
    <published>2018-10-21T15:45:20.000Z</published>
    <updated>2022-09-10T10:15:27.884Z</updated>
    
    <content type="html"><![CDATA[<p>内网穿透，又叫NAT穿透、端口映射、端口转发、反向代理、内网转外网/公网……</p><span id="more"></span><h2 id="原理">原理</h2><p>由于IPv4地址的缺乏，运营商们越来越少给我们提供公网IP，即使能够分配到公网IP，也是动态ip，在网络断开重新链接后IP地址就会改变。而我们使用交换机、路由器，使得我们处于“专用网”中，用<code>ipconfig</code>(Linux用<code>ifconfig</code>)查询本机IP会得到下面的几类局域网地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A类：10.0.0.0    到 10.255.255.255    (10.0.0.0/8)</span><br><span class="line">B类：172.16.0.0  到 172.31.255.255    (172.16.0.0/12)</span><br><span class="line">C类：192.168.0.0 到 192.168.255.255   (192.168.0.0/16)</span><br></pre></td></tr></table></figure><p>校园网经常分配到上面的A类地址，运营商的宽带可能分配到172开头的地址；而家用路由器分配的是192.168开头的地址。然后我们通过网络地址转换协议NAT 转换IP地址进行上网。</p><figure><img src="https://www.z4a.net/images/2018/10/21/reverse-proxy-02-1.jpg"alt="反向代理图解|Imperva" /><figcaption aria-hidden="true">反向代理图解|Imperva</figcaption></figure><p>所以，拥有一个公网IP就相当于处在各种网络的最外层，可以直接和其他主机进行通信。而处在NAT路由器内的主机的通信必须由专用网内的主机发起。因为如果是外部主机发起的通信的话，路由器不知道要将数据包转发给专用网中的哪一个主机。于是就有了反向代理的工作方式，把一台处于内网中的主机和一台拥有公网IP的主机的端口绑定，然后由公网主机将来自外部的请求转交给内网主机。这样，就实现了内网主机作为服务器的功能。</p><h2 id="软件">软件</h2><p>接下来推荐几个好用的内网穿透/反向代理软件：</p><h3 id="ddns-动态域名解析端口映射">DDNS (动态域名解析+端口映射)</h3><p>这个其实不算是软件吧，算是路由器应用…</p><ul><li>路由器/猫</li><li>有动态公网IP</li><li>管理员权限</li></ul><p>大多数的家庭宽带还是会分配公网IP地址的（除了一些二级运营商比如移动），只不过是临时的动态IP，断开重新拨号后IP地址就会改变。大部分路由器会提供动态域名解析的功能，虽然IP会经常变化，只要有一个域名指向这个IP地址就可以了。</p><p>打开路由器的设置界面，通常有一个叫DDNS或类似域名动态解析的选项。在动态域名服务的提供商那里注册账号，选一个二级域名，然后在路由器里面填上用户名和密码。设置完<code>ping</code>一下你的二级域名比如xxx.wicp.net，如果返回的是你的路由器的IP地址，就说明设置成功了。</p><figure><imgsrc="https://www.z4a.net/images/2018/10/23/ae5453e9e16d8ba4d070ce1ea4c0a43b.png"alt="路由器的端口映射设置" /><figcaption aria-hidden="true">路由器的端口映射设置</figcaption></figure><p>现在外部请求已经能够到达路由器了，接下来在路由器里设置端口映射(有的叫虚拟服务器)，将路由器的特定端口和局域网内的主机绑定，这样特定的服务就能够和局域网内特定的主机通信了。</p><p>通过动态域名和端口映射的方法局限性很大。在家里，我们知道路由器的密码，有更改路由器设置的权限；在学校的校园网，宿舍的个人网呢？如果被分配在多层子网中，你需要一层一层地联络网络管理员给你开放端口，还不能保证他们一定会给你开……遇到这种情况我们还是另辟蹊径吧。</p><h3 id="ssh--r">ssh -R</h3><ul><li>最最方便的方法</li><li>无需额外软件</li><li>跨平台</li><li>需要VPS</li></ul><p>新版的Win10已经自带<code>OpenSSH</code>了，在<code>设置</code> -&gt;<code>应用</code> -&gt; <code>应用和功能</code> -&gt;<code>管理可选功能</code>中可以启用。</p><figure><img src="https://www.z4a.net/images/2018/10/21/openssh-in-win10.png"alt="win10开启OpenSSH" /><figcaption aria-hidden="true">win10开启OpenSSH</figcaption></figure><p>OpenSSH提供了三种端口转发功能：正向代理（local），反向代理（remote），以及动态代理（dynamic）。在这里，我们用到的是它的反向代理功能。</p><p>只需要一句命令即可开启端口转发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=60 -R 8888:127.0.0.1:3389 beanbang@121.29.54.117</span><br></pre></td></tr></table></figure><p>执行命令，输入密码，进入终端就已经建立了从本机的3389端口到服务器的8888端口的链接。现在，你就可以在远程桌面中通过地址<code>121.29.54.117:8888</code>来连接你的主机了。其中<code>-o ServerAliveInterval=60</code>项是为了防止长时间无操作被关闭连接，每隔60秒向服务器发送信号。</p><p>如果开启失败可能是服务器端没有启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config    <span class="comment">#添加一行  GatewayPorts  yes</span></span><br><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><p>以及记得在防火墙中允许特定端口的通信。</p><h3 id="frp">frp</h3><ul><li>安装方便</li><li>跨平台</li><li>功能强大</li><li>需要VPS</li></ul><p>frp（fast reverse proxy）是一个功能强大的开源反向代理软件。在GitHub上面有详细的<ahref="https://github.com/fatedier/frp/blob/master/README_zh.md">中文说明</a>。</p><p>可以很轻松地配置简单的端口转发。只要<ahref="https://github.com/fatedier/frp/releases">下载</a>对应架构的程序放到相应的操作系统上。公网IP的主机使用frps 和 frps.ini，内网主机则使用 frpc 和 frpc.ini。</p><p>解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.21.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>编辑<code>frps.ini</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">dashboard_user = username</span><br><span class="line">dashboard_pwd = password</span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><p>启动 frps：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p>编辑<code>frpc.ini</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 121.29.54.117</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 8888</span><br></pre></td></tr></table></figure><p>启动 frpc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><p>服务端和客户端都启动后，就可以通过<code>121.29.54.117:8888</code>来连接远程主机了，还可以访问http://121.29.54.117:7500 来打开frp的 Dashboard界面，用网页的形式查看各种相关信息。</p><figure><imgsrc="https://www.z4a.net/images/2018/10/21/frps-dashboard-2018-10-21.png"alt="frps的dashboard界面" /><figcaption aria-hidden="true">frps的dashboard界面</figcaption></figure><p>开发者细心地编译了多种操作系统架构的程序使得我们可以方便地下载和使用，比如树莓派就可以使用其arm-64 版本来架设小型服务器。</p><h3 id="路由侠等内网映射服务">路由侠等内网映射服务</h3><ul><li>Windows系统</li><li>图形界面，操作简单</li><li>服务型，额外付费</li></ul><p>路由侠适合那些没有自己的公网服务器，只需要临时连接，或者不想要自己折腾的人。类似的这种软件还有花生壳、net123、蛤蟆吃（hamachi）等等。这些算是提供服务类型的软件了。只要安装上客户端，进行简单的配置就可以使用它们的服务了。</p><p>不过没有免费的午餐，这些软件往往提供有限制的免费套餐，然后提供附加的服务进行收费。比如路由侠就限制1个月1G的流量，1Mb的带宽。提供给你一个二级域名和端口号，用这个域名和端口来访问服务。</p><p>想当年和小伙伴玩Minecraft开服用的就是路由侠。在电脑上架上CraftBukkit服务器，然后开放地址开一起来开荒。后来买了vps，服务器就搬到vps上面去了。</p><figure><img src="https://www.z4a.net/images/2018/10/21/mstsc.png"alt="mstsc开启映射网络驱动器" /><figcaption aria-hidden="true">mstsc开启映射网络驱动器</figcaption></figure><p>其实，端口映射我用的最多的还是远程桌面。去机房上机的时候，打开 mstsc，远程桌面连上自己的电脑。这样避免了机房电脑渣机运行缓慢，而且实验结束不用拿U盘拷走实验结果，文件也可以直接传回电脑去。特别的方便有木有？</p><hr /><blockquote><p>参考资料：</p><ul><li><ahref="https://www.incapsula.com/cdn-guide/glossary/reverse-proxy.html">Whatis a Reverse Proxy Server | Reverse vs. Forward Proxy | CDN Guide |Incapsula</a></li><li><ahref="http://service.tp-link.com.cn/detail_article_2441.html">[云路由器]如何映射服务器到外网 - TP-LINK 服务支持</a></li><li><a href="https://www.cnblogs.com/phpdragon/p/5314650.html">使用 ssh-R 穿透局域网访问内部服务器主机，反向代理 无人值守化 - phpdragon -博客园</a></li><li><a href="https://www.zhihu.in/archives/2119">内网穿透工具frpWindows客户端frpc安装及使用教程 | 直呼过瘾</a></li><li><ahref="https://github.com/fatedier/frp/blob/master/README_zh.md">frp-中文文档-GitHub</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;内网穿透，又叫NAT穿透、端口映射、端口转发、反向代理、内网转外网/公网……&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://blog.beanbang.cn/categories/software/"/>
    
    
    <category term="网络" scheme="https://blog.beanbang.cn/tags/network/"/>
    
    <category term="DDNS" scheme="https://blog.beanbang.cn/tags/ddns/"/>
    
    <category term="frp" scheme="https://blog.beanbang.cn/tags/frp/"/>
    
    <category term="SSH" scheme="https://blog.beanbang.cn/tags/ssh/"/>
    
    <category term="内网穿透" scheme="https://blog.beanbang.cn/tags/nat-penetration/"/>
    
    <category term="反向代理" scheme="https://blog.beanbang.cn/tags/reverse-proxy/"/>
    
    <category term="远程桌面" scheme="https://blog.beanbang.cn/tags/remote-desktop/"/>
    
  </entry>
  
  <entry>
    <title>给站点开启SSL/HTTPS</title>
    <link href="https://blog.beanbang.cn/2018/10/09/enable-ssl-https-for-website/"/>
    <id>https://blog.beanbang.cn/2018/10/09/enable-ssl-https-for-website/</id>
    <published>2018-10-08T16:07:26.000Z</published>
    <updated>2022-09-10T10:15:27.884Z</updated>
    
    <content type="html"><![CDATA[<p>给网站地址栏上添加绿色小锁：我变绿了，也变安全了。</p><span id="more"></span><p>国庆旅游归来早，忙趁假期瞎折腾。</p><h2 id="为什么要使用https">为什么要使用https</h2><ol type="1"><li>SSL是应用层和运输层之间的加密协议，相比于http的明文传输来的更加安全。SSL能够有效降低中间人攻击的风险。比如使用<code>Fiddler</code>软件抓取https包的时候就需要先向浏览器添加自己的<code>CA</code>证书，因为没有证书信任的话就无法获得加密的内容。</li></ol><figure><img src="https://www.z4a.net/images/2018/10/24/SSL.png"alt="SSL安全会话建立过程 | 《计算机网络》" /><figcaption aria-hidden="true">SSL安全会话建立过程 |《计算机网络》</figcaption></figure><ol start="2" type="1"><li>全站https有利于提升网站在搜索引擎的收入率。在相同权重的情况下，搜索引擎会认为https站点的安全性更高而将网站排在前面。</li><li>站点使用https可以让自己的站点更加醒目（说白了就是想装13啦）。</li></ol><h2 id="申请ssl证书">申请SSL证书</h2><p>有许多的免费SSL证书提供商。我用的是腾讯云的<code>DV SSL</code>证书。在<ahref="https://console.cloud.tencent.com/ssl">这里</a>可以申请<code>TrustAsia</code>提供的免费证书，为期1年。（顺便瞟了一眼<code>OV</code>和<code>EV</code>的企业付费证书，价格基本5k以上…）</p><p>申请需要验证你的主机和域名，会要求在指定位置放置验证文件或者给域名添加一条解析记录。如果你的域名也是从腾讯云买的，它会给你自动添加。验证的速度很快，大约10分钟就能审核通过。</p><p>如果你等了1小时还没通过就别等了，赶紧检查一下自己填的信息有没有错吧，不要像我一样把域名打错了然后傻等了一天TT。</p><figure><imgsrc="https://www.z4a.net/images/2018/10/08/1dce2ec27b1338b2dc60beded5cf874c.png"alt="证书文件" /><figcaption aria-hidden="true">证书文件</figcaption></figure><p>审核通过后会颁发的证书可以下载到本地。打开后里面有为各种http服务器使用的证书和密钥文件。我用的是<code>Apache</code>，就把Apache文件夹下的3个文件上传到服务器上。</p><h2 id="编辑apache配置">编辑Apache配置</h2><p>编辑 etc/httpd.conf文件，找到<code>#LoadModule ssl_module modules/mod_ssl.so</code>和<code>#Include conf/extra/httpd-ssl.conf</code>，去掉前面的#号注释，启用SSL模组。</p><p>编辑<code>/lampp/etc/extra/httpd-ssl.conf</code>文件添加主机和证书：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> <span class="attr">0.0.0.0:443</span>&gt;</span></span><br><span class="line">    DocumentRoot &quot;/opt/lampp/htdocs/wordpress/&quot;</span><br><span class="line">    ServerName blog.beanbang.cn</span><br><span class="line">    SSLEngine on</span><br><span class="line">    SSLCertificateFile /opt/lampp/ssl-crt/2_blog.beanbang.cn.crt</span><br><span class="line">    SSLCertificateKeyFile /opt/lampp/ssl-crt/3_blog.beanbang.cn.key</span><br><span class="line">    SSLCertificateChainFile /opt/lampp/ssl-crt/1_root_bundle.crt</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成后需要重启Apache服务器。</p><h2 id="开启443端口">开启443端口</h2><p>https协议使用的不是80端口而是443端口。如果有防火墙记得允许443端口的<code>TCP</code>数据包通过。</p><figure><img src="https://www.z4a.net/images/2018/10/08/TCP443.png"alt="在安全组中允许TCP443端口" /><figcaption aria-hidden="true">在安全组中允许TCP443端口</figcaption></figure><h2 id="wordpress设置">Wordpress设置</h2><p>wordpress目录下的<code>.htaccess</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_rewrite.c</span>&gt;</span></span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line">RewriteCond %&#123;HTTPS&#125; !=on</span><br><span class="line">RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [L,R=301]</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样使用http访问网页会被<code>301</code>永久重定向至https页面。</p><p>编辑<code>wp-config.php</code>：</p><p>在 “if ( !defined('ABSPATH') )”前面，即"请不要再继续编辑”的提示前面添加。这样登陆博客时会强制使用https以保障安全。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTPS&#x27;</span>] = <span class="string">&#x27;ON&#x27;</span>; <span class="comment">//网页下的链接全部由&#x27;http://&#x27;转换为&#x27;https://&#x27;</span></span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;FORCE_SSL_LOGIN&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;FORCE_SSL_ADMIN&#x27;</span>, <span class="literal">true</span>); <span class="comment">//管理员登陆博客时跳转为https</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 好了！请不要再继续编辑。请保存本文件。使用愉快！ */</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="title function_ invoke__">defined</span>(<span class="string">&#x27;ABSPATH&#x27;</span>) )</span><br></pre></td></tr></table></figure><h2 id="更改域名信息固定链接">更改域名信息、固定链接？</h2><p>在有的教程里面还说需要像更换域名那样把全站的数据库中所有的“http”链接全部转换成“https”。其实不推荐也不需要这么做。上面的<code>$_SERVER['HTTPS'] = 'ON';</code>设置过以后，wordpress是会自动识别转换的。</p><h2 id="结束">结束</h2><p>现在，打开网站 <ahref="https://blog.beanbang.cn">https://blog.beanbang.cn</a>就可以正常访问了。即使是不加https前缀也能自动跳转到https。由于中间环节多了一个验证加密的步骤，网站打开的时间会比以往更长一些。</p><figure><img src="https://www.z4a.net/images/2018/11/04/https.png"alt="网站https标志" /><figcaption aria-hidden="true">网站https标志</figcaption></figure><hr /><blockquote><p>参考资料</p><ul><li><ahref="https://cloud.tencent.com/document/product/400/4143">证书安装指引- SSL 证书 - 文档平台 - 腾讯云</a></li><li><a href="https://adcc.me/399.html">wordpresshttp强制跳转https，我是这么做的，真正的零故障|永云博客</a></li><li><a href="https://ws234.com/344.html">WordPress启用https访问实战教程| 王商博客</a></li><li><ahref="https://www.sizuo.org/wordpress-https.html">Wordpress使用SSL证书开启HTTPS最简单的办法- 四座</a></li><li><ahref="https://blog.csdn.net/ithomer/article/details/78075006">十大免费SSL证书：网站免费添加HTTPS加密- 阳光岛主 - CSDN博客</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;给网站地址栏上添加绿色小锁：我变绿了，也变安全了。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://blog.beanbang.cn/categories/log/"/>
    
    
    <category term="安全" scheme="https://blog.beanbang.cn/tags/security/"/>
    
    <category term="Apache" scheme="https://blog.beanbang.cn/tags/apache/"/>
    
    <category term="HTTPS" scheme="https://blog.beanbang.cn/tags/https/"/>
    
    <category term="SSL" scheme="https://blog.beanbang.cn/tags/ssl/"/>
    
    <category term="Wordpress" scheme="https://blog.beanbang.cn/tags/wordpress/"/>
    
  </entry>
  
</feed>
